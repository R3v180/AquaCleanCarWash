# √çNDICE DE ARCHIVOS (ESTRUCTURA REFACTORIZADA)

1. .gitignore
2. .schemas/turbo-schema-v1.json
3. PROXIMOS_PASOS.md
4. README.md
5. ROADMAP.md
6. WORKFLOW.md
7. apps/client/index.html
8. apps/client/package.json
9. apps/client/src/App.tsx
10. apps/client/src/components/admin/AbsenceCalendar.tsx
11. apps/client/src/components/admin/AppointmentForm.tsx
12. apps/client/src/components/admin/ConflictResolutionModal.tsx
13. apps/client/src/components/admin/ScheduleEditor.tsx
14. apps/client/src/components/admin/ServiceForm.tsx
15. apps/client/src/components/booking/BookingDateTimePicker.tsx
16. apps/client/src/components/common/PublicFooter.module.css
17. apps/client/src/components/common/PublicFooter.tsx
18. apps/client/src/components/common/PublicHeader.module.css
19. apps/client/src/components/common/PublicHeader.tsx
20. apps/client/src/components/home/FeaturedReviews.tsx
21. apps/client/src/custom.d.ts
22. apps/client/src/layouts/AdminLayout.tsx
23. apps/client/src/layouts/CustomerLayout.tsx
24. apps/client/src/layouts/PublicLayout.tsx
25. apps/client/src/lib/apiClient.ts
26. apps/client/src/main.tsx
27. apps/client/src/pages/admin/AdminDashboardPage.tsx
28. apps/client/src/pages/admin/AdminLoginPage.tsx
29. apps/client/src/pages/admin/AdminPlanningPage.tsx
30. apps/client/src/pages/admin/BusinessSettingsPage.tsx
31. apps/client/src/pages/admin/EmployeesManagementPage.tsx
32. apps/client/src/pages/admin/ReviewsManagementPage.tsx
33. apps/client/src/pages/admin/ServicesManagementPage.tsx
34. apps/client/src/pages/customer/CustomerAppointmentsPage.tsx
35. apps/client/src/pages/customer/CustomerDashboardPage.tsx
36. apps/client/src/pages/public/BookingPage.tsx
37. apps/client/src/pages/public/HomePage.module.css
38. apps/client/src/pages/public/HomePage.tsx
39. apps/client/src/pages/public/LoginPage.tsx
40. apps/client/src/pages/public/RegisterPage.tsx
41. apps/client/src/pages/public/ReviewPage.tsx
42. apps/client/src/pages/public/ServicesPage.tsx
43. apps/client/src/pages/public/TeamPage.tsx
44. apps/client/tsconfig.json
45. apps/client/tsconfig.node.json
46. apps/server/.env
47. apps/server/package.json
48. apps/server/prisma/schema.prisma
49. apps/server/prisma/seed.ts
50. apps/server/src/api/adminAppointments.routes.ts
51. apps/server/src/api/adminDashboard.routes.ts
52. apps/server/src/api/adminDateOverrides.routes.ts
53. apps/server/src/api/adminSettings.routes.ts
54. apps/server/src/api/auth.routes.ts
55. apps/server/src/api/availability.routes.ts
56. apps/server/src/api/bookings.routes.ts
57. apps/server/src/api/customer.routes.ts
58. apps/server/src/api/customerAuth.routes.ts
59. apps/server/src/api/employees.routes.ts
60. apps/server/src/api/reviews.routes.ts
61. apps/server/src/api/services.routes.ts
62. apps/server/src/lib/availabilityService.ts
63. apps/server/src/lib/cronService.ts
64. apps/server/src/lib/cronService_24h.ts
65. apps/server/src/lib/notificationService.ts
66. apps/server/src/lib/prisma.ts
67. apps/server/src/server.ts
68. apps/server/tsconfig.json
69. docs/PROJECT_SPECIFICATION.md
70. docs/features/01-authentication.md
71. docs/features/02-public-site.md
72. docs/features/03-booking-flow.md
73. docs/features/04-customer-panel.md
74. docs/features/05-admin-panel-core-management.md
75. docs/features/06-admin-panel-operations.md
76. docs/features/07-reviews-system.md
77. docs/features/08-marketing-monetization.md
78. docs/features/09-notifications-system.md
79. docs/features/10-external-integrations.md
80. package.json
81. packages/config/eslint-preset.js
82. packages/config/package.json
83. packages/types/package.json
84. packages/types/src/employee.schema.ts
85. packages/types/src/index.ts
86. packages/types/src/service.schema.ts
87. packages/types/src/service.ts
88. packages/types/tsconfig.json
89. tsconfig.base.json
90. tsconfig.json
91. turbo.json


# CONTENIDO DE ARCHIVOS


// ====== [1] .gitignore ======
# Ignorar dependencias
node_modules/

# Ignorar archivos de build y distribuci√≥n
dist/
build/

# Ignorar variables de entorno
.env
.env.*
!.env.example

# Archivos de sistema operativo
.DS_Store

# Logs y archivos de debug
*.log
.pnpm-debug.log*

# Ignorar cach√© de herramientas
.eslintcache
.vite-cache


// ====== [2] .schemas/turbo-schema-v1.json ======
{
  "$id": "https://json.schemastore.org/turbo",
  "title": "Turborepo configuration file",
  "type": "object",
  "properties": {
    "$schema": {
      "type": "string"
    },
    "extends": {
      "description": "A list of packages to extend the configuration from. Can be a path to a local file or a package name.",
      "type": "array",
      "items": {
        "type": "string"
      }
    },
    "globalDependencies": {
      "description": "A list of file glob patterns that Turborepo will use to determine if a task should be executed.",
      "type": "array",
      "items": {
        "type": "string"
      }
    },
    "globalEnv": {
      "description": "A list of environment variables that are used by all tasks. These variables are passed to the tasks as environment variables.",
      "type": "array",
      "items": {
        "type": "string"
      }
    },
    "pipeline": {
      "description": "The pipeline configuration for the Turborepo.",
      "type": "object",
      "additionalProperties": {
        "type": "object",
        "properties": {
          "cache": {
            "description": "Whether or not to cache the task.",
            "type": "boolean"
          },
          "dependsOn": {
            "description": "A list of tasks that this task depends on.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "outputs": {
            "description": "A list of file glob patterns that are the outputs of the task.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "env": {
            "description": "A list of environment variables that are used by the task.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "outputMode": {
            "description": "The output mode of the task.",
            "type": "string",
            "enum": [
              "full",
              "hash-only",
              "new-only",
              "none"
            ]
          },
          "persistent": {
            "description": "Whether or not the task is a persistent task.",
            "type": "boolean"
          }
        },
        "additionalProperties": false
      }
    }
  },
  "additionalProperties": false
}


// ====== [3] PROXIMOS_PASOS.md ======
<!-- File: /PROXIMOS_PASOS.md - v5.0 (Finalizar Panel de Cliente) -->

# Pr√≥ximos Pasos: Finalizar el Panel de Cliente

Este documento define el siguiente objetivo clave del desarrollo tras la implementaci√≥n del n√∫cleo del panel de cliente y el sistema de valoraciones.

---

### ‚úÖ **Hito Alcanzado: Ecosistema del Cliente Implementado (v1)**

Se ha finalizado con √©xito la implementaci√≥n de un ciclo de vida completo para el cliente. Los logros clave incluyen:

- **Autenticaci√≥n de Clientes:** Sistema completo de registro, login y gesti√≥n de sesiones.
- **Reservas Flexibles:** La plataforma ahora soporta reservas de usuarios registrados, invitados y nuevos usuarios que se registran durante el proceso.
- **Sistema de Valoraciones Completo:** Automatizaci√≥n de la solicitud de rese√±as por Email/WhatsApp con tokens seguros, y un panel de moderaci√≥n funcional para el administrador.
- **Panel de Cliente (Base):** Implementaci√≥n de un √°rea de cliente protegida (`/dashboard`) con una p√°gina funcional de "Mis Citas".
- **Autogesti√≥n de Citas:** Los clientes ahora pueden cancelar sus propias citas desde su panel.

---

### üéØ **PR√ìXIMO OBJETIVO: Implementar la Funcionalidad "Reservar de Nuevo"**

El siguiente paso es a√±adir una de las funcionalidades de fidelizaci√≥n m√°s importantes: permitir a los clientes volver a reservar un servicio pasado con un solo clic, reduciendo la fricci√≥n al m√≠nimo.

La implementaci√≥n se centrar√° exclusivamente en el frontend:

1.  **Modificar `CustomerAppointmentsPage.tsx`:**
    - Se a√±adir√° la l√≥gica al bot√≥n "Reservar de Nuevo" en las tarjetas de citas del historial.
    - Al hacer clic, la aplicaci√≥n navegar√° a la p√°gina `/booking`.
    - Se pasar√°n los datos clave de la cita (como `serviceId` y `employeeId`) a trav√©s de par√°metros en la URL (ej: `/booking?serviceId=...&employeeId=...`).

2.  **Modificar `BookingPage.tsx`:**
    - Se mejorar√° el `useEffect` inicial para que detecte la presencia de estos par√°metros en la URL al cargar la p√°gina.
    - Si los par√°metros existen, se usar√°n para pre-seleccionar autom√°ticamente el servicio y/o el profesional en los campos correspondientes, presentando al cliente un flujo de reserva casi completo.



// ====== [4] README.md ======
<!-- File: /README.md - v1.4 (ACTUALIZADO CON √öLTIMOS AVANCES) -->
<div align="center">
  <img src="./docs/assets/logo.png" alt="AquaClean Car Wash Logo" width="200"/>
</div>

# AquaClean Car Wash - Plataforma de Gesti√≥n y Reservas

![Versi√≥n](https://img.shields.io/badge/version-1.1.0-blue)
![Estado](https://img.shields.io/badge/status-en--desarrollo-green)
![Licencia](https://img.shields.io/badge/licencia-privada-red)

Una soluci√≥n web completa para lavaderos de coches que automatiza las reservas, optimiza la gesti√≥n de clientes y potencia el marketing digital. Este proyecto est√° dise√±ado para ser una base robusta y reutilizable para negocios del sector.

---

## üé• Demo Visual

<!-- TODO: A√±adir un GIF animado mostrando el flujo de reserva del cliente y el panel de administraci√≥n -->
<div align="center">
  *Pr√≥ximamente: Una demostraci√≥n visual del producto en acci√≥n.*
</div>

---

## ‚ú® Caracter√≠sticas Principales

| Caracter√≠stica                          | Estado                       | Descripci√≥n                                                                                                                                                              |
| :-------------------------------------- | :--------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| üìÖ **Sistema de Reservas 24/7**         | üü¢ Implementado              | Permite a clientes (registrados o invitados) ver la disponibilidad en tiempo real y reservar una cita.                                                                   |
| üìä **Panel de Administraci√≥n Completo** | üü¢ Implementado              | Centro de control para gestionar citas, servicios, empleados y horarios. Incluye un dashboard con KPIs, planning visual interactivo y un panel de moderaci√≥n de rese√±as. |
| ‚≠ê **Sistema de Valoraciones**          | üü¢ Implementado              | Automatiza la solicitud de rese√±as post-servicio por Email/WhatsApp y permite moderarlas antes de mostrarlas p√∫blicamente en la web.                                     |
| üîî **Notificaciones Autom√°ticas**       | üü¢ Implementado              | Confirmaciones de reserva y recordatorios 24h antes por Email/WhatsApp para reducir las ausencias y mantener a todos informados.                                         |
| üë§ **Panel de Cliente**                 | üü° Parcialmente Implementado | Los clientes pueden registrarse, iniciar sesi√≥n y ver su historial de citas, con opci√≥n de cancelar las futuras.                                                         |
| üí≥ **M√∫ltiples V√≠as de Ingreso**        | ‚è≥ Pendiente                 | Soporte para bonos, tarjetas regalo y suscripciones mensuales para fidelizar clientes y generar ingresos recurrentes.                                                    |
| üîó **Integraciones Clave**              | ‚è≥ Pendiente                 | Sincronizaci√≥n bidireccional con Google Calendar y pasarela de pagos segura con Stripe.                                                                                  |
| üì± **Dise√±o 100% Adaptativo**           | üü° Parcialmente Implementado | La experiencia de usuario es funcional en m√≥vil, tablet y ordenador, con mejoras de pulido pendientes.                                                                   |

---

## üõ†Ô∏è Stack Tecnol√≥gico

| √Årea                                     | Tecnolog√≠as                                                        |
| :--------------------------------------- | :----------------------------------------------------------------- |
| **Frontend**                             | React 18, TypeScript, Vite, Mantine UI, Zustand                    |
| **Backend**                              | Node.js, Express.js, TypeScript, Prisma, Zod                       |
| **Base de Datos**                        | PostgreSQL                                                         |
| **Testing**                              | Vitest, React Testing Library                                      |
| **Herramientas de Desarrollo y Calidad** | pnpm (Monorepo), Git, GitHub, ESLint, Prettier, Husky, lint-staged |

---

## üöÄ C√≥mo Empezar (Gu√≠a para Desarrolladores)

<details>
<summary><strong>Haz clic aqu√≠ para ver las instrucciones</strong></summary>

### Requisitos Previos

- Node.js (v20+), pnpm (v9+), Git, una instancia de PostgreSQL.

### Pasos

1. Clonar: `git clone https://github.com/R3v180/AquaCleanCarWash.git`
2. Instalar: `pnpm install`
3. Configurar: Copia `apps/server/.env.example` a `.env` y rellena las variables.
4. Migrar: `pnpm --filter server run migrate:dev`
5. Poblar: `pnpm --filter server run prisma:seed`
6. Iniciar: `pnpm dev`

</details>

---

## üó∫Ô∏è Roadmap del Proyecto

Para ver el plan de desarrollo detallado por fases, consulta nuestro archivo [**ROADMAP.md**](./ROADMAP.md).

## üìÑ Especificaciones Completas

Toda la funcionalidad del proyecto est√° documentada en detalle en nuestra [**Especificaci√≥n de Proyecto**](./docs/PROJECT_SPECIFICATION.md).



// ====== [5] ROADMAP.md ======
<!-- File: /ROADMAP.md - v2.1 (Panel de Cliente en Progreso) -->

# Roadmap del Proyecto AquaClean Car Wash

Este documento describe el plan de desarrollo por fases para la plataforma. El objetivo es lanzar un Producto M√≠nimo Viable (MVP) funcional y luego iterar sobre √©l a√±adiendo capas de valor en versiones posteriores.

---

## üöß Versi√≥n 1.0: MVP - Lanzamiento y Operaciones Core

**Objetivo:** Poner en marcha la funcionalidad esencial para que el negocio pueda recibir y gestionar reservas online.

- **‚úÖ Sitio P√∫blico B√°sico:**
  - [‚úÖ] P√°gina de Inicio (Homepage) y Navegaci√≥n principal.
  - [‚úÖ] P√°gina de Servicios detallada.
  - [‚úÖ] Perfiles p√∫blicos del equipo (`/team`).

- **‚úÖ Flujo de Reserva (Sin Pago) - COMPLETADO:**
  - [‚úÖ] L√≥gica de Disponibilidad (API y Componente de Frontend).
  - [‚úÖ] Conexi√≥n del flujo (Selecci√≥n de servicio -> Calendario).
  - [‚úÖ] Formulario de datos de cliente.
  - [‚úÖ] Creaci√≥n final de la cita en la base de datos.
  - [‚úÖ] Auto-asignaci√≥n de empleado para "Cualquier Profesional".

- **‚úÖ Panel de Administraci√≥n Esencial:**
  - **‚úÖ Gesti√≥n Core:** CRUD completo para Servicios y Empleados.
  - **‚úÖ Operaciones:** Planning visual de citas (FullCalendar).
    - ‚úÖ Visualizaci√≥n y Reagendamiento (Drag & Drop) funcional.
    - ‚úÖ Creaci√≥n manual, edici√≥n y anulaci√≥n de citas (modales).
  - **‚úÖ Gesti√≥n Avanzada de Horarios:**
    - ‚úÖ Editor de turnos semanales, calendario de ausencias y anulaciones por fecha.
  - ‚úÖ **Autenticaci√≥n:** Login seguro para el administrador.

- **‚úÖ Notificaciones Cr√≠ticas (Email/WhatsApp) - COMPLETADO:**
  - [‚úÖ] Email/WhatsApp de confirmaci√≥n de cita para el cliente.
  - [‚úÖ] Email de notificaci√≥n de nueva cita para la empresa.
  - [‚úÖ] Recordatorios autom√°ticos 24h antes de la cita.

---

## ‚ú® Versi√≥n 1.1: Fidelizaci√≥n y Experiencia de Cliente

**Objetivo:** Mejorar la retenci√≥n de clientes y automatizar el marketing de reputaci√≥n.

- **üü° Panel de Cliente Completo - EN PROGRESO:**
  - [‚úÖ] Registro de usuarios (Email) y Login.
  - [üü°] Historial de citas y opci√≥n "Reservar de Nuevo".
  - [ ] Gesti√≥n de perfil (cambiar nombre/contrase√±a).
  - [ ] Gesti√≥n de m√∫ltiples veh√≠culos.

- **‚úÖ Sistema de Valoraciones y Rese√±as - COMPLETADO:**
  - [‚úÖ] Notificaci√≥n autom√°tica post-servicio para solicitar valoraci√≥n.
  - [‚úÖ] Panel de moderaci√≥n de rese√±as en el √°rea de administraci√≥n.
  - [‚úÖ] Visualizaci√≥n de rese√±as aprobadas en el sitio p√∫blico.

- **[ ] Integraci√≥n con Pasarela de Pagos (Stripe):**
  - [ ] Integraci√≥n b√°sica para pagos en el flujo de reserva.

- **[ ] Integraci√≥n con Google Calendar:**
  - [ ] Sincronizaci√≥n bidireccional para citas y bloqueos.

---

## üöÄ Versi√≥n 1.2: Monetizaci√≥n Avanzada y Anal√≠ticas

**Objetivo:** Introducir nuevas v√≠as de ingresos y proporcionar herramientas de inteligencia de negocio.

- **[ ] M√≥dulos de Marketing y Monetizaci√≥n:**
  - [ ] Creaci√≥n y gesti√≥n de Bonos de lavados.
  - [ ] Venta de Tarjetas Regalo digitales.
  - [ ] Sistema de suscripciones mensuales (Club de Lavado).

- **üü° Dashboard de Anal√≠ticas - EN PROGRESO:**
  - [‚úÖ] KPIs de negocio (citas, ingresos, no-shows).
  - [‚úÖ] Gr√°fico de actividad semanal.
  - [ ] Gr√°ficos con m√©tricas avanzadas (servicios populares, etc.).

- **[ ] Notificaciones Avanzadas (WhatsApp):**
  - [ ] Notificaciones de nuevas citas por WhatsApp para la empresa.



// ====== [6] WORKFLOW.md ======
# Nuestro Workflow de Desarrollo Colaborativo

Este documento describe nuestro m√©todo de trabajo para el desarrollo del proyecto AquaClean Car Wash. El objetivo es mantener un ritmo eficiente, minimizar errores y asegurar que ambos estemos siempre sincronizados.

## Principios Fundamentales

1.  **Un Archivo a la Vez (One-File-Flow):** El n√∫cleo de nuestro workflow. La IA proporcionar√° el c√≥digo completo para **un √∫nico archivo** a la vez. Esto nos permite implementar, probar y depurar de forma aislada y controlada antes de pasar a la siguiente pieza del puzle.

2.  **C√≥digo Siempre Completo:** Nunca se proporcionar√°n fragmentos, "diffs" o instrucciones parciales. Cada bloque de c√≥digo corresponder√° al **contenido 100% actualizado y completo del archivo** en cuesti√≥n.

3.  **El Contexto es la √önica Fuente de Verdad:** La sesi√≥n siempre comenzar√° con un prompt detallado que incluye el estado actual del proyecto y el c√≥digo completo. La IA basar√° **todas sus respuestas y c√≥digo √∫nicamente en este contexto**, sin hacer suposiciones sobre el `schema.prisma` u otras partes del c√≥digo que no est√©n expl√≠citamente proporcionadas.

4.  **Pasos Claros y Definidos:** Cada acci√≥n estar√° precedida por un an√°lisis y seguida de instrucciones claras:
    - **An√°lisis:** Se explicar√° qu√© vamos a hacer y por qu√©.
    - **C√≥digo:** Se proporcionar√° el bloque de c√≥digo completo.
    - **Gu√≠a de Pruebas:** Cuando sea aplicable, se incluir√° una gu√≠a detallada para verificar que la nueva funcionalidad se ha implementado correctamente.

5.  **Ciclo de Feedback Estricto:** El flujo de trabajo es un di√°logo constante:
    - **IA:** Proporciona el c√≥digo para el Archivo N.
    - **Desarrollador:** Implementa el c√≥digo.
    - **Desarrollador:** Si hay un error de compilador o de ejecuci√≥n, proporciona el **mensaje de error exacto y completo**.
    - **IA:** Analiza el error y proporciona una versi√≥n corregida del Archivo N.
    - **Desarrollador:** Confirma que el error se ha solucionado.
    - **IA:** Procede a proporcionar el c√≥digo para el Archivo N+1.

6.  **Commits y Documentaci√≥n como Hitos:** Al completar una funcionalidad significativa (ej: "Flujo de Reserva", "Planning Visual"), haremos una pausa para:
    - **Realizar un `git commit`** con un mensaje descriptivo.
    - **Actualizar la documentaci√≥n** (`ROADMAP.md`, `README.md`, especificaciones en `docs/features/`) para que refleje el nuevo estado del proyecto.

---

### Ejemplo de Flujo de Trabajo T√≠pico

1.  **Inicio:** El desarrollador inicia la conversaci√≥n con un prompt que incluye el `WORKFLOW.md`, el resumen de la sesi√≥n anterior y el estado actual del c√≥digo del proyecto.
2.  **IA:** Confirma la asimilaci√≥n del contexto y propone el primer archivo a modificar (ej: `apps/server/api/example.routes.ts`). Proporciona el c√≥digo completo.
3.  **Desarrollador:** Implementa y confirma que todo est√° OK.
4.  **IA:** Proporciona el siguiente archivo (ej: `apps/client/pages/ExamplePage.tsx`).
5.  **Desarrollador:** Implementa el c√≥digo pero recibe un error de TypeScript en VS Code.
6.  **Desarrollador:** Copia y pega el error completo en el chat.
7.  **IA:** Analiza el error, se disculpa, explica la causa y proporciona una versi√≥n corregida y completa de `apps/client/pages/ExamplePage.tsx`.
8.  **Desarrollador:** Confirma que la correcci√≥n funciona y completa la gu√≠a de pruebas.
9.  **IA:** Reconoce la finalizaci√≥n de la funcionalidad y sugiere un mensaje de `git commit` y las actualizaciones de documentaci√≥n pertinentes.



// ====== [7] apps/client/index.html ======
<!-- File: /apps/client/index.html - v1.0 -->
<!doctype html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AquaClean Car Wash</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>


// ====== [8] apps/client/package.json ======
{
  "name": "client",
  "version": "1.0.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview"
  },
  "dependencies": {
    "@fullcalendar/core": "^6.1.19",
    "@fullcalendar/daygrid": "^6.1.19",
    "@fullcalendar/interaction": "^6.1.19",
    "@fullcalendar/react": "^6.1.19",
    "@fullcalendar/resource-timegrid": "^6.1.19",
    "@fullcalendar/resource-timeline": "^6.1.19",
    "@fullcalendar/timegrid": "^6.1.19",
    "@mantine/charts": "^7.10.2",
    "@mantine/core": "^7.10.2",
    "@mantine/dates": "^7.10.2",
    "@mantine/form": "^7.10.2",
    "@mantine/hooks": "^7.10.2",
    "@mantine/notifications": "^7.10.2",
    "@tabler/icons-react": "^3.35.0",
    "axios": "^1.7.2",
    "dayjs": "^1.11.11",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-international-phone": "^4.3.0",
    "react-router-dom": "^6.23.1",
    "recharts": "^2.12.7",
    "zustand": "^4.5.2"
  },
  "devDependencies": {
    "@aquaclean/config": "workspace:*",
    "@aquaclean/types": "workspace:*",
    "@types/react": "^18.2.66",
    "@types/react-dom": "^18.2.22",
    "@vitejs/plugin-react": "^4.2.1",
    "eslint": "^8.57.0",
    "postcss": "^8.4.38",
    "postcss-preset-mantine": "^1.15.0",
    "postcss-simple-vars": "^7.0.1",
    "typescript": "^5.4.5",
    "vite": "^5.2.0"
  }
}


// ====== [9] apps/client/src/App.tsx ======
// File: /apps/client/src/App.tsx (CON RUTA 'MIS CITAS')

import { Route, Routes } from 'react-router-dom';
import { HomePage } from './pages/public/HomePage';
import { AdminLayout } from './layouts/AdminLayout';
import { PublicLayout } from './layouts/PublicLayout';
import { AdminDashboardPage } from './pages/admin/AdminDashboardPage';
import { ServicesManagementPage } from './pages/admin/ServicesManagementPage';
import { AdminLoginPage } from './pages/admin/AdminLoginPage';
import { EmployeesManagementPage } from './pages/admin/EmployeesManagementPage';
import { ServicesPage } from './pages/public/ServicesPage';
import { BookingPage } from './pages/public/BookingPage';
import { AdminPlanningPage } from './pages/admin/AdminPlanningPage';
import { TeamPage } from './pages/public/TeamPage';
import { BusinessSettingsPage } from './pages/admin/BusinessSettingsPage';
import { LoginPage } from './pages/public/LoginPage';
import { RegisterPage } from './pages/public/RegisterPage';
import { CustomerLayout } from './layouts/CustomerLayout';
import { CustomerDashboardPage } from './pages/customer/CustomerDashboardPage';
import { ReviewPage } from './pages/public/ReviewPage';
import { ReviewsManagementPage } from './pages/admin/ReviewsManagementPage';

// --- IMPORTACI√ìN A√ëADIDA ---
import { CustomerAppointmentsPage } from './pages/customer/CustomerAppointmentsPage';

function App() {
  return (
    <Routes>
      {/* Rutas P√∫blicas */}
      <Route element={<PublicLayout />}>
        <Route path="/" element={<HomePage />} />
        <Route path="/services" element={<ServicesPage />} />
        <Route path="/booking" element={<BookingPage />} />
        <Route path="/team" element={<TeamPage />} />
        <Route path="/login" element={<LoginPage />} />
        <Route path="/register" element={<RegisterPage />} />
        <Route path="/review" element={<ReviewPage />} />
      </Route>

      {/* Rutas Protegidas para Clientes */}
      <Route path="/dashboard" element={<CustomerLayout />}>
        <Route index element={<CustomerDashboardPage />} />
        
        {/* --- RUTA DESCOMENTADA Y ACTUALIZADA --- */}
        <Route path="appointments" element={<CustomerAppointmentsPage />} />
      </Route>

      {/* Ruta de Login para Admin (sin layout) */}
      <Route path="/admin/login" element={<AdminLoginPage />} />

      {/* Rutas de Administraci√≥n Protegidas */}
      <Route path="/admin" element={<AdminLayout />}>
        <Route index element={<AdminDashboardPage />} />
        <Route path="services" element={<ServicesManagementPage />} />
        <Route path="employees" element={<EmployeesManagementPage />} />
        <Route path="planning" element={<AdminPlanningPage />} />
        <Route path="settings" element={<BusinessSettingsPage />} />
        <Route path="reviews" element={<ReviewsManagementPage />} />
      </Route>
    </Routes>
  );
}

export default App;


// ====== [10] apps/client/src/components/admin/AbsenceCalendar.tsx ======
// File: /apps/client/src/components/admin/AbsenceCalendar.tsx (CORRECCI√ìN FINAL-FINAL)

import { useState } from 'react';
// --- L√çNEA MODIFICADA ---
import { DatePickerInput } from '@mantine/dates'; 
import { Button, Group, Text, Paper, ActionIcon, Stack, Divider, Title } from '@mantine/core';
// --- FIN DE LA MODIFICACI√ìN ---
import { IconTrash } from '@tabler/icons-react';
import dayjs from 'dayjs';

export interface Absence {
  id: string;
  startDate: Date;
  endDate: Date;
  reason?: string | null;
}

interface AbsenceCalendarProps {
  absences: Absence[];
  onAddAbsence: (dates: [Date, Date]) => void;
  onDeleteAbsence: (absenceId: string) => void;
}

export function AbsenceCalendar({ absences, onAddAbsence, onDeleteAbsence }: AbsenceCalendarProps) {
  const [value, setValue] = useState<[Date | null, Date | null]>([null, null]);

  const handleAddAbsence = () => {
    if (value[0] && value[1]) {
      const sortedDates: [Date, Date] = [
        dayjs(value[0]).startOf('day').toDate(),
        dayjs(value[1]).endOf('day').toDate()
      ].sort((a, b) => a.getTime() - b.getTime()) as [Date, Date];
      
      onAddAbsence(sortedDates);
      setValue([null, null]);
    }
  };

  return (
    <Stack>
      <Title order={4}>Seleccionar Rango de Fechas</Title>
      
      {/* --- COMPONENTE CORREGIDO --- */}
      <DatePickerInput
        type="range"
        label="Selecciona un rango de d√≠as"
        placeholder="Desde... hasta..."
        value={value}
        onChange={setValue}
        minDate={new Date()}
        clearable // A√±adimos la opci√≥n de limpiar la selecci√≥n
      />
      {/* --- FIN DE LA CORRECCI√ìN --- */}

      <Button
        onClick={handleAddAbsence}
        disabled={!value[0] || !value[1]}
      >
        A√±adir Ausencia Programada
      </Button>

      <Divider my="md" label="Ausencias Programadas" />

      <Stack>
        {absences.length > 0 ? (
          absences.map((absence) => (
            <Paper withBorder p="xs" key={absence.id}>
              <Group justify="space-between">
                <Text size="sm">
                  Del {dayjs(absence.startDate).format('DD/MM/YYYY')} al {dayjs(absence.endDate).format('DD/MM/YYYY')}
                </Text>
                <ActionIcon color="red" variant="light" onClick={() => onDeleteAbsence(absence.id)}>
                  <IconTrash size={16} />
                </ActionIcon>
              </Group>
            </Paper>
          ))
        ) : (
          <Text c="dimmed" ta="center" size="sm">
            Este empleado no tiene ausencias programadas.
          </Text>
        )}
      </Stack>
    </Stack>
  );
}


// ====== [11] apps/client/src/components/admin/AppointmentForm.tsx ======
// File: /apps/client/src/components/admin/AppointmentForm.tsx (ACTUALIZADO CON GESTI√ìN DE ESTADO)

import { useEffect, useState } from 'react';
import { useForm } from '@mantine/form';
import { TextInput, Select, Button, Group, Stack, LoadingOverlay, Modal, Text } from '@mantine/core';
import { DateTimePicker } from '@mantine/dates';
import { notifications } from '@mantine/notifications';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../lib/apiClient';
import type { Service } from '@aquaclean/types';

interface Employee {
  id: string;
  name: string;
}

interface AppointmentFormProps {
  initialData?: any;
  onSuccess: () => void;
  onClose: () => void;
}

// Opciones de estado para el selector
const statusOptions = [
  { value: 'CONFIRMED', label: 'Confirmada' },
  { value: 'COMPLETED', label: 'Completada' },
  { value: 'NO_SHOW', label: 'No Presentado' },
  { value: 'CANCELLED', label: 'Cancelada' },
];

export function AppointmentForm({ initialData, onSuccess, onClose }: AppointmentFormProps) {
  const [services, setServices] = useState<{ value: string; label: string }[]>([]);
  const [employees, setEmployees] = useState<{ value: string; label: string }[]>([]);
  const [loadingData, setLoadingData] = useState(true);
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  const [deleteModalOpened, { open: openDeleteModal, close: closeDeleteModal }] = useDisclosure(false);

  const form = useForm({
    initialValues: {
      customerName: '',
      customerEmail: '',
      serviceId: '',
      employeeId: '',
      startTime: null as Date | null,
      status: 'CONFIRMED', // <-- CAMPO A√ëADIDO
    },
  });

  useEffect(() => {
    if (initialData) {
      form.setValues({
        customerName: initialData.customerName || '',
        customerEmail: initialData.customerEmail || '',
        serviceId: initialData.serviceId || '',
        employeeId: initialData.employeeId || '',
        startTime: initialData.start ? new Date(initialData.start) : null,
        status: initialData.status || 'CONFIRMED', // <-- CAMPO A√ëADIDO
      });
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [initialData]);

  useEffect(() => {
    const fetchData = async () => {
      setLoadingData(true);
      try {
        const [servicesResponse, employeesResponse] = await Promise.all([
          apiClient.get<Service[]>('/services'),
          apiClient.get<Employee[]>('/employees'),
        ]);
        setServices(servicesResponse.data.map(s => ({ value: s.id, label: s.name })));
        setEmployees(employeesResponse.data.map(e => ({ value: e.id, label: e.name })));
      } catch (error) { console.error("Error fetching data for form", error); }
      finally { setLoadingData(false); }
    };
    fetchData();
  }, []);

  const handleSubmit = async (values: typeof form.values) => {
    setIsSubmitting(true);
    try {
      if (initialData?.type === 'edit') {
        // Ahora enviamos todos los valores del formulario, incluido el 'status'
        await apiClient.put(`/admin/appointments/${initialData.appointmentId}`, values);
        notifications.show({ title: 'Cita Actualizada', message: 'Los cambios se han guardado.', color: 'blue' });
      } else {
        await apiClient.post('/admin/appointments', values);
        notifications.show({ title: 'Cita Creada', message: 'La nueva cita ha sido guardada.', color: 'green' });
      }
      onSuccess();
    } catch (error) {
      notifications.show({ title: 'Error al Guardar', message: 'No se pudo guardar la cita.', color: 'red' });
    } finally {
      setIsSubmitting(false);
    }
  };
  
  const handleDelete = async () => {
    setIsSubmitting(true);
    try {
      await apiClient.delete(`/admin/appointments/${initialData.appointmentId}`);
      notifications.show({ title: 'Cita Anulada', message: 'La cita ha sido eliminada.', color: 'orange' });
      onSuccess();
    } catch (error) {
      notifications.show({ title: 'Error al Anular', message: 'No se pudo anular la cita.', color: 'red' });
    } finally {
      setIsSubmitting(false);
      closeDeleteModal();
    }
  };

  return (
    <>
      <Modal opened={deleteModalOpened} onClose={closeDeleteModal} title="Confirmar Anulaci√≥n" centered>
        <Text>¬øSeguro que quieres anular esta cita? Esto la devolver√° al estado 'Disponible'.</Text>
        <Group justify="flex-end" mt="md">
          <Button variant="default" onClick={closeDeleteModal}>Cancelar</Button>
          <Button color="red" onClick={handleDelete} loading={isSubmitting}>Anular Cita</Button>
        </Group>
      </Modal>

      <form onSubmit={form.onSubmit(handleSubmit)}>
        <LoadingOverlay visible={loadingData} />
        <Stack>
          <TextInput label="Nombre del Cliente" {...form.getInputProps('customerName')} required />
          <TextInput type="email" label="Email del Cliente" {...form.getInputProps('customerEmail')} required />
          <DateTimePicker label="Fecha y Hora" {...form.getInputProps('startTime')} valueFormat="DD/MM/YYYY HH:mm" required />
          <Select label="Servicio" data={services} {...form.getInputProps('serviceId')} searchable required />
          <Select label="Empleado Asignado" data={employees} {...form.getInputProps('employeeId')} required />
          
          {/* --- COMPONENTE A√ëADIDO --- */}
          {initialData?.type === 'edit' && (
            <Select
              label="Estado de la Cita"
              data={statusOptions}
              {...form.getInputProps('status')}
              required
            />
          )}

          <Group justify="space-between" mt="md">
            {initialData?.type === 'edit' ? (
              <Button variant="outline" color="red" onClick={openDeleteModal} disabled={isSubmitting}>Anular Cita</Button>
            ) : <div />}
            <Group>
              <Button variant="default" onClick={onClose} disabled={isSubmitting}>Cancelar</Button>
              <Button type="submit" loading={isSubmitting}>Guardar Cambios</Button>
            </Group>
          </Group>
        </Stack>
      </form>
    </>
  );
}


// ====== [12] apps/client/src/components/admin/ConflictResolutionModal.tsx ======
// File: /apps/client/src/components/admin/ConflictResolutionModal.tsx (NUEVO ARCHIVO)

import { Modal, Text, Alert, List, ThemeIcon, Button, Group } from '@mantine/core';
import { IconAlertTriangle, IconCalendarEvent } from '@tabler/icons-react';
import dayjs from 'dayjs';

// Definimos un tipo para las citas en conflicto que recibiremos de la API
interface Conflict {
  id: string;
  startTime: string;
  user: {
    name: string | null;
  };
}

interface ConflictResolutionModalProps {
  opened: boolean;
  onClose: () => void;
  conflicts: Conflict[];
}

export function ConflictResolutionModal({ opened, onClose, conflicts }: ConflictResolutionModalProps) {
  return (
    <Modal
      opened={opened}
      onClose={onClose}
      title="Conflicto de Citas"
      centered
      size="lg"
    >
      <Alert
        variant="light"
        color="orange"
        title="Acci√≥n Requerida"
        icon={<IconAlertTriangle />}
        mb="md"
      >
        No se puede programar la ausencia porque entra en conflicto con las siguientes {conflicts.length} citas ya existentes. Debes cancelarlas o reasignarlas manualmente antes de poder registrar la ausencia.
      </Alert>

      <Text fw={500} mb="xs">Citas en conflicto:</Text>
      <List
        spacing="xs"
        size="sm"
        center
        icon={
          <ThemeIcon color="orange" size={24} radius="xl">
            <IconCalendarEvent size={16} />
          </ThemeIcon>
        }
      >
        {conflicts.map((conflict) => (
          <List.Item key={conflict.id}>
            {dayjs(conflict.startTime).format('DD/MM/YYYY [a las] HH:mm')} - Cliente: <strong>{conflict.user.name || 'N/A'}</strong>
          </List.Item>
        ))}
      </List>
      
      <Group justify="flex-end" mt="xl">
        <Button variant="outline" onClick={onClose}>
          Entendido
        </Button>
      </Group>

    </Modal>
  );
}


// ====== [13] apps/client/src/components/admin/ScheduleEditor.tsx ======
// File: /apps/client/src/components/admin/ScheduleEditor.tsx (CORREGIDO)

import { Button, Group, ActionIcon, Stack, Text, Box } from '@mantine/core';
import { TimeInput } from '@mantine/dates'; // <-- IMPORTACI√ìN CORREGIDA
import { IconPlus, IconTrash } from '@tabler/icons-react';

type Shift = { start: string; end: string };
export type WeeklySchedule = {
  [key: string]: Shift[];
};

interface ScheduleEditorProps {
  value: WeeklySchedule;
  onChange: (schedule: WeeklySchedule) => void;
}

const DAYS_OF_WEEK = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];
const DAY_LABELS: { [key: string]: string } = {
  monday: 'Lunes',
  tuesday: 'Martes',
  wednesday: 'Mi√©rcoles',
  thursday: 'Jueves',
  friday: 'Viernes',
  saturday: 'S√°bado',
  sunday: 'Domingo',
};

export function ScheduleEditor({ value, onChange }: ScheduleEditorProps) {
  
  const handleTimeChange = (day: string, shiftIndex: number, field: 'start' | 'end', time: string) => {
    const newSchedule = { ...value };
    if (newSchedule[day]?.[shiftIndex]) {
      newSchedule[day]![shiftIndex]![field] = time;
      onChange(newSchedule);
    }
  };

  const addShift = (day: string) => {
    const newSchedule = { ...value };
    if (!newSchedule[day]) {
      newSchedule[day] = [];
    }
    newSchedule[day]!.push({ start: '09:00', end: '17:00' });
    onChange(newSchedule);
  };

  const removeShift = (day: string, shiftIndex: number) => {
    const newSchedule = { ...value };
    newSchedule[day]?.splice(shiftIndex, 1);
    onChange(newSchedule);
  };

  return (
    <Stack gap="xl">
      {DAYS_OF_WEEK.map((day) => (
        <Box key={day}>
          <Text fw={500} tt="capitalize">{DAY_LABELS[day]}</Text>
          <Stack gap="xs" mt="xs">
            {value[day]?.map((shift, index) => (
              <Group key={index} grow>
                <TimeInput
                  label="Inicio"
                  value={shift.start}
                  // --- L√çNEA CORREGIDA ---
                  onChange={(e: React.ChangeEvent<HTMLInputElement>) => handleTimeChange(day, index, 'start', e.currentTarget.value)}
                />
                <TimeInput
                  label="Fin"
                  value={shift.end}
                  // --- L√çNEA CORREGIDA ---
                  onChange={(e: React.ChangeEvent<HTMLInputElement>) => handleTimeChange(day, index, 'end', e.currentTarget.value)}
                />
                <ActionIcon
                  color="red"
                  variant="light"
                  onClick={() => removeShift(day, index)}
                  style={{ marginTop: 25 }}
                >
                  <IconTrash size={16} />
                </ActionIcon>
              </Group>
            ))}
             <Button
                leftSection={<IconPlus size={14} />}
                variant="light"
                onClick={() => addShift(day)}
                fullWidth
             >
                A√±adir Turno
            </Button>
          </Stack>
        </Box>
      ))}
    </Stack>
  );
}


// ====== [14] apps/client/src/components/admin/ServiceForm.tsx ======
// File: /apps/client/src/components/admin/ServiceForm.tsx (CORREGIDO)

import { useEffect } from 'react';
import { TextInput, Textarea, NumberInput, Button, Group, Stack, Switch } from '@mantine/core';
import { useForm, zodResolver } from '@mantine/form';
import { createServiceSchema } from '@aquaclean/types';
import type { Service } from '@aquaclean/types';

interface ServiceFormProps {
  initialData?: Partial<Service>; 
  onSuccess: (service: Partial<Service>) => void; // Aceptamos un servicio parcial
  onClose: () => void;
  isSubmitting: boolean;
}

export function ServiceForm({ initialData, onSuccess, onClose, isSubmitting }: ServiceFormProps) {
  
  const form = useForm({
    validate: zodResolver(createServiceSchema),
    initialValues: {
      name: '',
      description: '',
      duration: 60,
      prices: { standard: 50 },
      category: 'General',
      isActive: true,
    },
  });

  useEffect(() => {
    if (initialData) {
      form.setValues(initialData);
    }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [initialData]);

  // --- L√ìGICA CORREGIDA ---
  const handleSubmit = (values: typeof form.values) => {
    // Fusionamos los datos iniciales (que contienen el ID) con los nuevos valores del formulario.
    // Esto asegura que al editar, no perdamos el ID del servicio.
    const finalData = { ...initialData, ...values };
    onSuccess(finalData); 
  };
  // --- FIN DE LA CORRECCI√ìN ---

  const isEditMode = Boolean(initialData?.id);

  return (
    <form onSubmit={form.onSubmit(handleSubmit)}>
      <Stack>
        <TextInput label="Nombre del Servicio" {...form.getInputProps('name')} withAsterisk />
        <Textarea label="Descripci√≥n" {...form.getInputProps('description')} withAsterisk />
        <NumberInput label="Duraci√≥n (minutos)" {...form.getInputProps('duration')} withAsterisk />
        <NumberInput label="Precio Est√°ndar (‚Ç¨)" {...form.getInputProps('prices.standard')} withAsterisk />
        <TextInput label="Categor√≠a" {...form.getInputProps('category')} withAsterisk />
        <Switch 
          label="Servicio Activo"
          description="Si est√° inactivo, no se podr√° seleccionar para nuevas reservas."
          {...form.getInputProps('isActive', { type: 'checkbox' })}
        />
        
        <Group justify="flex-end" mt="md">
          <Button variant="default" onClick={onClose} disabled={isSubmitting}>
            Cancelar
          </Button>
          <Button type="submit" loading={isSubmitting}>
            {isEditMode ? 'Guardar Cambios' : 'Crear Servicio'}
          </Button>
        </Group>
      </Stack>
    </form>
  );
}


// ====== [15] apps/client/src/components/booking/BookingDateTimePicker.tsx ======
// File: /apps/client/src/components/booking/BookingDateTimePicker.tsx (ACTUALIZADO)

import { useState, useEffect } from 'react';
import { DatePicker } from '@mantine/dates';
import { SimpleGrid, Button, Text, Loader, Center, Stack, Title } from '@mantine/core';
import dayjs from 'dayjs';
import apiClient from '../../lib/apiClient';

interface BookingDateTimePickerProps {
  serviceDuration: number;
  onDateTimeChange: (dateTime: Date | null) => void;
  // --- L√çNEA A√ëADIDA ---
  employeeId?: string | null; 
}

export function BookingDateTimePicker({ serviceDuration, onDateTimeChange, employeeId }: BookingDateTimePickerProps) {
  const [selectedDate, setSelectedDate] = useState<Date | null>(new Date());
  const [availableSlots, setAvailableSlots] = useState<string[]>([]);
  const [selectedSlot, setSelectedSlot] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // --- L√ìGICA MODIFICADA ---
  useEffect(() => {
    if (!selectedDate) {
      setAvailableSlots([]);
      return;
    }

    const fetchAvailability = async () => {
      setLoading(true);
      setError(null);
      setSelectedSlot(null);
      onDateTimeChange(null); // Reseteamos la fecha seleccionada al cambiar de d√≠a/empleado

      try {
        const formattedDate = dayjs(selectedDate).format('YYYY-MM-DD');
        const response = await apiClient.get<string[]>('/availability', {
          params: {
            date: formattedDate,
            // Si hay un employeeId y no es 'any', lo enviamos. Si no, no lo incluimos.
            ...(employeeId && employeeId !== 'any' && { employeeId }),
          },
        });
        setAvailableSlots(response.data);
      } catch (err) {
        console.error('Error fetching availability:', err);
        setError('No se pudo cargar la disponibilidad.');
      } finally {
        setLoading(false);
      }
    };

    fetchAvailability();
  // El useEffect ahora tambi√©n depende de employeeId
  }, [selectedDate, employeeId, onDateTimeChange]);
  // --- FIN DE LA MODIFICACI√ìN ---


  const handleSlotSelect = (slot: string) => {
    setSelectedSlot(slot);
    if (selectedDate) {
      const hours = parseInt(slot.split(':')[0] ?? '0', 10);
      const minutes = parseInt(slot.split(':')[1] ?? '0', 10);
      const finalDateTime = dayjs(selectedDate).hour(hours).minute(minutes).toDate();
      onDateTimeChange(finalDateTime);
    }
  };

  return (
    <Stack>
      <DatePicker
        value={selectedDate}
        onChange={setSelectedDate}
        minDate={new Date()}
        weekendDays={[0]}
      />

      <Stack mt="lg">
        <Title order={4}>Selecciona una hora</Title>
        {loading && <Center><Loader /></Center>}
        {error && <Text c="red">{error}</Text>}
        
        {!loading && !error && availableSlots.length === 0 && (
          <Text c="dimmed">No hay huecos disponibles para esta selecci√≥n.</Text>
        )}

        {!loading && !error && availableSlots.length > 0 && (
          <SimpleGrid cols={{ base: 3, sm: 4 }}>
            {availableSlots.map((slot) => (
              <Button
                key={slot}
                variant={selectedSlot === slot ? 'filled' : 'outline'}
                onClick={() => handleSlotSelect(slot)}
              >
                {slot}
              </Button>
            ))}
          </SimpleGrid>
        )}
      </Stack>
    </Stack>
  );
}


// ====== [16] apps/client/src/components/common/PublicFooter.module.css ======
/* File: /apps/client/src/components/common/PublicFooter.module.css (CORREGIDO) */

.footer {
  margin-top: calc(var(--mantine-spacing-xl) * 2);
  border-top: 1px solid light-dark(var(--mantine-color-gray-2), var(--mantine-color-dark-5));
  padding-top: var(--mantine-spacing-lg);
  padding-bottom: var(--mantine-spacing-lg);
}

.inner {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

/* Usamos una media query est√°ndar de CSS */
@media (max-width: 576px) {
  .inner {
    flex-direction: column;
    align-items: center;
    gap: var(--mantine-spacing-md);
  }
}


// ====== [17] apps/client/src/components/common/PublicFooter.tsx ======
// File: /apps/client/src/components/common/PublicFooter.tsx (CORREGIDO)

import { Container, Text, Anchor, Group } from '@mantine/core';
import classes from './PublicFooter.module.css';

export function PublicFooter() {
  return (
    <footer className={classes.footer}>
      <Container className={classes.inner}>
        <Text c="dimmed" size="sm">
          &copy; {new Date().getFullYear()} AquaClean Car Wash. Todos los derechos reservados.
        </Text>
        <Group gap="xs" justify="flex-end" wrap="nowrap">
          {/* Aqu√≠ podr√≠amos a√±adir enlaces a redes sociales o a p√°ginas como "Pol√≠tica de Privacidad" */}
          <Anchor c="dimmed" href="#" size="sm">
            T√©rminos
          </Anchor>
          <Anchor c="dimmed" href="#" size="sm">
            Privacidad
          </Anchor>
        </Group>
      </Container>
    </footer>
  );
}


// ====== [18] apps/client/src/components/common/PublicHeader.module.css ======
/* ====== [18] apps/client/src/components/common/PublicHeader.module.css ====== */
/* File: /apps/client/src/components/common/PublicHeader.module.css (CON ESTILOS PARA EL DRAWER) */

.header {
  height: 60px;
  border-bottom: 1px solid light-dark(var(--mantine-color-gray-3), var(--mantine-color-dark-4));
}

.inner {
  height: 60px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.link {
  display: block;
  line-height: 1;
  padding: 8px 12px;
  border-radius: var(--mantine-radius-sm);
  text-decoration: none;
  color: light-dark(var(--mantine-color-gray-7), var(--mantine-color-dark-0));
  font-size: var(--mantine-font-size-sm);
  font-weight: 500;

  &:hover {
    background-color: light-dark(var(--mantine-color-gray-0), var(--mantine-color-dark-6));
  }
}

.linkActive {
  &,
  &:hover {
    background-color: var(--mantine-color-blue-light);
    color: var(--mantine-color-blue-light-color);
  }
}

/* --- NUEVOS ESTILOS A√ëADIDOS --- */

.drawerLink {
  display: block;
  padding: 12px 16px;
  border-radius: var(--mantine-radius-md);
  text-decoration: none;
  color: light-dark(var(--mantine-color-gray-7), var(--mantine-color-dark-0));
  font-size: var(--mantine-font-size-lg);
  font-weight: 500;

  &:hover {
    background-color: light-dark(var(--mantine-color-gray-0), var(--mantine-color-dark-6));
  }
}

.drawerLinkActive {
  &,
  &:hover {
    background-color: var(--mantine-color-blue-light);
    color: var(--mantine-color-blue-light-color);
  }
}


// ====== [19] apps/client/src/components/common/PublicHeader.tsx ======
// File: /apps/client/src/components/common/PublicHeader.tsx (CON L√ìGICA DE AUTENTICACI√ìN)

import { NavLink, useNavigate } from 'react-router-dom';
import { Container, Group, Button, Image, Burger, Drawer, Stack, Menu, Text, Avatar } from '@mantine/core';
import { useDisclosure } from '@mantine/hooks';
import { notifications } from '@mantine/notifications';
import { IconDashboard, IconLogout } from '@tabler/icons-react';
import { useEffect, useState } from 'react';
import classes from './PublicHeader.module.css';

interface CustomerInfo {
  name?: string;
  email?: string;
}

export function PublicHeader() {
  const navigate = useNavigate();
  const [opened, { open, close }] = useDisclosure(false);

  // --- L√ìGICA A√ëADIDA ---
  const [customer, setCustomer] = useState<CustomerInfo | null>(null);

  // Este efecto se ejecutar√° al cargar y cada vez que cambie el localStorage
  useEffect(() => {
    const updateCustomerState = () => {
      const token = localStorage.getItem('customerAuthToken');
      const info = localStorage.getItem('customerInfo');
      if (token && info) {
        setCustomer(JSON.parse(info));
      } else {
        setCustomer(null);
      }
    };

    updateCustomerState();

    // Escuchamos cambios en el storage para actualizar la cabecera en tiempo real
    // (si el login/logout ocurre en otra pesta√±a)
    window.addEventListener('storage', updateCustomerState);
    return () => {
      window.removeEventListener('storage', updateCustomerState);
    };
  }, []);

  const handleLogout = () => {
    localStorage.removeItem('customerAuthToken');
    localStorage.removeItem('customerInfo');
    setCustomer(null); // Actualizamos el estado local
    notifications.show({
      title: 'Sesi√≥n cerrada',
      message: 'Has cerrado sesi√≥n correctamente.',
      color: 'blue',
    });
    navigate('/');
  };

  const handleLinkClick = (path: string) => {
    navigate(path);
    close();
  };
  // --- FIN DE LA L√ìGICA A√ëADIDA ---

  return (
    <header className={classes.header}>
      <Container size="md" className={classes.inner}>
        <Image src="/logo.png" alt="Logo" h={40} fit="contain" style={{ cursor: 'pointer' }} onClick={() => navigate('/')} />

        <Group gap={5} visibleFrom="xs">
          <NavLink to="/" className={({ isActive }) => `${classes.link} ${isActive ? classes.linkActive : ''}`} end>Inicio</NavLink>
          <NavLink to="/services" className={({ isActive }) => `${classes.link} ${isActive ? classes.linkActive : ''}`}>Servicios</NavLink>
          <NavLink to="/team" className={({ isActive }) => `${classes.link} ${isActive ? classes.linkActive : ''}`}>Nuestro Equipo</NavLink>
        </Group>
        
        {/* --- RENDERIZADO CONDICIONAL DEL BOT√ìN --- */}
        <Group visibleFrom="xs">
          {customer ? (
            <Menu shadow="md" width={200}>
              <Menu.Target>
                <Button variant="outline">
                  <Group>
                    <Avatar size="sm" color="blue" radius="xl">{customer.name?.charAt(0)}</Avatar>
                    <Text size="sm">{customer.name}</Text>
                  </Group>
                </Button>
              </Menu.Target>
              <Menu.Dropdown>
                <Menu.Label>Mi Cuenta</Menu.Label>
                <Menu.Item leftSection={<IconDashboard size={14} />} onClick={() => navigate('/dashboard')}>
                  Mi Panel
                </Menu.Item>
                <Menu.Divider />
                <Menu.Item color="red" leftSection={<IconLogout size={14} />} onClick={handleLogout}>
                  Cerrar Sesi√≥n
                </Menu.Item>
              </Menu.Dropdown>
            </Menu>
          ) : (
            <Group>
                <Button variant="default" onClick={() => navigate('/login')}>Iniciar Sesi√≥n</Button>
                <Button onClick={() => navigate('/booking')}>Reservar Cita</Button>
            </Group>
          )}
        </Group>
        {/* --- FIN DEL RENDERIZADO CONDICIONAL --- */}

        <Burger opened={opened} onClick={open} hiddenFrom="xs" size="sm" />
      </Container>
      
      <Drawer opened={opened} onClose={close} title="Men√∫" padding="xl" size="sm">
        <Stack gap="lg">
          <NavLink to="/" className={({ isActive }) => `${classes.drawerLink} ${isActive ? classes.drawerLinkActive : ''}`} onClick={close} end>Inicio</NavLink>
          <NavLink to="/services" className={({ isActive }) => `${classes.drawerLink} ${isActive ? classes.drawerLinkActive : ''}`} onClick={close}>Servicios</NavLink>
          <NavLink to="/team" className={({ isActive }) => `${classes.drawerLink} ${isActive ? classes.drawerLinkActive : ''}`} onClick={close}>Nuestro Equipo</NavLink>
          <Button onClick={() => handleLinkClick('/booking')} size="lg" mt="md">Reservar Cita</Button>
          {/* Aqu√≠ podr√≠amos a√±adir tambi√©n la l√≥gica de login/logout para m√≥vil */}
        </Stack>
      </Drawer>
    </header>
  );
}


// ====== [20] apps/client/src/components/home/FeaturedReviews.tsx ======
// File: /apps/client/src/components/home/FeaturedReviews.tsx (NUEVO ARCHIVO)

import { useEffect, useState } from 'react';
import { Container, Title, Text, SimpleGrid, Paper, Rating, Blockquote, Loader, Center, Alert } from '@mantine/core';
import { IconMessageCircle2 } from '@tabler/icons-react';
import apiClient from '../../lib/apiClient';

// Interfaz para los datos que esperamos de la API p√∫blica
interface PublicReview {
  id: string;
  rating: number;
  comment: string | null;
  customerName: string | null;
}

export function FeaturedReviews() {
  const [reviews, setReviews] = useState<PublicReview[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchReviews = async () => {
      try {
        const response = await apiClient.get<PublicReview[]>('/reviews');
        setReviews(response.data);
      } catch (err) {
        console.error('Error fetching public reviews:', err);
        setError('No se pudieron cargar las valoraciones en este momento.');
      } finally {
        setLoading(false);
      }
    };

    fetchReviews();
  }, []);

  if (loading) {
    return (
      <Center style={{ height: 200 }}>
        <Loader />
      </Center>
    );
  }

  if (error) {
    return (
      <Container size="md" py="xl">
        <Alert color="orange" title="Opiniones no disponibles">
          {error}
        </Alert>
      </Container>
    );
  }

  if (reviews.length === 0) {
    // No mostramos nada si no hay rese√±as que mostrar
    return null;
  }

  return (
    <Container size="lg" py="xl">
      <Title order={2} ta="center" mb="xs">
        La Opini√≥n de Nuestros Clientes
      </Title>
      <Text c="dimmed" ta="center" mb="xl">
        Descubre por qu√© nuestros clientes conf√≠an en nosotros para el cuidado de sus veh√≠culos.
      </Text>

      <SimpleGrid cols={{ base: 1, sm: 2, lg: 3 }} spacing="lg">
        {reviews.map((review) => (
          <Paper withBorder radius="md" p="lg" key={review.id}>
            <Rating value={review.rating} readOnly />
            <Blockquote
              color="blue"
              cite={`‚Äì ${review.customerName || 'Cliente An√≥nimo'}`}
              icon={<IconMessageCircle2 size={24} />}
              mt="sm"
            >
              {review.comment || '¬°Un servicio excelente!'}
            </Blockquote>
          </Paper>
        ))}
      </SimpleGrid>
    </Container>
  );
}


// ====== [21] apps/client/src/custom.d.ts ======
// File: /apps/client/src/custom.d.ts (NUEVO ARCHIVO)

// Este archivo le dice a TypeScript c√≥mo tratar los archivos CSS Modules.
// Declara que cualquier importaci√≥n de un archivo que termine en .module.css
// exportar√° por defecto un objeto donde las claves y los valores son strings.
declare module '*.module.css' {
  const classes: { readonly [key: string]: string };
  export default classes;
}


// ====== [22] apps/client/src/layouts/AdminLayout.tsx ======
// File: /apps/client/src/layouts/AdminLayout.tsx (A√ëADIENDO ENLACE A RESE√ëAS)

import { Outlet, Navigate, NavLink } from 'react-router-dom';
import { AppShell, Burger, Group, Title } from '@mantine/core';
import { useDisclosure } from '@mantine/hooks';

export function AdminLayout() {
  const [opened, { toggle }] = useDisclosure();

  const authToken = localStorage.getItem('authToken');

  if (!authToken) {
    return <Navigate to="/admin/login" replace />;
  }

  // Estilos para los NavLink
  const linkStyles = {
    display: 'block',
    padding: '8px 16px',
    borderRadius: '4px',
    textDecoration: 'none',
    color: 'black',
  };

  const activeLinkStyles = {
    backgroundColor: '#e9ecef',
    fontWeight: 500,
  };

  return (
    <AppShell
      header={{ height: 60 }}
      navbar={{ width: 300, breakpoint: 'sm', collapsed: { mobile: !opened } }}
      padding="md"
    >
      <AppShell.Header>
        <Group h="100%" px="md">
          <Burger opened={opened} onClick={toggle} hiddenFrom="sm" size="sm" />
          <Title order={4}>Panel de Administraci√≥n de AquaClean</Title>
        </Group>
      </AppShell.Header>

      <AppShell.Navbar p="md">
         <NavLink 
            to="/admin" 
            end
            style={({ isActive }) => ({ ...linkStyles, ...(isActive ? activeLinkStyles : {}) })}
         >
            Dashboard
         </NavLink>
         <NavLink 
            to="/admin/planning" 
            style={({ isActive }) => ({ ...linkStyles, ...(isActive ? activeLinkStyles : {}) })}
         >
            Planning
         </NavLink>
         <NavLink 
            to="/admin/services" 
            style={({ isActive }) => ({ ...linkStyles, ...(isActive ? activeLinkStyles : {}) })}
         >
            Servicios
         </NavLink>
         <NavLink 
            to="/admin/employees" 
            style={({ isActive }) => ({ ...linkStyles, ...(isActive ? activeLinkStyles : {}) })}
         >
            Empleados
         </NavLink>
         <NavLink 
            to="/admin/settings" 
            style={({ isActive }) => ({ ...linkStyles, ...(isActive ? activeLinkStyles : {}) })}
         >
            Ajustes del Negocio
         </NavLink>

         {/* --- ENLACE A√ëADIDO --- */}
         <NavLink 
            to="/admin/reviews" 
            style={({ isActive }) => ({ ...linkStyles, ...(isActive ? activeLinkStyles : {}) })}
         >
            Valoraciones
         </NavLink>
         {/* --- FIN DEL ENLACE A√ëADIDO --- */}

      </AppShell.Navbar>
      
      <AppShell.Main>
        <Outlet /> 
      </AppShell.Main>
    </AppShell>
  );
}


// ====== [23] apps/client/src/layouts/CustomerLayout.tsx ======
// File: /apps/client/src/layouts/CustomerLayout.tsx (SIN CAMBIOS, SOLO CONFIRMACI√ìN)

import { Outlet, Navigate, NavLink, useNavigate } from 'react-router-dom';
import { AppShell, Burger, Group, Title, Button } from '@mantine/core';
import { useDisclosure } from '@mantine/hooks';
import { notifications } from '@mantine/notifications';
import { IconLogout } from '@tabler/icons-react';

export function CustomerLayout() {
  const navigate = useNavigate();
  const [opened, { toggle }] = useDisclosure();

  const authToken = localStorage.getItem('customerAuthToken');

  const handleLogout = () => {
    localStorage.removeItem('customerAuthToken');
    localStorage.removeItem('customerInfo');
    notifications.show({
      title: 'Sesi√≥n cerrada',
      message: 'Has cerrado sesi√≥n correctamente.',
      color: 'blue',
    });
    navigate('/');
  };

  if (!authToken) {
    return <Navigate to="/login" replace />;
  }

  // Estilos para los NavLink
  const linkStyles: React.CSSProperties = {
    display: 'flex',
    alignItems: 'center',
    width: '100%',
    padding: '10px 15px',
    borderRadius: 'var(--mantine-radius-md)',
    textDecoration: 'none',
    color: 'var(--mantine-color-text)',
    fontWeight: 500,
    fontSize: 'var(--mantine-font-size-sm)',
  };

  const activeLinkStyles: React.CSSProperties = {
    backgroundColor: 'var(--mantine-color-blue-light)',
    color: 'var(--mantine-color-blue-light-color)',
  };

  return (
    <AppShell
      header={{ height: 60 }}
      navbar={{ width: 250, breakpoint: 'sm', collapsed: { mobile: !opened } }}
      padding="md"
    >
      <AppShell.Header>
        <Group h="100%" px="md" justify="space-between">
          <Group>
            <Burger opened={opened} onClick={toggle} hiddenFrom="sm" size="sm" />
            <Title order={4}>Mi Cuenta de AquaClean</Title>
          </Group>
          <Button
            variant="light"
            color="red"
            leftSection={<IconLogout size={14} />}
            onClick={handleLogout}
            visibleFrom="sm"
          >
            Cerrar Sesi√≥n
          </Button>
        </Group>
      </AppShell.Header>

      <AppShell.Navbar p="md">
         <NavLink 
            to="/dashboard" 
            end
            style={({ isActive }) => ({ ...linkStyles, ...(isActive ? activeLinkStyles : {}) })}
         >
            Resumen
         </NavLink>
         {/* Este es el enlace que ahora funcionar√° y tendr√° un estilo activo */}
         <NavLink 
            to="/dashboard/appointments" 
            style={({ isActive }) => ({ ...linkStyles, ...(isActive ? activeLinkStyles : {}) })}
         >
            Mis Citas
         </NavLink>

         <Button
            variant="light"
            color="red"
            leftSection={<IconLogout size={14} />}
            onClick={handleLogout}
            hiddenFrom="sm"
            mt="auto"
          >
            Cerrar Sesi√≥n
          </Button>
      </AppShell.Navbar>
      
      <AppShell.Main>
        <Outlet /> 
      </AppShell.Main>
    </AppShell>
  );
}


// ====== [24] apps/client/src/layouts/PublicLayout.tsx ======
// File: /apps/client/src/layouts/PublicLayout.tsx (ACTUALIZADO)

import { Outlet } from 'react-router-dom';
import { AppShell, Container } from '@mantine/core';

// Importamos los componentes que acabamos de crear
import { PublicHeader } from '../components/common/PublicHeader';
import { PublicFooter } from '../components/common/PublicFooter';

export function PublicLayout() {
  // Simplificamos el AppShell ya que no necesitamos la barra lateral (navbar)
  // que s√≠ usamos en el panel de admin.
  return (
    <AppShell header={{ height: 60 }} padding={0}>
      <AppShell.Header>
        <PublicHeader />
      </AppShell.Header>

      <AppShell.Main>
        {/* Usamos un Container para centrar y limitar el ancho del contenido de cada p√°gina */}
        <Container size="lg" py="xl">
          <Outlet />
        </Container>
      </AppShell.Main>
      
      {/* El footer se renderiza aqu√≠, despu√©s del contenido principal */}
      <PublicFooter />
    </AppShell>
  );
}


// ====== [25] apps/client/src/lib/apiClient.ts ======
// File: /apps/client/src/lib/apiClient.ts (ACTUALIZADO CON INTERCEPTOR DE AUTH)

import axios from 'axios';

const apiClient = axios.create({
  baseURL: 'http://localhost:3001/api',
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json',
  },
});

// --- INTERCEPTOR A√ëADIDO ---
// Este c√≥digo se ejecuta en CADA petici√≥n que se hace con apiClient
apiClient.interceptors.request.use(
  (config) => {
    // Buscamos el token del cliente. Podr√≠amos a√±adir l√≥gica para el token de admin tambi√©n.
    const token = localStorage.getItem('customerAuthToken');
    
    if (token) {
      // Si el token existe, lo a√±adimos a la cabecera de la petici√≥n
      config.headers.Authorization = `Bearer ${token}`;
    }
    
    return config;
  },
  (error) => {
    // Manejar errores de la configuraci√≥n de la petici√≥n
    return Promise.reject(error);
  }
);

export default apiClient;


// ====== [26] apps/client/src/main.tsx ======
// File: /apps/client/src/main.tsx (ACTUALIZADO CON ESTILOS DE GR√ÅFICOS)

import React from 'react';
import ReactDOM from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom';
import { MantineProvider } from '@mantine/core';
import { Notifications } from '@mantine/notifications';
import App from './App';

import '@mantine/core/styles.css';
import '@mantine/dates/styles.css';
import '@mantine/notifications/styles.css';
import '@mantine/charts/styles.css'; // <-- L√çNEA A√ëADIDA

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <MantineProvider>
      <Notifications />
      <BrowserRouter>
        <App />
      </BrowserRouter>
    </MantineProvider>
  </React.StrictMode>
);


// ====== [27] apps/client/src/pages/admin/AdminDashboardPage.tsx ======
// File: /apps/client/src/pages/admin/AdminDashboardPage.tsx (CON GR√ÅFICO DE BARRAS)

import { useEffect, useState } from 'react';
import { Title, Text, SimpleGrid, Paper, Group, ThemeIcon, LoadingOverlay, Alert } from '@mantine/core';
import { BarChart } from '@mantine/charts'; // <-- 1. IMPORTAMOS EL GR√ÅFICO
import { IconCalendar, IconCash, IconUserPlus, IconUserExclamation } from '@tabler/icons-react';
import apiClient from '../../lib/apiClient';

interface KpiData {
  appointmentsToday: number;
  potentialRevenueToday: number;
  newCustomersThisMonth: number;
  noShowRateThisMonth: number;
}

// Interfaz para los datos del gr√°fico
interface ChartData {
  date: string;
  Citas: number;
}

interface StatsCardProps {
  icon: React.ReactNode;
  title: string;
  value: string;
  description: string;
  color: string;
}

function StatsCard({ icon, title, value, description, color }: StatsCardProps) {
  return (
    <Paper withBorder p="md" radius="md">
      <Group justify="space-between">
        <Text size="xs" c="dimmed" tt="uppercase" fw={700}>{title}</Text>
        <ThemeIcon color={color} variant="light" size={38} radius="md">{icon}</ThemeIcon>
      </Group>
      <Group align="flex-end" gap="xs" mt={25}>
        <Text fz={38} fw={800} lh={1}>{value}</Text>
      </Group>
      <Text fz="sm" c="dimmed" mt={7}>{description}</Text>
    </Paper>
  );
}


export function AdminDashboardPage() {
  const [kpis, setKpis] = useState<KpiData | null>(null);
  const [chartData, setChartData] = useState<ChartData[]>([]); // <-- 2. NUEVO ESTADO
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        // --- 3. LLAMADAS EN PARALELO ---
        const [kpisResponse, chartResponse] = await Promise.all([
          apiClient.get<KpiData>('/admin/dashboard/kpis'),
          apiClient.get<ChartData[]>('/admin/dashboard/charts/bookings-over-time')
        ]);
        setKpis(kpisResponse.data);
        setChartData(chartResponse.data);
      } catch (err) {
        setError('No se pudieron cargar los datos del dashboard.');
      } finally {
        setLoading(false);
      }
    };
    fetchData();
  }, []);

  return (
    <div>
      <Title order={2} mb="xl">Dashboard Principal</Title>
      
      {error && <Alert color="red" title="Error">{error}</Alert>}
      
      <div style={{ position: 'relative' }}>
        <LoadingOverlay visible={loading} />
        {kpis && (
          <SimpleGrid cols={{ base: 1, sm: 2, lg: 4 }} mb="xl">
            <StatsCard icon={<IconCalendar size={24} />} title="Citas para Hoy" value={kpis.appointmentsToday.toString()} description="Citas con estado 'Confirmada'" color="blue" />
            <StatsCard icon={<IconCash size={24} />} title="Ingresos Potenciales Hoy" value={`${kpis.potentialRevenueToday.toFixed(2)}‚Ç¨`} description="Suma del precio de los servicios de hoy" color="green" />
            <StatsCard icon={<IconUserPlus size={24} />} title="Nuevos Clientes" value={kpis.newCustomersThisMonth.toString()} description="Clientes registrados este mes" color="teal" />
            <StatsCard icon={<IconUserExclamation size={24} />} title="Tasa de No-Shows" value={`${kpis.noShowRateThisMonth.toFixed(1)}%`} description="Porcentaje de ausencias este mes" color="orange" />
          </SimpleGrid>
        )}

        {/* --- 4. RENDERIZADO DEL GR√ÅFICO --- */}
        {!loading && chartData.length > 0 && (
          <Paper withBorder p="md" radius="md">
            <Title order={5} mb="md">Citas en los √öltimos 7 D√≠as</Title>
            <BarChart
              h={300}
              data={chartData}
              dataKey="date"
              series={[{ name: 'Citas', color: 'blue.6' }]}
              tickLine="y"
              yAxisProps={{ width: 30 }}
            />
          </Paper>
        )}
      </div>
    </div>
  );
}


// ====== [28] apps/client/src/pages/admin/AdminLoginPage.tsx ======
import { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Container,
  Title,
  Paper,
  TextInput,
  PasswordInput,
  Button,
  Text,
  LoadingOverlay,
  Stack,
} from '@mantine/core';
import apiClient from '../../lib/apiClient';

export function AdminLoginPage() {
  const navigate = useNavigate();
  const [email, setEmail] = useState('admin@aquaclean.com'); // Pre-rellenado para facilitar las pruebas
  const [password, setPassword] = useState('password123'); // Pre-rellenado para facilitar las pruebas
  const [error, setError] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);

  const handleLogin = async (event: React.FormEvent) => {
    event.preventDefault();
    setLoading(true);
    setError(null);

    try {
      const response = await apiClient.post('/auth/login', { email, password });
      
      // Aqu√≠ es donde guardaremos el token m√°s adelante (ej. en Zustand)
      console.log('Login exitoso:', response.data);
      // Por ahora, solo guardamos en localStorage para que funcione la protecci√≥n de rutas
      localStorage.setItem('authToken', response.data.token);
      
      // Redirigimos al dashboard de admin
      navigate('/admin');

    } catch (err: any) {
      console.error('Error en el login:', err);
      if (err.response && err.response.data && err.response.data.message) {
        setError(err.response.data.message);
      } else {
        setError('Ha ocurrido un error inesperado. Int√©ntalo de nuevo.');
      }
    } finally {
      setLoading(false);
    }
  };

  return (
    <Container size={420} my={40}>
      <Title ta="center">AquaClean Admin</Title>
      <Text c="dimmed" size="sm" ta="center" mt={5}>
        Inicia sesi√≥n para acceder al panel de administraci√≥n
      </Text>

      <Paper withBorder shadow="md" p={30} mt={30} radius="md" component="form" onSubmit={handleLogin}>
        <LoadingOverlay visible={loading} zIndex={1000} overlayProps={{ radius: 'sm', blur: 2 }} />
        <Stack gap="md">
          <TextInput
            label="Email"
            placeholder="tu@email.com"
            required
            value={email}
            onChange={(event) => setEmail(event.currentTarget.value)}
          />
          <PasswordInput
            label="Contrase√±a"
            placeholder="Tu contrase√±a"
            required
            value={password}
            onChange={(event) => setPassword(event.currentTarget.value)}
          />
          {error && (
            <Text c="red" size="sm" ta="center">
              {error}
            </Text>
          )}
          <Button fullWidth mt="xl" type="submit">
            Iniciar Sesi√≥n
          </Button>
        </Stack>
      </Paper>
    </Container>
  );
}


// ====== [29] apps/client/src/pages/admin/AdminPlanningPage.tsx ======
// ====== [27] apps/client/src/pages/admin/AdminPlanningPage.tsx ======
// File: /apps/client/src/pages/admin/AdminPlanningPage.tsx (CORRECCI√ìN FINAL DE ZONA HORARIA)

import { useState, useEffect, useCallback } from 'react';
import FullCalendar from '@fullcalendar/react';
import { EventDropArg, EventClickArg } from '@fullcalendar/core';
import dayGridPlugin from '@fullcalendar/daygrid';
import resourceTimeGridPlugin from '@fullcalendar/resource-timegrid';
import interactionPlugin from '@fullcalendar/interaction';
import { Alert, Modal, LoadingOverlay, Box } from '@mantine/core';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../lib/apiClient';
import { AppointmentForm } from '../../components/admin/AppointmentForm';

interface BusinessHour {
  daysOfWeek: number[];
  startTime: string;
  endTime: string;
}
interface Resource {
  id: string;
  title: string;
  businessHours?: BusinessHour[];
}
interface ViewConfig {
  minTime: string;
  maxTime: string;
}
const dayMapping: { [key: string]: number } = {
  sunday: 0, monday: 1, tuesday: 2, wednesday: 3,
  thursday: 4, friday: 5, saturday: 6,
};

export function AdminPlanningPage() {
  const [events, setEvents] = useState([]);
  const [resources, setResources] = useState<Resource[]>([]);
  const [error, setError] = useState<string | null>(null);
  const [opened, { open, close }] = useDisclosure(false);
  const [modalData, setModalData] = useState<any>(null);
  const [viewConfig, setViewConfig] = useState<ViewConfig | null>(null);
  const [loading, setLoading] = useState(true);

  const fetchData = useCallback(async () => {
    setLoading(true);
    try {
      const [appointmentsResponse, employeesResponse] = await Promise.all([
        apiClient.get('/admin/appointments'),
        apiClient.get('/employees'),
      ]);

      setEvents(appointmentsResponse.data);

      let minTime = '24:00';
      let maxTime = '00:00';

      const employeeResources = employeesResponse.data.map((emp: any) => {
        const businessHours: BusinessHour[] = [];
        if (emp.workSchedule) {
          for (const day in emp.workSchedule) {
            const shifts = emp.workSchedule[day];
            if (shifts && shifts.length > 0) {
              shifts.forEach((shift: { start: string, end: string }) => {
                if (dayMapping[day] !== undefined) {
                  businessHours.push({
                    daysOfWeek: [dayMapping[day]],
                    startTime: shift.start,
                    endTime: shift.end,
                  });
                }
                if (shift.start < minTime) minTime = shift.start;
                if (shift.end > maxTime) maxTime = shift.end;
              });
            }
          }
        }
        return { id: emp.id, title: emp.name, businessHours };
      });
      
      setResources(employeeResources);
      setViewConfig({
          minTime: minTime === '24:00' ? '08:00' : minTime,
          maxTime: maxTime === '00:00' ? '20:00' : maxTime
      });

    } catch (err) {
      console.error('Error fetching data for planning:', err);
      setError('No se pudieron cargar los datos del planning.');
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  const handleEventDrop = async (dropInfo: EventDropArg) => {
    try {
      const { event, newResource } = dropInfo;
      const newEmployeeId = newResource ? newResource.id : event._def.resourceIds?.[0];
      
      const updateData = {
        start: event.start,
        end: event.end,
        employeeId: newEmployeeId
      };

      await apiClient.put(`/admin/appointments/${event.id}`, updateData);
      fetchData();
    } catch (err) {
      console.error('Error al reagendar la cita:', err);
      dropInfo.revert();
    }
  };

  const handleDateClick = (arg: any) => {
    setModalData({ type: 'new', start: arg.date, employeeId: arg.resource?.id });
    open();
  };
  
  const handleEventClick = (arg: EventClickArg) => {
    setModalData({ type: 'edit', ...arg.event.extendedProps });
    open();
  };
  
  const handleFormSuccess = () => {
    close();
    fetchData();
  };

  if (error) {
    return <Alert title="Error" color="red" variant="light">{error}</Alert>;
  }

  return (
    <>
      <Modal opened={opened} onClose={close} title={modalData?.type === 'new' ? 'Crear Nueva Cita' : 'Editar Cita'} centered>
        <AppointmentForm initialData={modalData} onSuccess={handleFormSuccess} onClose={close} />
      </Modal>

      <Box style={{ height: 'calc(100vh - 60px - 32px)', position: 'relative' }}>
        <LoadingOverlay visible={loading} />
        {!loading && viewConfig && (
          <FullCalendar
            plugins={[resourceTimeGridPlugin, dayGridPlugin, interactionPlugin]}
            initialView="resourceTimeGridDay"
            headerToolbar={{
              left: 'prev,next today',
              center: 'title',
              right: 'resourceTimeGridDay,resourceTimeGridWeek,dayGridMonth',
            }}
            locale="es"
            editable={true}
            events={events}
            resources={resources}
            schedulerLicenseKey="GPL-My-Project-Is-Open-Source"
            height="100%"
            eventDrop={handleEventDrop}
            dateClick={handleDateClick}
            eventClick={handleEventClick}
            // --- L√çNEA ELIMINADA ---
            // timeZone="UTC" // <-- ¬°ESTA ES LA L√çNEA QUE CAUSABA EL PROBLEMA!
            slotMinTime={viewConfig.minTime}
            slotMaxTime={viewConfig.maxTime}
            businessHours={true}
            allDaySlot={false}
          />
        )}
      </Box>
    </>
  );
}


// ====== [30] apps/client/src/pages/admin/BusinessSettingsPage.tsx ======
// ====== [28] apps/client/src/pages/admin/BusinessSettingsPage.tsx ======
// File: /apps/client/src/pages/admin/BusinessSettingsPage.tsx (VERSI√ìN COMPLETA Y CORRECTA)

import { useState, useEffect } from 'react';
import { Title, Text, Paper, LoadingOverlay, Alert, Select, Button, Group, Stack, Divider, SimpleGrid, TextInput, ActionIcon, List, ThemeIcon, Tabs, PasswordInput } from '@mantine/core';
import { useForm } from '@mantine/form';
import { notifications } from '@mantine/notifications';
import { IconAlertCircle, IconCalendar, IconClock, IconTrash, IconSettings, IconMail, IconBrandWhatsapp } from '@tabler/icons-react';
import { DatePicker, TimeInput } from '@mantine/dates';
import dayjs from 'dayjs';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../lib/apiClient';
import { ScheduleEditor, WeeklySchedule } from '../../components/admin/ScheduleEditor';
import { ConflictResolutionModal } from '../../components/admin/ConflictResolutionModal';


interface Service { id: string; name: string; duration: number; }
interface DateOverride { id: string; date: string; reason?: string | null; openTime?: string | null; closeTime?: string | null; }
interface Conflict { id: string; startTime: string; user: { name: string | null; }; }

interface SettingsData {
  settings: {
    defaultServiceId: string | null;
    weeklySchedule: WeeklySchedule;
    defaultService: Service | null;
    emailHost?: string | null; emailPort?: string | null; emailUser?: string | null;
    emailPass?: string | null; emailFrom?: string | null;
    twilioSid?: string | null; twilioAuthToken?: string | null; twilioPhoneNumber?: string | null;
  };
  allServices: Service[];
}

export function BusinessSettingsPage() {
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [allServices, setAllServices] = useState<{ value: string; label: string }[]>([]);
  
  const [overrides, setOverrides] = useState<DateOverride[]>([]);
  const [selectedDate, setSelectedDate] = useState<Date | null>(null);
  const [overrideReason, setOverrideReason] = useState('');
  const [overrideOpenTime, setOverrideOpenTime] = useState('');
  const [overrideCloseTime, setOverrideCloseTime] = useState('');

  const [conflictingAppointments, setConflictingAppointments] = useState<Conflict[]>([]);
  const [conflictModalOpened, { open: openConflictModal, close: closeConflictModal }] = useDisclosure(false);

  const form = useForm({
    initialValues: {
      defaultServiceId: '',
      weeklySchedule: {} as WeeklySchedule,
      emailHost: '', emailPort: '', emailUser: '', emailPass: '', emailFrom: '',
      twilioSid: '', twilioAuthToken: '', twilioPhoneNumber: '',
    },
  });

  const fetchAllSettings = async () => {
    try {
      setLoading(true);
      const [settingsResponse, overridesResponse] = await Promise.all([
        apiClient.get<SettingsData>('/admin/settings'),
        apiClient.get<DateOverride[]>('/admin/overrides'),
      ]);
      const { settings, allServices } = settingsResponse.data;
      
      form.setValues({
        defaultServiceId: settings.defaultServiceId || '',
        weeklySchedule: settings.weeklySchedule || {},
        emailHost: settings.emailHost || '',
        emailPort: settings.emailPort || '',
        emailUser: settings.emailUser || '',
        emailPass: settings.emailPass || '',
        emailFrom: settings.emailFrom || '',
        twilioSid: settings.twilioSid || '',
        twilioAuthToken: settings.twilioAuthToken || '',
        twilioPhoneNumber: settings.twilioPhoneNumber || '',
      });

      setAllServices(allServices.map(s => ({ value: s.id, label: `${s.name} (${s.duration} min)` })));
      setOverrides(overridesResponse.data);
    } catch (err) {
      setError('No se pudo cargar la configuraci√≥n del negocio.');
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => { fetchAllSettings(); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const handleSubmit = async (values: typeof form.values) => {
    try {
      await apiClient.put('/admin/settings', values);
      notifications.show({
        title: '¬°Guardado!',
        message: 'La configuraci√≥n del negocio se ha actualizado correctamente.',
        color: 'green',
      });
    } catch (err) {
      notifications.show({
        title: 'Error',
        message: 'No se pudo guardar la configuraci√≥n. Int√©ntalo de nuevo.',
        color: 'red',
      });
    }
  };
  
  const handleAddOverride = async () => {
    if (!selectedDate) return;
    try {
      await apiClient.post('/admin/overrides', {
        date: dayjs(selectedDate).format('YYYY-MM-DD'),
        reason: overrideReason,
        openTime: overrideOpenTime || null,
        closeTime: overrideCloseTime || null,
      });
      notifications.show({ title: 'Configuraci√≥n de Fecha Guardada', message: 'El horario especial o cierre ha sido guardado.', color: 'green' });
      setSelectedDate(null);
      setOverrideReason('');
      setOverrideOpenTime('');
      setOverrideCloseTime('');
      fetchAllSettings();
    } catch (err: any) {
      if (err.response && err.response.status === 409) {
        setConflictingAppointments(err.response.data.conflicts || []);
        openConflictModal();
      } else {
        const errorMsg = err.response?.data?.message || 'No se pudo guardar la configuraci√≥n de la fecha.';
        notifications.show({ title: 'Error', message: errorMsg, color: 'red' });
      }
    }
  };

  const handleDeleteOverride = async (overrideId: string) => {
    try {
      await apiClient.delete(`/admin/overrides/${overrideId}`);
      notifications.show({ title: 'Configuraci√≥n Eliminada', message: 'La fecha vuelve a su horario normal.', color: 'orange' });
      fetchAllSettings();
    } catch (error) {
      notifications.show({ title: 'Error', message: 'No se pudo eliminar la configuraci√≥n.', color: 'red' });
    }
  };

  const overrideDates = overrides.map(o => dayjs(o.date).format('YYYY-MM-DD'));

  return (
    <>
      <ConflictResolutionModal opened={conflictModalOpened} onClose={closeConflictModal} conflicts={conflictingAppointments} />
      
      <Paper component="form" onSubmit={form.onSubmit(handleSubmit)} shadow="md" p="xl" withBorder pos="relative">
        <LoadingOverlay visible={loading} />
        <Title order={2}>Ajustes del Negocio</Title>
        <Text c="dimmed" mt="sm" mb="xl">Configura aqu√≠ las opciones principales de la aplicaci√≥n.</Text>

        {error && <Alert icon={<IconAlertCircle size="1rem" />} title="Error de Carga" color="red" mb="xl">{error}</Alert>}

        <Tabs defaultValue="general">
          <Tabs.List>
            <Tabs.Tab value="general" leftSection={<IconSettings size={14} />}>General y Horarios</Tabs.Tab>
            <Tabs.Tab value="email" leftSection={<IconMail size={14} />}>Email (SMTP)</Tabs.Tab>
            <Tabs.Tab value="whatsapp" leftSection={<IconBrandWhatsapp size={14} />}>WhatsApp (Twilio)</Tabs.Tab>
          </Tabs.List>

          <Tabs.Panel value="general" pt="xl">
            <Stack>
              <Title order={4}>Configuraci√≥n de Reservas</Title>
              <Select label="Servicio por Defecto para las Reservas" description="Este es el √∫nico servicio que se ofrecer√° a los clientes al reservar." data={allServices} disabled={loading} withAsterisk {...form.getInputProps('defaultServiceId')} />
              
              <Divider my="xl" label="Horario de Apertura del Negocio" />
              <Title order={4}>Horario Semanal Est√°ndar</Title>
              <ScheduleEditor value={form.values.weeklySchedule} onChange={(schedule) => form.setFieldValue('weeklySchedule', schedule)} />
              
              <Divider my="xl" label="Horarios Especiales y D√≠as de Cierre" />
              <Title order={4}>Anulaciones por Fecha</Title>
              <Text c="dimmed" size="sm" mb="md">
                Selecciona un d√≠a para definir un horario especial o marcarlo como cerrado. Esta configuraci√≥n anular√° el horario semanal est√°ndar solo para esa fecha.
              </Text>
              
              <SimpleGrid cols={{ base: 1, md: 2 }} spacing="xl">
                <Stack>
                  <DatePicker
                    value={selectedDate}
                    onChange={setSelectedDate}
                    minDate={new Date()}
                    renderDay={(date) => {
                      const day = date.getDate();
                      const isOverridden = overrideDates.includes(dayjs(date).format('YYYY-MM-DD'));
                      return (
                        <div style={{ position: 'relative' }}>
                          {day}
                          {isOverridden && <div style={{ position: 'absolute', top: -2, right: 0, width: 6, height: 6, borderRadius: '50%', backgroundColor: 'var(--mantine-color-red-5)' }} />}
                        </div>
                      );
                    }}
                  />
                  {selectedDate && (
                    <Paper withBorder p="sm" mt="md">
                      <Text size="sm" fw={500}>Configuraci√≥n para: {dayjs(selectedDate).format('DD/MM/YYYY')}</Text>
                      <TextInput label="Raz√≥n (opcional)" placeholder="Ej: Festivo, Evento" value={overrideReason} onChange={(e) => setOverrideReason(e.currentTarget.value)} mt="xs" />
                      <Text size="xs" c="dimmed" mt="md">Deja las horas en blanco para un cierre de d√≠a completo.</Text>
                      <Group grow>
                        <TimeInput label="Nueva Apertura" value={overrideOpenTime} onChange={(e) => setOverrideOpenTime(e.currentTarget.value)} />
                        <TimeInput label="Nuevo Cierre" value={overrideCloseTime} onChange={(e) => setOverrideCloseTime(e.currentTarget.value)} />
                      </Group>
                      <Button onClick={handleAddOverride} fullWidth mt="md">Guardar Configuraci√≥n de Fecha</Button>
                    </Paper>
                  )}
                </Stack>
                <Stack>
                  <Title order={5}>Fechas con Configuraci√≥n Especial</Title>
                  {overrides.length > 0 ? (
                    <List spacing="sm" size="sm">
                      {overrides.map(override => (
                        <List.Item
                          key={override.id}
                          icon={
                            <ThemeIcon color={override.openTime ? 'blue' : 'red'} size={24} radius="xl">
                              {override.openTime ? <IconClock size="1rem" /> : <IconCalendar size="1rem" />}
                            </ThemeIcon>
                          }
                        >
                          <Group justify="space-between">
                            <div>
                              <Text>{dayjs(override.date).format('DD/MM/YYYY')}</Text>
                              <Text size="xs" c="dimmed">
                                {override.openTime ? `Horario: ${override.openTime} - ${override.closeTime}` : 'Cerrado todo el d√≠a'}
                                {override.reason && ` (${override.reason})`}
                              </Text>
                            </div>
                            <ActionIcon variant="light" color="red" size="sm" onClick={() => handleDeleteOverride(override.id)}>
                              <IconTrash size={14} />
                            </ActionIcon>
                          </Group>
                        </List.Item>
                      ))}
                    </List>
                  ) : (
                    <Text c="dimmed" size="sm">No hay configuraciones especiales programadas.</Text>
                  )}
                </Stack>
              </SimpleGrid>
            </Stack>
          </Tabs.Panel>
          
          <Tabs.Panel value="email" pt="xl">
            <Stack>
              <Title order={4}>Configuraci√≥n de Email (SMTP)</Title>
              <Text c="dimmed" size="sm">Introduce aqu√≠ los datos de tu proveedor de email para enviar notificaciones (ej: Google Workspace, Namecheap, etc.).</Text>
              <TextInput label="Servidor (Host)" placeholder="smtp.ejemplo.com" {...form.getInputProps('emailHost')} />
              <TextInput label="Puerto" placeholder="465" {...form.getInputProps('emailPort')} />
              <TextInput label="Usuario" placeholder="tu@email.com" {...form.getInputProps('emailUser')} />
              <PasswordInput label="Contrase√±a" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢" {...form.getInputProps('emailPass')} />
              <TextInput label="Email 'De'" placeholder="Nombre Negocio <tu@email.com>" description="El nombre y email que ver√°n tus clientes." {...form.getInputProps('emailFrom')} />
            </Stack>
          </Tabs.Panel>

          <Tabs.Panel value="whatsapp" pt="xl">
            <Stack>
              <Title order={4}>Configuraci√≥n de WhatsApp (Twilio)</Title>
              <Text c="dimmed" size="sm">Introduce aqu√≠ tus credenciales de Twilio para enviar recordatorios por WhatsApp.</Text>
              <TextInput label="Account SID" placeholder="ACxxxxxxxxxxxxxxxxxxxxxxxx" {...form.getInputProps('twilioSid')} />
              <PasswordInput label="Auth Token" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢" {...form.getInputProps('twilioAuthToken')} />
              <TextInput label="N√∫mero de Tel√©fono de Twilio" placeholder="+14155238886" {...form.getInputProps('twilioPhoneNumber')} />
            </Stack>
          </Tabs.Panel>
        </Tabs>
        
        <Group justify="flex-end" mt="xl">
          <Button type="submit" disabled={loading} size="md">Guardar todos los Ajustes</Button>
        </Group>
      </Paper>
    </>
  );
}


// ====== [31] apps/client/src/pages/admin/EmployeesManagementPage.tsx ======
// File: /apps/client/src/pages/admin/EmployeesManagementPage.tsx (CON SELECTOR DE COLOR)

import { useEffect, useState } from 'react';
import { Table, Title, Button, Modal, TextInput, Select, Group, Avatar, Text, Badge, SegmentedControl, Tabs, LoadingOverlay, Stack, Box, Textarea, ColorInput } from '@mantine/core'; // ColorInput a√±adido
import { useDisclosure } from '@mantine/hooks';
import { useForm, zodResolver } from '@mantine/form';
import { notifications } from '@mantine/notifications';
import { IconArchive, IconUserPlus, IconUserCheck, IconUser, IconClock, IconBeach, IconPalette } from '@tabler/icons-react'; // IconPalette a√±adido
import apiClient from '../../lib/apiClient';
import { createEmployeeSchema } from '@aquaclean/types';
import { ScheduleEditor, WeeklySchedule } from '../../components/admin/ScheduleEditor';
import { AbsenceCalendar, Absence } from '../../components/admin/AbsenceCalendar';
import { ConflictResolutionModal } from '../../components/admin/ConflictResolutionModal';

export interface Employee {
  id: string; name: string; email: string; role: 'ADMIN' | 'EMPLOYEE';
  status: 'ACTIVE' | 'ARCHIVED'; imageUrl?: string | null; bio?: string | null;
  workSchedule?: WeeklySchedule; color?: string;
}
interface Conflict { id: string; startTime: string; user: { name: string | null; }; }

export function EmployeesManagementPage() {
  const [employees, setEmployees] = useState<Employee[]>([]);
  const [loading, setLoading] = useState(true);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [selectedEmployee, setSelectedEmployee] = useState<Employee | undefined>(undefined);
  const [employeeAbsences, setEmployeeAbsences] = useState<Absence[]>([]);
  const [statusFilter, setStatusFilter] = useState('ACTIVE');
  
  const [conflictingAppointments, setConflictingAppointments] = useState<Conflict[]>([]);
  const [conflictModalOpened, { open: openConflictModal, close: closeConflictModal }] = useDisclosure(false);

  const [modalOpened, { open: openModal, close: closeModal }] = useDisclosure(false);

  const form = useForm({
    validate: zodResolver(createEmployeeSchema),
    initialValues: { name: '', email: '', role: 'EMPLOYEE', bio: '', imageUrl: '', workSchedule: {} as WeeklySchedule, color: '#868e96' },
  });

  const fetchEmployees = async () => {
    try { setLoading(true); const response = await apiClient.get<Employee[]>(`/employees?status=${statusFilter}`); setEmployees(response.data);
    } catch (err) { notifications.show({ title: 'Error', message: 'No se pudieron cargar los empleados.', color: 'red' });
    } finally { setLoading(false); }
  };

  useEffect(() => { fetchEmployees(); }, [statusFilter]);

  const handleCreate = () => {
    form.reset(); setSelectedEmployee(undefined); setEmployeeAbsences([]); openModal();
  };

  const handleEdit = async (employee: Employee) => {
    setLoading(true); setSelectedEmployee(employee);
    const sanitizedEmployeeData = { 
        ...employee, 
        bio: employee.bio || '', 
        imageUrl: employee.imageUrl || '', 
        workSchedule: employee.workSchedule || {},
        color: employee.color || '#868e96'
    };
    form.setValues(sanitizedEmployeeData);
    try {
        const absencesResponse = await apiClient.get<Absence[]>(`/employees/${employee.id}/absences`);
        setEmployeeAbsences(absencesResponse.data); openModal();
    } catch (error) { notifications.show({ title: 'Error', message: 'No se pudieron cargar las ausencias del empleado.', color: 'red' });
    } finally { setLoading(false); }
  };

  const handleFormSubmit = async (values: typeof form.values) => {
    setIsSubmitting(true);
    try {
      if (selectedEmployee) { await apiClient.put(`/employees/${selectedEmployee.id}`, values);
        notifications.show({ title: '¬°Guardado!', message: 'Los datos del empleado han sido actualizados.', color: 'green' });
      } else { await apiClient.post('/employees', values);
        notifications.show({ title: '¬°Creado!', message: 'El nuevo empleado ha sido a√±adido.', color: 'green' });
      }
      fetchEmployees(); closeModal();
    } catch (err) { notifications.show({ title: 'Error', message: 'No se pudo guardar el empleado.', color: 'red' });
    } finally { setIsSubmitting(false); }
  };

  const handleStatusChange = async (employee: Employee, status: 'ACTIVE' | 'ARCHIVED') => {
    try { await apiClient.put(`/employees/${employee.id}`, { status });
      notifications.show({ title: `Empleado ${status === 'ACTIVE' ? 'Reactivado' : 'Archivado'}`, message: `${employee.name} ha sido actualizado.`, color: status === 'ACTIVE' ? 'teal' : 'orange' });
      fetchEmployees();
    } catch (err) { notifications.show({ title: 'Error', message: 'No se pudo cambiar el estado del empleado.', color: 'red' }); }
  };

  const handleAddAbsence = async (dates: [Date, Date]) => {
      if (!selectedEmployee) return;
      try {
          const newAbsence = await apiClient.post<Absence>(`/employees/${selectedEmployee.id}/absences`, { startDate: dates[0], endDate: dates[1] });
          setEmployeeAbsences([...employeeAbsences, newAbsence.data]);
          notifications.show({ title: 'Ausencia A√±adida', message: 'El periodo de ausencia ha sido guardado.', color: 'green' });
      } catch (error: any) { 
          if (error.response && error.response.status === 409) {
              setConflictingAppointments(error.response.data.conflicts || []);
              openConflictModal();
          } else {
              notifications.show({ title: 'Error', message: 'No se pudo guardar la ausencia.', color: 'red' });
          }
      }
  };

  const handleDeleteAbsence = async (absenceId: string) => {
      if (!selectedEmployee) return;
      try {
          await apiClient.delete(`/employees/${selectedEmployee.id}/absences/${absenceId}`);
          setEmployeeAbsences(employeeAbsences.filter(a => a.id !== absenceId));
          notifications.show({ title: 'Ausencia Eliminada', message: 'El periodo de ausencia ha sido eliminado.', color: 'orange' });
      } catch (error) { notifications.show({ title: 'Error', message: 'No se pudo eliminar la ausencia.', color: 'red' }); }
  };
  
  return (
    <div>
      <Modal opened={modalOpened} onClose={closeModal} title={selectedEmployee ? `Editando a ${selectedEmployee.name}` : 'A√±adir Nuevo Empleado'} size="xl" centered>
        <LoadingOverlay visible={isSubmitting || loading} />
        <Tabs defaultValue="profile">
          <Tabs.List>
            <Tabs.Tab value="profile" leftSection={<IconUser size={14} />}>Perfil</Tabs.Tab>
            <Tabs.Tab value="schedule" leftSection={<IconClock size={14} />}>Horario Laboral</Tabs.Tab>
            <Tabs.Tab value="absences" leftSection={<IconBeach size={14} />}>Ausencias</Tabs.Tab>
          </Tabs.List>

          <form onSubmit={form.onSubmit(handleFormSubmit)}>
            <Tabs.Panel value="profile" pt="md">
              <Stack>
                <TextInput label="Nombre Completo" {...form.getInputProps('name')} withAsterisk />
                <TextInput label="Email" type="email" {...form.getInputProps('email')} withAsterisk />
                <Select
                    label="Rol en el sistema"
                    data={[{ value: 'EMPLOYEE', label: 'Empleado' }, { value: 'ADMIN', label: 'Administrador' }]}
                    {...form.getInputProps('role')}
                    withAsterisk
                />
                <TextInput label="URL de la Foto" {...form.getInputProps('imageUrl')} />
                <Textarea label="Biograf√≠a" {...form.getInputProps('bio')} /> 
                {/* --- COMPONENTE A√ëADIDO --- */}
                <ColorInput 
                  label="Color en el Calendario"
                  description="Elige un color para identificar a este empleado en el planning."
                  {...form.getInputProps('color')}
                  withAsterisk
                />
              </Stack>
            </Tabs.Panel>
            
            <Tabs.Panel value="schedule" pt="md">
                <ScheduleEditor value={form.values.workSchedule} onChange={(schedule) => form.setFieldValue('workSchedule', schedule)} />
            </Tabs.Panel>

            {selectedEmployee && (
              <Tabs.Panel value="absences" pt="md">
                  <AbsenceCalendar absences={employeeAbsences} onAddAbsence={handleAddAbsence} onDeleteAbsence={handleDeleteAbsence} />
              </Tabs.Panel>
            )}

            <Group justify="flex-end" mt="xl">
                <Button variant="default" onClick={closeModal}>Cancelar</Button>
                <Button type="submit">Guardar Cambios</Button>
            </Group>
          </form>
        </Tabs>
      </Modal>

      <ConflictResolutionModal opened={conflictModalOpened} onClose={closeConflictModal} conflicts={conflictingAppointments} />

      <Group justify="space-between" mb="xl">
        <Title order={2}>Gesti√≥n de Empleados</Title>
        <Button onClick={handleCreate} leftSection={<IconUserPlus size={14} />}>A√±adir Empleado</Button>
      </Group>

      <SegmentedControl value={statusFilter} onChange={setStatusFilter} data={[{ label: 'Activos', value: 'ACTIVE' }, { label: 'Archivados', value: 'ARCHIVED' }]} mb="md" />

      <Table striped highlightOnHover withTableBorder>
        <Table.Thead>
          <Table.Tr><Table.Th>Nombre</Table.Th><Table.Th>Rol</Table.Th><Table.Th>Estado</Table.Th><Table.Th>Acciones</Table.Th></Table.Tr>
        </Table.Thead>
        <Table.Tbody>
          {employees.map((employee) => (
            <Table.Tr key={employee.id}>
              <Table.Td><Group><Avatar src={employee.imageUrl || undefined} name={employee.name} radius="xl" color={employee.color || 'gray'} /><Box><Text>{employee.name}</Text><Text size="xs" c="dimmed">{employee.email}</Text></Box></Group></Table.Td>
              <Table.Td>{employee.role === 'ADMIN' ? 'Administrador' : 'Empleado'}</Table.Td>
              <Table.Td><Badge color={employee.status === 'ACTIVE' ? 'green' : 'gray'}>{employee.status === 'ACTIVE' ? 'Activo' : 'Archivado'}</Badge></Table.Td>
              <Table.Td>
                <Group gap="xs">
                  <Button variant="light" size="xs" onClick={() => handleEdit(employee)}>Editar</Button>
                  {employee.status === 'ACTIVE' ? (
                     <Button variant="light" color="orange" size="xs" onClick={() => handleStatusChange(employee, 'ARCHIVED')} leftSection={<IconArchive size={14} />}>Archivar</Button>
                  ) : (
                     <Button variant="light" color="teal" size="xs" onClick={() => handleStatusChange(employee, 'ACTIVE')} leftSection={<IconUserCheck size={14} />}>Reactivar</Button>
                  )}
                </Group>
              </Table.Td>
            </Table.Tr>
          ))}
        </Table.Tbody>
      </Table>
    </div>
  );
}


// ====== [32] apps/client/src/pages/admin/ReviewsManagementPage.tsx ======
// File: /apps/client/src/pages/admin/ReviewsManagementPage.tsx (NUEVO ARCHIVO)

import { useEffect, useState } from 'react';
import { Title, Table, Group, Badge, ActionIcon, SegmentedControl, Text, LoadingOverlay, Alert } from '@mantine/core';
import { IconCheck, IconEyeOff } from '@tabler/icons-react';
import { notifications } from '@mantine/notifications';
import dayjs from 'dayjs';
import apiClient from '../../lib/apiClient';

// Definimos los tipos de datos que esperamos de la API
type ReviewStatus = 'PENDING' | 'APPROVED' | 'HIDDEN';
interface Review {
  id: string;
  rating: number;
  comment: string | null;
  status: ReviewStatus;
  createdAt: string;
  employeeName: string;
  customerName: string | null;
  serviceName: string;
}

const statusColors: Record<ReviewStatus, string> = {
  PENDING: 'yellow',
  APPROVED: 'green',
  HIDDEN: 'gray',
};

export function ReviewsManagementPage() {
  const [reviews, setReviews] = useState<Review[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [statusFilter, setStatusFilter] = useState<ReviewStatus>('PENDING');

  const fetchReviews = async () => {
    try {
      setLoading(true);
      setError(null);
      const response = await apiClient.get<Review[]>('/reviews/admin');
      setReviews(response.data);
    } catch (err) {
      setError('No se pudieron cargar las valoraciones.');
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchReviews();
  }, []);

  const handleUpdateStatus = async (reviewId: string, newStatus: ReviewStatus) => {
    try {
      await apiClient.put(`/reviews/admin/${reviewId}`, { status: newStatus });
      notifications.show({
        title: 'Estado actualizado',
        message: `La valoraci√≥n ha sido marcada como ${newStatus === 'APPROVED' ? 'Aprobada' : 'Oculta'}.`,
        color: 'blue',
      });
      // Actualizamos el estado localmente para una respuesta instant√°nea en la UI
      setReviews(prevReviews =>
        prevReviews.map(review =>
          review.id === reviewId ? { ...review, status: newStatus } : review
        )
      );
    } catch (err) {
      notifications.show({
        title: 'Error',
        message: 'No se pudo actualizar el estado de la valoraci√≥n.',
        color: 'red',
      });
    }
  };

  const filteredReviews = reviews.filter(review => review.status === statusFilter);

  return (
    <div>
      <Title order={2} mb="xl">
        Gesti√≥n de Valoraciones
      </Title>

      <SegmentedControl
        value={statusFilter}
        onChange={(value) => setStatusFilter(value as ReviewStatus)}
        data={[
          { label: 'Pendientes', value: 'PENDING' },
          { label: 'Aprobadas', value: 'APPROVED' },
          { label: 'Ocultas', value: 'HIDDEN' },
        ]}
        mb="lg"
      />

      <div style={{ position: 'relative' }}>
        <LoadingOverlay visible={loading} />
        {error && <Alert color="red" title="Error">{error}</Alert>}
        
        <Table striped highlightOnHover withTableBorder>
          <Table.Thead>
            <Table.Tr>
              <Table.Th>Cliente</Table.Th>
              <Table.Th>Puntuaci√≥n</Table.Th>
              <Table.Th>Comentario</Table.Th>
              <Table.Th>Estado</Table.Th>
              <Table.Th>Fecha</Table.Th>
              <Table.Th>Acciones</Table.Th>
            </Table.Tr>
          </Table.Thead>
          <Table.Tbody>
            {filteredReviews.length > 0 ? (
              filteredReviews.map((review) => (
                <Table.Tr key={review.id}>
                  <Table.Td>{review.customerName || 'N/A'}</Table.Td>
                  <Table.Td>{'‚≠ê'.repeat(review.rating)}</Table.Td>
                  <Table.Td>
                    <Text size="sm" lineClamp={3}>{review.comment || 'Sin comentario.'}</Text>
                  </Table.Td>
                  <Table.Td>
                    <Badge color={statusColors[review.status]}>{review.status}</Badge>
                  </Table.Td>
                  <Table.Td>{dayjs(review.createdAt).format('DD/MM/YYYY')}</Table.Td>
                  <Table.Td>
                    {review.status === 'PENDING' && (
                      <Group gap="xs">
                        <ActionIcon
                          variant="light"
                          color="green"
                          onClick={() => handleUpdateStatus(review.id, 'APPROVED')}
                          title="Aprobar"
                        >
                          <IconCheck size={16} />
                        </ActionIcon>
                        <ActionIcon
                          variant="light"
                          color="gray"
                          onClick={() => handleUpdateStatus(review.id, 'HIDDEN')}
                          title="Ocultar"
                        >
                          <IconEyeOff size={16} />
                        </ActionIcon>
                      </Group>
                    )}
                  </Table.Td>
                </Table.Tr>
              ))
            ) : (
              <Table.Tr>
                <Table.Td colSpan={6}>
                  <Text c="dimmed" ta="center" py="lg">
                    No hay valoraciones en esta categor√≠a.
                  </Text>
                </Table.Td>
              </Table.Tr>
            )}
          </Table.Tbody>
        </Table>
      </div>
    </div>
  );
}


// ====== [33] apps/client/src/pages/admin/ServicesManagementPage.tsx ======
// File: /apps/client/src/pages/admin/ServicesManagementPage.tsx (RECONSTRUIDO)

import { useEffect, useState } from 'react';
import { Table, Title, Button, Group, Modal, ActionIcon, Switch, Text } from '@mantine/core';
import { useDisclosure } from '@mantine/hooks';
import { notifications } from '@mantine/notifications';
import { IconPencil, IconTrash } from '@tabler/icons-react';
import apiClient from '../../lib/apiClient';
import type { Service } from '@aquaclean/types';
import { ServiceForm } from '../../components/admin/ServiceForm';

export function ServicesManagementPage() {
  const [services, setServices] = useState<Service[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [selectedService, setSelectedService] = useState<Partial<Service> | undefined>(undefined);
  const [isSubmitting, setIsSubmitting] = useState(false);

  const [modalOpened, { open: openModal, close: closeModal }] = useDisclosure(false);
  const [deleteModalOpened, { open: openDeleteModal, close: closeDeleteModal }] = useDisclosure(false);

  const fetchServices = async () => {
    try {
      setLoading(true);
      const response = await apiClient.get<Service[]>('/services');
      setServices(response.data);
    } catch (err) {
      setError('No se pudieron cargar los servicios.');
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchServices();
  }, []);

  const handleCreate = () => {
    setSelectedService(undefined);
    openModal();
  };

  const handleEdit = (service: Service) => {
    setSelectedService(service);
    openModal();
  };
  
  const handleDeleteConfirm = (service: Service) => {
    setSelectedService(service);
    openDeleteModal();
  };

  const handleFormSuccess = () => {
    fetchServices(); // Recargamos la lista de servicios
    closeModal();
    setIsSubmitting(false);
  };
  
  const handleToggleActive = async (service: Service) => {
    try {
      const updatedService = { ...service, isActive: !service.isActive };
      await apiClient.put(`/services/${service.id}`, { isActive: updatedService.isActive });
      setServices(services.map(s => s.id === service.id ? updatedService : s));
      notifications.show({ title: 'Estado Cambiado', message: `El servicio "${service.name}" ha sido actualizado.`, color: 'blue' });
    } catch (err) {
      notifications.show({ title: 'Error', message: 'No se pudo cambiar el estado del servicio.', color: 'red' });
    }
  };

  const handleFormSubmit = async (serviceData: Partial<Service>) => {
    setIsSubmitting(true);
    try {
      if (serviceData.id) { // Modo Edici√≥n
        const response = await apiClient.put<Service>(`/services/${serviceData.id}`, serviceData);
        notifications.show({ title: '¬°Actualizado!', message: 'El servicio ha sido guardado correctamente.', color: 'green' });
      } else { // Modo Creaci√≥n
        const response = await apiClient.post<Service>('/services', serviceData);
        notifications.show({ title: '¬°Creado!', message: 'El nuevo servicio ha sido a√±adido.', color: 'green' });
      }
      handleFormSuccess();
    } catch (err: any) {
      setIsSubmitting(false);
      const errorMessage = err.response?.data?.message || 'Ocurri√≥ un error al guardar el servicio.';
      notifications.show({ title: 'Error', message: errorMessage, color: 'red' });
    }
  };
  
  const handleDeleteService = async () => {
    if (!selectedService?.id) return;
    setIsSubmitting(true);
    try {
      await apiClient.delete(`/services/${selectedService.id}`);
      notifications.show({ title: '¬°Eliminado!', message: 'El servicio ha sido eliminado.', color: 'orange' });
      fetchServices();
      closeDeleteModal();
    } catch (err: any) {
      const errorMessage = err.response?.data?.message || 'No se pudo eliminar el servicio.';
      notifications.show({ title: 'Error', message: errorMessage, color: 'red' });
    } finally {
      setIsSubmitting(false);
    }
  };


  if (loading) return <p>Cargando servicios...</p>;
  if (error) return <p style={{ color: 'red' }}>{error}</p>;

  return (
    <div>
      {/* Modal para Crear/Editar */}
      <Modal opened={modalOpened} onClose={closeModal} title={selectedService?.id ? 'Editar Servicio' : 'Crear Nuevo Servicio'} centered>
        <ServiceForm 
          initialData={selectedService}
          onSuccess={handleFormSubmit}
          onClose={closeModal}
          isSubmitting={isSubmitting}
        />
      </Modal>

      {/* Modal de confirmaci√≥n para Eliminar */}
      <Modal opened={deleteModalOpened} onClose={closeDeleteModal} title="Confirmar Eliminaci√≥n" centered>
        <Text>¬øEst√°s seguro de que quieres eliminar el servicio "{selectedService?.name}"? Esta acci√≥n no se puede deshacer.</Text>
        <Group justify="flex-end" mt="md">
          <Button variant="default" onClick={closeDeleteModal}>Cancelar</Button>
          <Button color="red" onClick={handleDeleteService} loading={isSubmitting}>Eliminar Servicio</Button>
        </Group>
      </Modal>

      <Group justify="space-between" mb="xl">
        <Title order={2}>Gesti√≥n de Servicios</Title>
        <Button onClick={handleCreate}>Crear Nuevo Servicio</Button>
      </Group>

      <Table striped highlightOnHover withTableBorder>
        <Table.Thead>
          <Table.Tr>
            <Table.Th>Nombre</Table.Th>
            <Table.Th>Duraci√≥n</Table.Th>
            <Table.Th>Estado</Table.Th>
            <Table.Th>Acciones</Table.Th>
          </Table.Tr>
        </Table.Thead>
        <Table.Tbody>
          {services.map((service) => (
            <Table.Tr key={service.id}>
              <Table.Td>{service.name}</Table.Td>
              <Table.Td>{service.duration} min</Table.Td>
              <Table.Td>
                <Switch 
                  checked={service.isActive} 
                  onChange={() => handleToggleActive(service)}
                  label={service.isActive ? 'Activo' : 'Inactivo'}
                />
              </Table.Td>
              <Table.Td>
                <Group gap="xs">
                  <ActionIcon variant="light" onClick={() => handleEdit(service)}>
                    <IconPencil size={16} />
                  </ActionIcon>
                  <ActionIcon variant="light" color="red" onClick={() => handleDeleteConfirm(service)}>
                    <IconTrash size={16} />
                  </ActionIcon>
                </Group>
              </Table.Td>
            </Table.Tr>
          ))}
        </Table.Tbody>
      </Table>
    </div>
  );
}


// ====== [34] apps/client/src/pages/customer/CustomerAppointmentsPage.tsx ======
// File: /apps/client/src/pages/customer/CustomerAppointmentsPage.tsx (CON CORRECCI√ìN DE LOADER)

import { useEffect, useState } from 'react';
import { Title, Text, Tabs, Stack, Card, Group, Badge, Button, LoadingOverlay, Alert, Modal } from '@mantine/core';
import { useDisclosure } from '@mantine/hooks';
import { notifications } from '@mantine/notifications';
import dayjs from 'dayjs';
import 'dayjs/locale/es';
import apiClient from '../../lib/apiClient';

dayjs.locale('es');

interface AppointmentService {
  service: { name: string; duration: number };
}
interface Appointment {
  id: string;
  startTime: string;
  status: 'CONFIRMED' | 'COMPLETED' | 'CANCELLED' | 'NO_SHOW';
  services: AppointmentService[];
  employee: { name: string };
}

const statusConfig = {
    CONFIRMED: { label: 'Confirmada', color: 'blue' },
    COMPLETED: { label: 'Completada', color: 'green' },
    CANCELLED: { label: 'Cancelada', color: 'gray' },
    NO_SHOW: { label: 'No Presentado', color: 'orange' },
};

function AppointmentCard({ appointment, onCancel }: { appointment: Appointment; onCancel: (id: string) => void; }) {
    const config = statusConfig[appointment.status] || { label: 'Desconocido', color: 'gray' };
    const service = appointment.services[0]?.service;
    const isPast = dayjs(appointment.startTime).isBefore(dayjs());

    return (
        <Card withBorder radius="md">
            <Group justify="space-between">
                <Stack gap="xs">
                    <Text fw={500}>{service?.name || 'Servicio'}</Text>
                    <Text size="sm" c="dimmed">{dayjs(appointment.startTime).format('dddd, D [de] MMMM [de] YYYY')}</Text>
                    <Text size="sm" c="dimmed">Hora: {dayjs(appointment.startTime).format('HH:mm')}h</Text>
                </Stack>
                <Badge color={config.color} variant="light">{config.label}</Badge>
            </Group>
            <Group justify="flex-end" mt="md">
                {appointment.status === 'CONFIRMED' && !isPast && (
                    <Button variant="outline" color="red" size="xs" onClick={() => onCancel(appointment.id)}>
                        Cancelar Cita
                    </Button>
                )}
                {appointment.status === 'COMPLETED' && (
                    <Button variant="light" size="xs">Reservar de Nuevo</Button>
                )}
            </Group>
        </Card>
    );
}


export function CustomerAppointmentsPage() {
  const [appointments, setAppointments] = useState<Appointment[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  const [modalOpened, { open: openModal, close: closeModal }] = useDisclosure(false);
  const [appointmentToCancel, setAppointmentToCancel] = useState<string | null>(null);
  
  // --- ESTADO CORREGIDO ---
  const [isSubmitting, setIsSubmitting] = useState(false);

  const openCancelModal = (id: string) => {
    setAppointmentToCancel(id);
    openModal();
  };

  const handleConfirmCancel = async () => {
    if (!appointmentToCancel) return;
    
    setIsSubmitting(true); // <-- Usamos el nuevo estado
    try {
      await apiClient.post(`/me/appointments/${appointmentToCancel}/cancel`);
      
      setAppointments(currentAppointments =>
        currentAppointments.map(appt =>
          appt.id === appointmentToCancel ? { ...appt, status: 'CANCELLED' } : appt
        )
      );
      
      notifications.show({
        title: 'Cita Cancelada', message: 'Tu cita ha sido cancelada correctamente.', color: 'orange',
      });
      closeModal(); // Cerramos el modal solo en caso de √©xito
    } catch (err: any) {
      notifications.show({
        title: 'Error', message: err.response?.data?.message || 'No se pudo cancelar la cita.', color: 'red',
      });
    } finally {
      setIsSubmitting(false); // <-- Desactivamos el loader siempre
      setAppointmentToCancel(null); // Limpiamos el ID
    }
  };


  useEffect(() => {
    const fetchAppointments = async () => {
      try {
        const response = await apiClient.get<Appointment[]>('/me/appointments');
        setAppointments(response.data);
      } catch (err) { setError('No se pudieron cargar tus citas.'); }
      finally { setLoading(false); }
    };
    fetchAppointments();
  }, []);

  const now = dayjs();
  const upcomingAppointments = appointments.filter(
    (appt) => appt.status === 'CONFIRMED' && dayjs(appt.startTime).isAfter(now)
  );
  const pastAppointments = appointments.filter(
    (appt) => appt.status !== 'CONFIRMED' || dayjs(appt.startTime).isBefore(now)
  );

  return (
    <>
      <Modal opened={modalOpened} onClose={() => !isSubmitting && closeModal()} title="Confirmar Cancelaci√≥n" centered>
        <Text>¬øEst√°s seguro de que quieres cancelar esta cita? Esta acci√≥n no se puede deshacer.</Text>
        <Group justify="flex-end" mt="xl">
          <Button variant="default" onClick={closeModal} disabled={isSubmitting}>No, mantener cita</Button>
          <Button color="red" onClick={handleConfirmCancel} loading={isSubmitting}>S√≠, cancelar</Button>
        </Group>
      </Modal>

      <div>
        <Title order={2} mb="xl">Mis Citas</Title>
        <div style={{ position: "relative" }}>
          <LoadingOverlay visible={loading} />
          {error && <Alert color="red" title="Error">{error}</Alert>}
          {!loading && !error && (
            <Tabs defaultValue="upcoming">
              <Tabs.List>
                <Tabs.Tab value="upcoming">Pr√≥ximas Citas ({upcomingAppointments.length})</Tabs.Tab>
                <Tabs.Tab value="history">Historial ({pastAppointments.length})</Tabs.Tab>
              </Tabs.List>
              <Tabs.Panel value="upcoming" pt="lg">
                <Stack>
                  {upcomingAppointments.length > 0 ? (
                    upcomingAppointments.map(appt => <AppointmentCard key={appt.id} appointment={appt} onCancel={openCancelModal} />)
                  ) : (<Text c="dimmed">No tienes ninguna cita programada.</Text>)}
                </Stack>
              </Tabs.Panel>
              <Tabs.Panel value="history" pt="lg">
                <Stack>
                  {pastAppointments.length > 0 ? (
                    pastAppointments.map(appt => <AppointmentCard key={appt.id} appointment={appt} onCancel={openCancelModal} />)
                  ) : (<Text c="dimmed">A√∫n no tienes un historial de citas.</Text>)}
                </Stack>
              </Tabs.Panel>
            </Tabs>
          )}
        </div>
      </div>
    </>
  );
}


// ====== [35] apps/client/src/pages/customer/CustomerDashboardPage.tsx ======
// File: /apps/client/src/pages/customer/CustomerDashboardPage.tsx (NUEVO ARCHIVO)

import { Title, Text, Paper } from '@mantine/core';
import { useEffect, useState } from 'react';

interface CustomerInfo {
  name?: string;
}

export function CustomerDashboardPage() {
  const [customer, setCustomer] = useState<CustomerInfo | null>(null);

  useEffect(() => {
    // Recuperamos la informaci√≥n del usuario del localStorage
    const customerInfoStr = localStorage.getItem('customerInfo');
    if (customerInfoStr) {
      setCustomer(JSON.parse(customerInfoStr));
    }
  }, []);

  return (
    <div>
      <Title order={2} mb="sm">
        Bienvenido de nuevo, {customer?.name || 'Cliente'}
      </Title>
      <Text c="dimmed" mb="xl">
        Desde aqu√≠ puedes gestionar tus citas y tu informaci√≥n personal.
      </Text>

      <Paper withBorder p="lg" shadow="sm">
        <Title order={4}>Resumen R√°pido</Title>
        <Text mt="sm">
          (Aqu√≠ ir√°n las pr√≥ximas citas y otras notificaciones importantes...)
        </Text>
      </Paper>
    </div>
  );
}


// ====== [36] apps/client/src/pages/public/BookingPage.tsx ======
// File: /apps/client/src/pages/public/BookingPage.tsx (ACTUALIZADO PARA RESERVA FLEXIBLE)

import { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { Container, Title, Paper, Stepper, Group, Button, TextInput, LoadingOverlay, Text, Alert, Select, Input, Checkbox, PasswordInput } from '@mantine/core';
import { useForm, zodResolver } from '@mantine/form';
import { z } from 'zod';
import { BookingDateTimePicker } from '../../components/booking/BookingDateTimePicker';
import apiClient from '../../lib/apiClient';

import { PhoneInput } from 'react-international-phone';
import 'react-international-phone/style.css';

// Esquema de validaci√≥n din√°mico
const createBookingSchema = (isCreatingAccount: boolean) => z.object({
  customerName: z.string().min(3, { message: 'El nombre debe tener al menos 3 caracteres.' }),
  customerEmail: z.string().email({ message: 'Introduce un email v√°lido.' }),
  customerPhone: z.string().min(10, { message: 'Introduce un n√∫mero de tel√©fono v√°lido.' }),
  createAccount: z.boolean(),
  password: isCreatingAccount
    ? z.string().min(8, { message: 'La contrase√±a debe tener al menos 8 caracteres.' })
    : z.string().optional(),
});


interface Employee { id: string; name: string; }
interface Settings { defaultService: { duration: number; id: string; }; }
interface CustomerInfo { id: string; name: string; email: string; }

export function BookingPage() {
  const navigate = useNavigate();
  const [activeStep, setActiveStep] = useState(0);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const [employees, setEmployees] = useState<{ value: string; label: string }[]>([]);
  const [selectedEmployeeId, setSelectedEmployeeId] = useState<string | null>('any');
  const [serviceInfo, setServiceInfo] = useState<{ duration: number; id: string } | null>(null);
  const [selectedDateTime, setSelectedDateTime] = useState<Date | null>(null);
  
  // --- NUEVA L√ìGICA ---
  const [loggedInCustomer, setLoggedInCustomer] = useState<CustomerInfo | null>(null);
  const [wantsToCreateAccount, setWantsToCreateAccount] = useState(false);
  
  const form = useForm({
    // Usamos una funci√≥n para que el schema se reeval√∫e cuando cambie el checkbox
    validate: zodResolver(createBookingSchema(wantsToCreateAccount)),
    initialValues: { customerName: '', customerEmail: '', customerPhone: '', createAccount: false, password: '' },
  });

  useEffect(() => {
    // Comprobar si hay un usuario logueado al cargar
    const customerInfoStr = localStorage.getItem('customerInfo');
    if (customerInfoStr) {
      const customer = JSON.parse(customerInfoStr);
      setLoggedInCustomer(customer);
      // Rellenar el formulario con sus datos
      form.setValues({ customerName: customer.name, customerEmail: customer.email });
    }
    
    const fetchInitialData = async () => {
      setError(null);
      try {
        const [employeesRes, settingsRes] = await Promise.all([
          apiClient.get<Employee[]>('/employees/public'),
          apiClient.get<{ settings: Settings }>('/admin/settings'),
        ]);
        const employeeOptions = employeesRes.data.map(emp => ({ value: emp.id, label: emp.name }));
        setEmployees([ { value: 'any', label: 'Cualquier Profesional' }, ...employeeOptions ]);
        if (settingsRes.data.settings.defaultService) {
          setServiceInfo(settingsRes.data.settings.defaultService);
        } else { throw new Error('No hay un servicio por defecto configurado.'); }
      } catch (err) {
        setError('No se pudo cargar la configuraci√≥n de la reserva.');
      } finally { setLoading(false); }
    };
    fetchInitialData();
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // Sincronizamos el estado del checkbox con el del formulario
  useEffect(() => {
    setWantsToCreateAccount(form.values.createAccount);
  }, [form.values.createAccount]);

  const handleDateTimeChange = (dateTime: Date | null) => {
    setSelectedDateTime(dateTime);
    if (dateTime) { setActiveStep(1); }
  };

  const handleBookingSubmit = async (values: typeof form.values) => {
    if (!serviceInfo?.id || !selectedDateTime) {
      setError('Faltan datos para completar la reserva.'); return;
    }
    setLoading(true); setError(null);
    try {
      const payload = {
        serviceId: serviceInfo.id,
        startTime: selectedDateTime.toISOString(),
        ...(selectedEmployeeId && selectedEmployeeId !== 'any' && { employeeId: selectedEmployeeId }),
        // --- L√ìGICA DE PAYLOAD MODIFICADA ---
        customerName: values.customerName,
        customerEmail: values.customerEmail,
        customerPhone: values.customerPhone,
        createAccount: values.createAccount,
        password: values.password,
      };
      
      // La API se encarga de si es invitado o nuevo usuario
      await apiClient.post('/bookings', payload);
      setActiveStep(2);
    } catch (err: any) {
      setError(err.response?.data?.message || 'No se pudo completar la reserva.');
    } finally { setLoading(false); }
  };

  if (error && activeStep < 2) {
    return (
      <Container size="sm" py="xl"><Alert title="Error Cr√≠tico" color="red">{error}</Alert></Container>
    );
  }

  return (
    <Container size="sm" py="xl">
      <Title order={2} ta="center" mb="xl">Realizar una Reserva</Title>
      <Stepper active={activeStep} onStepClick={setActiveStep}>
        <Stepper.Step label="Paso 1" description="Elige Profesional y Hora">
          <Paper withBorder shadow="md" p="xl" mt="xl" radius="md">
            <LoadingOverlay visible={loading && !serviceInfo} />
            <Select label="Elige un profesional" data={employees} value={selectedEmployeeId} onChange={setSelectedEmployeeId} mb="xl" />
            {serviceInfo && (
              <BookingDateTimePicker key={selectedEmployeeId} serviceDuration={serviceInfo.duration} onDateTimeChange={handleDateTimeChange} employeeId={selectedEmployeeId} />
            )}
          </Paper>
        </Stepper.Step>

        <Stepper.Step label="Paso 2" description="Tus Datos">
          <Paper withBorder shadow="md" p="xl" mt="xl" radius="md" component="form" onSubmit={form.onSubmit(handleBookingSubmit)}>
            <LoadingOverlay visible={loading && activeStep === 1} />
            <Title order={4} mb="lg">Completa tu informaci√≥n</Title>
            
            <TextInput label="Nombre Completo" {...form.getInputProps('customerName')} withAsterisk readOnly={!!loggedInCustomer} />
            <TextInput label="Email" type="email" {...form.getInputProps('customerEmail')} withAsterisk mt="md" readOnly={!!loggedInCustomer} />
            <Input.Wrapper label="Tel√©fono" withAsterisk mt="md" error={form.errors.customerPhone}>
              <PhoneInput defaultCountry="es" value={form.values.customerPhone} onChange={(phone) => form.setFieldValue('customerPhone', phone)} />
            </Input.Wrapper>
            
            {/* --- L√ìGICA CONDICIONAL A√ëADIDA --- */}
            {!loggedInCustomer && (
              <>
                <Checkbox label="Crear una cuenta para gestionar mis citas" {...form.getInputProps('createAccount', { type: 'checkbox' })} mt="lg" />
                {form.values.createAccount && (
                  <PasswordInput label="Crear Contrase√±a" placeholder="M√≠nimo 8 caracteres" {...form.getInputProps('password')} withAsterisk mt="md" />
                )}
              </>
            )}
            
            <Group justify="flex-end" mt="xl">
              <Button variant="default" onClick={() => setActiveStep(0)}>Volver</Button>
              <Button type="submit">Confirmar Reserva</Button>
            </Group>
          </Paper>
        </Stepper.Step>
        
        <Stepper.Step label="Paso 3" description="Confirmaci√≥n">
           <Paper withBorder shadow="md" p="xl" mt="xl" radius="md">
             <Title order={3} ta="center">¬°Reserva Confirmada!</Title>
             <Text ta="center" mt="md">Hemos enviado un email de confirmaci√≥n a <strong>{form.values.customerEmail}</strong>.</Text>
             <Text ta="center" mt="sm">Fecha de la cita: <strong>{selectedDateTime?.toLocaleString('es-ES')}</strong></Text>
             <Group justify="center" mt="xl"><Button onClick={() => navigate('/')}>Ir a Inicio</Button></Group>
           </Paper>
        </Stepper.Step>
      </Stepper>
    </Container>
  );
}


// ====== [37] apps/client/src/pages/public/HomePage.module.css ======
/* File: /apps/client/src/pages/public/HomePage.module.css (ACTUALIZADO) */

.hero {
  position: relative;
  /* APUNTAMOS A NUESTRA IMAGEN LOCAL */
  background-image: url('/hero-background.jpg');
  background-size: cover;
  background-position: center;
  padding-top: calc(var(--mantine-spacing-xl) * 4);
  padding-bottom: calc(var(--mantine-spacing-xl) * 4);
}

.overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.65);
  z-index: 1;
}

.heroContent {
  position: relative;
  z-index: 2;
  text-align: center;
}

.heroTitle {
  color: var(--mantine-color-white);
  font-size: 50px;
  font-weight: 900;
  line-height: 1.1;

  @media (max-width: 768px) {
    font-size: 40px;
    line-height: 1.2;
  }
}

.heroDescription {
  color: var(--mantine-color-white);
  max-width: 600px;
  margin-left: auto;
  margin-right: auto;
}

.heroButton {
  margin-top: calc(var(--mantine-spacing-xl) * 1.5);
}


// ====== [38] apps/client/src/pages/public/HomePage.tsx ======
// File: /apps/client/src/pages/public/HomePage.tsx (CON RESE√ëAS INTEGRADAS)

import { Title, Text, Button, Container, SimpleGrid, ThemeIcon, Stack, Divider } from '@mantine/core';
import { IconTruck, IconCertificate, IconCalendarStats } from '@tabler/icons-react';
import { useNavigate } from 'react-router-dom';
import classes from './HomePage.module.css';
// --- IMPORTACI√ìN A√ëADIDA ---
import { FeaturedReviews } from '../../components/home/FeaturedReviews';

function Feature({ icon: Icon, title, description }: { icon: React.ElementType, title: string, description: string }) {
  return (
    <Stack align="center" ta="center">
      <ThemeIcon variant="light" size={60} radius="md">
        <Icon size={30} />
      </ThemeIcon>
      <Text fw={700} fz="lg" mt="sm">{title}</Text>
      <Text c="dimmed" fz="sm">{description}</Text>
    </Stack>
  );
}

export function HomePage() {
  const navigate = useNavigate();

  return (
    <>
      <div className={classes.hero}>
        <div className={classes.overlay} />
        <Container className={classes.heroContent} size="lg">
          <Title className={classes.heroTitle}>La Excelencia en Cada Detalle</Title>
          <Text className={classes.heroDescription} c="white" size="xl" mt="xl">
            Tu veh√≠culo merece el mejor cuidado. Descubre nuestros servicios de detallado premium y devu√©lvele el brillo que se merece.
          </Text>
          <Button
            variant="gradient"
            gradient={{ from: 'blue', to: 'cyan' }}
            size="xl"
            radius="xl"
            className={classes.heroButton}
            onClick={() => navigate('/booking')}
          >
            Reservar Ahora
          </Button>
        </Container>
      </div>

      <Container py="xl" mt="xl">
        <Title order={2} ta="center" mb="xl">
          ¬øPor Qu√© Elegir AquaClean?
        </Title>
        <SimpleGrid cols={{ base: 1, md: 3 }} spacing="xl">
          <Feature
            icon={IconCertificate}
            title="Productos de Alta Calidad"
            description="Utilizamos solo los mejores productos del mercado, seguros para tu coche y para el medio ambiente."
          />
          <Feature
            icon={IconTruck}
            title="Atenci√≥n al Detalle"
            description="Nuestros t√©cnicos especializados tratan cada veh√≠culo como si fuera propio, garantizando un acabado impecable."
          />
          <Feature
            icon={IconCalendarStats}
            title="Reservas F√°ciles 24/7"
            description="Elige tu servicio y reserva tu cita en menos de 2 minutos con nuestro sistema de reservas online."
          />
        </SimpleGrid>
      </Container>
      
      {/* --- SECCI√ìN A√ëADIDA --- */}
      <Divider my="lg" />
      <FeaturedReviews />
      <Divider my="lg" />
      {/* --- FIN DE LA SECCI√ìN A√ëADIDA --- */}

      <Container py="xl" ta="center">
         <Title order={3}>¬øListo para que tu coche luzca como nuevo?</Title>
         <Text c="dimmed" mt="sm" mb="lg">
           No esperes m√°s. Encuentra el servicio perfecto y agenda tu cita hoy mismo.
         </Text>
         <Button size="lg" onClick={() => navigate('/booking')}>
           Reservar Mi Cita Ahora
         </Button>
      </Container>
    </>
  );
}


// ====== [39] apps/client/src/pages/public/LoginPage.tsx ======
// File: /apps/client/src/pages/public/LoginPage.tsx (CORREGIDO)

import { useForm, zodResolver } from '@mantine/form';
import { z } from 'zod';
import { useNavigate, Link } from 'react-router-dom';
import {
  Container,
  Title,
  Paper,
  TextInput,
  PasswordInput,
  Button,
  Text,
  LoadingOverlay,
  Stack,
  Anchor,
} from '@mantine/core';
import { notifications } from '@mantine/notifications';
import apiClient from '../../lib/apiClient';

// Esquema de validaci√≥n del formulario (debe coincidir con el del backend)
const loginSchema = z.object({
  email: z.string().email({ message: 'Introduce un email v√°lido.' }),
  password: z.string().min(1, { message: 'La contrase√±a no puede estar vac√≠a.' }),
});

export function LoginPage() {
  const navigate = useNavigate();

  const form = useForm({
    validate: zodResolver(loginSchema),
    initialValues: {
      email: '',
      password: '',
    },
  });

  const handleSubmit = async (values: typeof form.values) => {
    try {
      const response = await apiClient.post('/customer/login', values);
      
      localStorage.setItem('customerAuthToken', response.data.token);
      localStorage.setItem('customerInfo', JSON.stringify(response.data.user));

      notifications.show({
        title: `¬°Bienvenido de nuevo, ${response.data.user.name}!`,
        message: 'Has iniciado sesi√≥n correctamente.',
        color: 'green',
      });
      
      navigate('/dashboard');

    } catch (err: any) {
      const errorMessage = err.response?.data?.message || 'Ha ocurrido un error inesperado.';
      notifications.show({
        title: 'Error al iniciar sesi√≥n',
        message: errorMessage,
        color: 'red',
      });
    }
  };

  return (
    <Container size={420} my={40}>
      <Title ta="center">Accede a tu Cuenta</Title>
      <Text c="dimmed" size="sm" ta="center" mt={5}>
        ¬øA√∫n no tienes una?{' '}
        <Anchor component={Link} to="/register" size="sm">
          Crea una cuenta aqu√≠
        </Anchor>
      </Text>

      <Paper withBorder shadow="md" p={30} mt={30} radius="md" component="form" onSubmit={form.onSubmit(handleSubmit)}>
        {/* --- L√çNEA CORREGIDA --- */}
        <LoadingOverlay visible={form.submitting} zIndex={1000} overlayProps={{ radius: 'sm', blur: 2 }} />
        <Stack gap="md">
          <TextInput
            label="Email"
            placeholder="tu@email.com"
            required
            {...form.getInputProps('email')}
          />
          <PasswordInput
            label="Contrase√±a"
            placeholder="Tu contrase√±a"
            required
            {...form.getInputProps('password')}
          />
          <Button fullWidth mt="xl" type="submit">
            Iniciar Sesi√≥n
          </Button>
        </Stack>
      </Paper>
    </Container>
  );
}


// ====== [40] apps/client/src/pages/public/RegisterPage.tsx ======
// File: /apps/client/src/pages/public/RegisterPage.tsx (VERSI√ìN COMPLETA)

import { useForm, zodResolver } from '@mantine/form';
import { z } from 'zod';
import { useNavigate, Link } from 'react-router-dom';
import {
  Container,
  Title,
  Paper,
  TextInput,
  PasswordInput,
  Button,
  Text,
  LoadingOverlay,
  Stack,
  Anchor,
} from '@mantine/core';
import { notifications } from '@mantine/notifications';
import apiClient from '../../lib/apiClient';

// Esquema de validaci√≥n para el formulario de registro
const registerSchema = z.object({
    name: z.string().min(3, { message: 'El nombre debe tener al menos 3 caracteres.' }),
    email: z.string().email({ message: 'Introduce un email v√°lido.' }),
    password: z.string().min(8, { message: 'La contrase√±a debe tener al menos 8 caracteres.' }),
    confirmPassword: z.string(),
  }).refine((data) => data.password === data.confirmPassword, {
    message: 'Las contrase√±as no coinciden.',
    path: ['confirmPassword'], // Indica qu√© campo mostrar√° el error
  });


export function RegisterPage() {
  const navigate = useNavigate();

  const form = useForm({
    validate: zodResolver(registerSchema),
    initialValues: {
      name: '',
      email: '',
      password: '',
      confirmPassword: '',
    },
  });

  const handleSubmit = async (values: typeof form.values) => {
    try {
      // No enviamos confirmPassword a la API
      const { confirmPassword, ...payload } = values;
      const response = await apiClient.post('/customer/register', payload);

      // El backend ya nos devuelve el token, as√≠ que iniciamos sesi√≥n directamente
      localStorage.setItem('customerAuthToken', response.data.token);
      localStorage.setItem('customerInfo', JSON.stringify(response.data.user));

      notifications.show({
        title: `¬°Bienvenido, ${response.data.user.name}!`,
        message: 'Tu cuenta ha sido creada con √©xito.',
        color: 'green',
      });

      // Redirigimos al panel de cliente
      navigate('/dashboard');

    } catch (err: any) {
      const errorMessage = err.response?.data?.message || 'Ha ocurrido un error inesperado.';
      notifications.show({
        title: 'Error en el registro',
        message: errorMessage,
        color: 'red',
      });
    }
  };

  return (
    <Container size={420} my={40}>
      <Title ta="center">Crea tu Cuenta</Title>
      <Text c="dimmed" size="sm" ta="center" mt={5}>
        ¬øYa tienes una?{' '}
        <Anchor component={Link} to="/login" size="sm">
          Inicia sesi√≥n aqu√≠
        </Anchor>
      </Text>

      <Paper withBorder shadow="md" p={30} mt={30} radius="md" component="form" onSubmit={form.onSubmit(handleSubmit)}>
        <LoadingOverlay visible={form.submitting} zIndex={1000} overlayProps={{ radius: 'sm', blur: 2 }} />
        <Stack gap="md">
          <TextInput
            label="Nombre Completo"
            placeholder="Tu nombre y apellido"
            required
            {...form.getInputProps('name')}
          />
          <TextInput
            label="Email"
            placeholder="tu@email.com"
            required
            {...form.getInputProps('email')}
          />
          <PasswordInput
            label="Contrase√±a"
            placeholder="M√≠nimo 8 caracteres"
            required
            {...form.getInputProps('password')}
          />
          <PasswordInput
            label="Confirmar Contrase√±a"
            placeholder="Repite la contrase√±a"
            required
            {...form.getInputProps('confirmPassword')}
          />
          <Button fullWidth mt="xl" type="submit">
            Crear Cuenta
          </Button>
        </Stack>
      </Paper>
    </Container>
  );
}


// ====== [41] apps/client/src/pages/public/ReviewPage.tsx ======
// File: /apps/client/src/pages/public/ReviewPage.tsx (CON LLAMADA A API REAL)

import { useSearchParams } from 'react-router-dom';
import { useForm, zodResolver } from '@mantine/form';
import { z } from 'zod';
import { Container, Title, Text, Paper, Rating, Textarea, Button, Stack, Group, Alert } from '@mantine/core';
import { notifications } from '@mantine/notifications';
import { IconAlertCircle } from '@tabler/icons-react';
import { useState } from 'react';
import apiClient from '../../lib/apiClient';

const reviewSchema = z.object({
  rating: z.number().min(1, { message: 'Por favor, selecciona al menos una estrella.' }),
  comment: z.string().optional(),
});

export function ReviewPage() {
  const [searchParams] = useSearchParams();
  const token = searchParams.get('token');
  
  const [submissionStatus, setSubmissionStatus] = useState<'idle' | 'success' | 'error'>('idle');

  const form = useForm({
    validate: zodResolver(reviewSchema),
    initialValues: {
      rating: 0,
      comment: '',
    },
  });

  const handleSubmit = async (values: typeof form.values) => {
    try {
      // --- C√ìDIGO ACTUALIZADO: AHORA SE HACE LA LLAMADA REAL A LA API ---
      await apiClient.post('/reviews', { ...values, token });
      
      notifications.show({
        title: '¬°Gracias por tu valoraci√≥n!',
        message: 'Tu opini√≥n nos ayuda a mejorar cada d√≠a.',
        color: 'green',
      });
      setSubmissionStatus('success');
    } catch (err: any) {
      notifications.show({
        title: 'Error al enviar la valoraci√≥n',
        message: err.response?.data?.message || 'Ha ocurrido un error. Int√©ntalo de nuevo.',
        color: 'red',
      });
      setSubmissionStatus('error');
    }
  };

  if (!token) {
    return (
      <Container size="sm" my={40}>
        <Alert icon={<IconAlertCircle size="1rem" />} title="Enlace no v√°lido" color="red">
          El enlace para dejar la valoraci√≥n parece ser incorrecto o ha expirado.
        </Alert>
      </Container>
    );
  }
  
  if (submissionStatus === 'success') {
    return (
      <Container size="sm" my={40}>
         <Paper withBorder shadow="md" p={30} radius="md" ta="center">
            <Title order={3}>¬°Valoraci√≥n enviada!</Title>
            <Text mt="md">Muchas gracias por tu tiempo. Tu feedback es muy valioso para nosotros.</Text>
         </Paper>
      </Container>
    );
  }

  return (
    <Container size="sm" my={40}>
      <Title ta="center">Valora tu experiencia</Title>
      <Text c="dimmed" size="sm" ta="center" mt={5}>
        Tu opini√≥n es muy importante para nosotros.
      </Text>

      <Paper withBorder shadow="md" p={30} mt={30} radius="md" component="form" onSubmit={form.onSubmit(handleSubmit)}>
        <Stack>
          <Group justify="center">
             <Rating size="xl" {...form.getInputProps('rating')} />
          </Group>
          {form.errors.rating && <Text c="red" size="xs" ta="center">{form.errors.rating}</Text>}

          <Textarea
            label="Tu comentario (opcional)"
            placeholder="¬øQu√© te ha parecido el servicio? ¬øHay algo que podamos mejorar?"
            autosize
            minRows={4}
            {...form.getInputProps('comment')}
          />
          <Button type="submit" mt="md" loading={form.submitting}>
            Enviar mi valoraci√≥n
          </Button>
        </Stack>
      </Paper>
    </Container>
  );
}


// ====== [42] apps/client/src/pages/public/ServicesPage.tsx ======
// File: /apps/client/src/pages/public/ServicesPage.tsx (ACTUALIZADO)

import { useEffect, useState } from 'react';
import { useNavigate } from 'react-router-dom'; // <-- L√çNEA A√ëADIDA
import {
  Container,
  Title,
  Text,
  Card,
  Button,
  SimpleGrid,
  Group,
  Badge,
} from '@mantine/core';
import apiClient from '../../lib/apiClient';
import type { Service } from '@aquaclean/types';

export function ServicesPage() {
  const [services, setServices] = useState<Service[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const navigate = useNavigate(); // <-- L√çNEA A√ëADIDA

  useEffect(() => {
    const fetchServices = async () => {
      try {
        setLoading(true);
        const response = await apiClient.get<Service[]>('/services');
        setServices(response.data);
      } catch (err) {
        setError('No se pudieron cargar los servicios. Por favor, int√©ntalo m√°s tarde.');
        console.error(err);
      } finally {
        setLoading(false);
      }
    };

    fetchServices();
  }, []);

  // --- FUNCI√ìN A√ëADIDA ---
  // Esta funci√≥n se ejecutar√° cuando el cliente haga clic en "Reservar Ahora".
  // Navegar√° a la p√°gina de booking, pasando los datos del servicio en la URL.
  const handleReserveClick = (service: Service) => {
    navigate(`/booking?serviceId=${service.id}&duration=${service.duration}`);
  };
  // --- FIN DE LA FUNCI√ìN A√ëADIDA ---

  if (loading) {
    return <Container><Text>Cargando servicios...</Text></Container>;
  }

  if (error) {
    return <Container><Text c="red">{error}</Text></Container>;
  }

  return (
    <Container py="xl">
      <Title order={2} ta="center" mb="lg">
        Nuestros Servicios
      </Title>
      <Text ta="center" c="dimmed" mb="xl">
        Elige el tratamiento perfecto para tu veh√≠culo. Ofrecemos desde lavados r√°pidos hasta detallados completos con la m√°xima calidad.
      </Text>

      <SimpleGrid cols={{ base: 1, sm: 2, lg: 3 }} spacing="lg">
        {services.map((service) => (
          <Card shadow="sm" padding="lg" radius="md" withBorder key={service.id}>
            <Group justify="space-between" mt="md" mb="xs">
              <Text fw={500}>{service.name}</Text>
              <Badge color="pink">{service.category}</Badge>
            </Group>

            <Text size="sm" c="dimmed" style={{ minHeight: 60 }}>
              {service.description.substring(0, 100)}...
            </Text>
            
            <Text size="sm" c="dimmed" mt="sm">
              Duraci√≥n estimada: {service.duration} min.
            </Text>

            {/* --- L√çNEA MODIFICADA --- */}
            <Button
              color="blue"
              fullWidth
              mt="md"
              radius="md"
              onClick={() => handleReserveClick(service)} // <-- Se a√±ade el evento onClick
            >
              Reservar Ahora
            </Button>
            {/* --- FIN DE LA MODIFICACI√ìN --- */}
          </Card>
        ))}
      </SimpleGrid>
    </Container>
  );
}


// ====== [43] apps/client/src/pages/public/TeamPage.tsx ======
// File: /apps/client/src/pages/public/TeamPage.tsx (NUEVO ARCHIVO)

import { useEffect, useState } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Container,
  Title,
  Text,
  SimpleGrid,
  Card,
  Avatar,
  Button,
  Loader,
  Center,
  Alert,
} from '@mantine/core';
import { IconAlertCircle } from '@tabler/icons-react';
import apiClient from '../../lib/apiClient';

// Definimos un tipo local para los datos que esperamos de la API.
// Esto nos da autocompletado y seguridad de tipos.
interface TeamMember {
  id: string;
  name: string;
  role: 'ADMIN' | 'EMPLOYEE';
  bio?: string;
  imageUrl?: string;
}

export function TeamPage() {
  const [team, setTeam] = useState<TeamMember[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const navigate = useNavigate();

  useEffect(() => {
    const fetchTeam = async () => {
      try {
        const response = await apiClient.get<TeamMember[]>('/employees');
        // Por ahora, mostramos a todos. En el futuro, podr√≠amos filtrar por rol.
        setTeam(response.data);
      } catch (err) {
        console.error('Error fetching team members:', err);
        setError('No se pudo cargar la informaci√≥n del equipo. Por favor, int√©ntalo de nuevo m√°s tarde.');
      } finally {
        setLoading(false);
      }
    };
    fetchTeam();
  }, []);

  if (loading) {
    return <Center style={{ height: 300 }}><Loader /></Center>;
  }

  if (error) {
    return (
      <Alert icon={<IconAlertCircle size="1rem" />} title="Error" color="red">
        {error}
      </Alert>
    );
  }

  return (
    <Container py="xl">
      <Title order={2} ta="center">
        Conoce a Nuestro Equipo
      </Title>
      <Text c="dimmed" ta="center" mt="sm" mb="xl">
        Profesionales apasionados por el cuidado de tu veh√≠culo, listos para ofrecerte el mejor servicio.
      </Text>

      <SimpleGrid cols={{ base: 1, sm: 2, lg: 3 }} spacing="lg">
        {team.map((member) => (
          <Card key={member.id} shadow="sm" padding="lg" radius="md" withBorder>
            <Center>
              <Avatar src={member.imageUrl} size={120} radius="xl" alt={member.name} />
            </Center>
            <Text ta="center" fw={500} fz="lg" mt="md">
              {member.name}
            </Text>
            <Text ta="center" c="dimmed" fz="sm">
              {member.role === 'ADMIN' ? 'Gerente de Operaciones' : 'Especialista en Detallado'}
            </Text>
            <Text ta="center" fz="sm" mt="sm" style={{ minHeight: 60 }}>
              {member.bio || 'Comprometido con la excelencia y la satisfacci√≥n del cliente.'}
            </Text>
            <Button
              variant="light"
              fullWidth
              mt="md"
              radius="md"
              onClick={() => navigate('/services')}
            >
              Ver Servicios
            </Button>
          </Card>
        ))}
      </SimpleGrid>
    </Container>
  );
}


// ====== [44] apps/client/tsconfig.json ======
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "lib": ["DOM", "DOM.Iterable", "ESNext"],
    "plugins": [{ "name": "typescript-plugin-css-modules" }]
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}



// ====== [45] apps/client/tsconfig.node.json ======
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "composite": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "noEmit": false
  },
  "include": ["vite.config.ts"]
}


// ====== [46] apps/server/.env ======
# File: /apps/server/.env - v1.0

# --- Base de Datos y Servidor ---
DATABASE_URL="postgresql://postgres:Matrix2010%40@localhost:5432/aquaclean_db?schema=public"
PORT=3001

# --- Autenticaci√≥n ---
JWT_SECRET="temporal-secret-dev-12345!"
JWT_EXPIRES_IN="604800s" # (s for seconds)

# --- Servicios Externos (Cloudinary) ---
CLOUDINARY_CLOUD_NAME="dbrniwsql"
CLOUDINARY_API_KEY="369383982123395"
CLOUDINARY_API_SECRET="rSOm48XmeYC5FQt27D6k5sppguc"

# --- CORS ---
CORS_ALLOWED_ORIGIN="http://localhost:5173"

# --- Configuraci√≥n de Email (Nodemailer) ---
EMAIL_HOST="smtp.privateemail.com"
EMAIL_PORT="465"
EMAIL_USER="info@ohcodex.com"
EMAIL_PASS="Matrix2010@"
EMAIL_FROM="AquaClean Notificaciones <info@ohcodex.com>"
EMAIL_TO="info@ohcodex.com"


// ====== [47] apps/server/package.json ======
{
  "name": "server",
  "version": "1.0.0",
  "private": true,
  "main": "dist/server.js",
  "scripts": {
    "dev": "ts-node-dev --respawn --transpile-only --exit-child src/server.ts",
    "build": "tsc",
    "start": "node dist/server.js",
    "lint": "eslint . --ext .ts",
    "migrate:dev": "prisma migrate dev --schema=./prisma/schema.prisma",
    "migrate:deploy": "prisma migrate deploy --schema=./prisma/schema.prisma",
    "prisma:generate": "prisma generate --schema=./prisma/schema.prisma",
    "prisma:studio": "prisma studio --schema=./prisma/schema.prisma",
    "prisma:seed": "ts-node prisma/seed.ts"
  },
  "dependencies": {
    "@prisma/client": "^5.14.0",
    "bcryptjs": "^2.4.3",
    "cors": "^2.8.5",
    "dayjs": "^1.11.11",
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "jsonwebtoken": "^9.0.2",
    "node-cron": "^3.0.3",
    "nodemailer": "^6.10.1",
    "twilio": "^5.2.2",
    "zod": ">=3.0.0"
  },
  "devDependencies": {
    "@aquaclean/config": "workspace:*",
    "@aquaclean/types": "workspace:*",
    "@types/bcryptjs": "^2.4.6",
    "@types/cors": "^2.8.17",
    "@types/express": "^4.17.21",
    "@types/jsonwebtoken": "^9.0.10",
    "@types/node": "^20.12.12",
    "@types/node-cron": "^3.0.11",
    "@types/nodemailer": "^6.4.20",
    "eslint": "^8.57.0",
    "prisma": "^5.14.0",
    "ts-node": "^10.9.2",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.4.5"
  }
}


// ====== [48] apps/server/prisma/schema.prisma ======
// File: /apps/server/prisma/schema.prisma (ACTUALIZADO PARA ECOSISTEMA DE CLIENTE)

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// 2. Modelos de Autenticaci√≥n y Usuarios
model User {
  id              String          @id @default(cuid())
  name            String?
  email           String          @unique
  emailVerified   DateTime?
  passwordHash    String?
  image           String?
  role            UserRole        @default(CUSTOMER)
  stripeCustomerId String?        @unique

  accounts        Account[]
  sessions        Session[]
  appointments    Appointment[]
  reviews         Review[]
  vehicles        Vehicle[]
  purchasedBonuses PurchasedBonus[]
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime
  @@unique([identifier, token])
}

// 3. Modelos del Core del Negocio
model Service {
  id          String   @id @default(cuid())
  name        String
  description String   @db.Text
  duration    Int
  prices      Json
  category    String
  isAddon     Boolean  @default(false)
  isGiftable  Boolean  @default(false)
  isFeatured  Boolean  @default(false)
  isActive    Boolean  @default(true)

  appointments    AppointmentService[]
  bonusOfferings  BonusOffering[]
  giftCards       GiftCard[]

  businessSettings BusinessSettings?
}

model Employee {
  id           String @id @default(cuid())
  name         String
  email        String @unique
  role         UserRole @default(EMPLOYEE)
  bio          String? @db.Text
  imageUrl     String?
  status       EmployeeStatus @default(ACTIVE)
  color        String?  @default("#868e96")
  
  workSchedule Json?
  absences     Absence[]

  appointments Appointment[]
  reviews      Review[]
}

model Absence {
  id         String   @id @default(cuid())
  startDate  DateTime
  endDate    DateTime
  reason     String?
  
  employee   Employee @relation(fields: [employeeId], references: [id])
  employeeId String
}

// 4. Modelos Operacionales
model Appointment {
  id            String   @id @default(cuid())
  startTime     DateTime
  endTime       DateTime
  notes         String?
  status        AppointmentStatus @default(AVAILABLE)
  paymentIntentId String?  @unique
  googleEventId   String?  @unique
  reminderSent  Boolean  @default(false)

  // --- CAMPOS MODIFICADOS/A√ëADIDOS ---
  // Relaci√≥n opcional con el usuario (para clientes registrados)
  user          User?    @relation(fields: [userId], references: [id])
  userId        String?
  // Campos para reservas de invitados
  guestName     String?
  guestEmail    String?
  guestPhone    String?
  // --- FIN DE LA MODIFICACI√ìN ---
  
  employee      Employee @relation(fields: [employeeId], references: [id])
  employeeId    String

  services      AppointmentService[]
  review        Review? // Una cita puede tener una rese√±a
}

model AppointmentService {
  appointment   Appointment @relation(fields: [appointmentId], references: [id])
  appointmentId String
  service       Service     @relation(fields: [serviceId], references: [id])
  serviceId     String
  @@id([appointmentId, serviceId])
}

// --- NUEVO MODELO A√ëADIDO ---
model Review {
  id            String      @id @default(cuid())
  rating        Int
  comment       String?     @db.Text
  status        ReviewStatus @default(PENDING)
  isFeatured    Boolean     @default(false)
  createdAt     DateTime    @default(now())
  
  // Relaciones
  appointment   Appointment @relation(fields: [appointmentId], references: [id])
  appointmentId String      @unique // Cada cita solo puede tener una rese√±a

  user          User?        @relation(fields: [userId], references: [id])
  userId        String?      // Opcional, por si es la rese√±a de un invitado

  employee      Employee    @relation(fields: [employeeId], references: [id])
  employeeId    String
}
// --- FIN DEL NUEVO MODELO ---


// 5. Modelos de Cliente y Marketing
model Vehicle {
  id          String @id @default(cuid())
  alias       String
  brand       String
  model       String
  plate       String?
  size        String
  user        User   @relation(fields: [userId], references: [id])
  userId      String
}

model BonusOffering {
  id          String   @id @default(cuid())
  name        String
  price       Float
  uses        Int
  validityDays Int?
  isActive    Boolean  @default(true)
  service     Service  @relation(fields: [serviceId], references: [id])
  serviceId   String
  purchases   PurchasedBonus[]
}

model PurchasedBonus {
  id              String   @id @default(cuid())
  usesRemaining   Int
  expiresAt       DateTime?
  user            User     @relation(fields: [userId], references: [id])
  userId          String
  bonusOffering   BonusOffering @relation(fields: [bonusOfferingId], references: [id])
  bonusOfferingId String
}

model GiftCard {
  id            String    @id @default(cuid())
  code          String    @unique
  isRedeemed    Boolean   @default(false)
  redeemedAt    DateTime?
  recipientEmail String?
  message       String?   @db.Text
  service       Service   @relation(fields: [serviceId], references: [id])
  serviceId     String
}

// 6. Modelo de Configuraci√≥n del Negocio
model BusinessSettings {
  id              String    @id @default(cuid())
  weeklySchedule  Json
  singleton       String    @unique @default("SINGLETON")

  defaultService   Service? @relation(fields: [defaultServiceId], references: [id])
  defaultServiceId String?  @unique

  emailHost       String?
  emailPort       String?
  emailUser       String?
  emailPass       String?
  emailFrom       String?
  twilioSid       String?
  twilioAuthToken String?
  twilioPhoneNumber String?
}

model DateOverride {
  id        String   @id @default(cuid())
  date      DateTime
  reason    String?
  openTime  String?
  closeTime String?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 7. Enums
enum UserRole {
  ADMIN
  EMPLOYEE
  CUSTOMER
}

enum AppointmentStatus {
  AVAILABLE
  CONFIRMED
  COMPLETED
  CANCELLED
  NO_SHOW // <-- VALOR A√ëADIDO
}

// --- NUEVO ENUM A√ëADIDO ---
enum ReviewStatus {
  PENDING
  APPROVED
  HIDDEN
}
// --- FIN DEL NUEVO ENUM ---

enum EmployeeStatus {
  ACTIVE
  ARCHIVED
}


// ====== [49] apps/server/prisma/seed.ts ======
// File: /apps/server/prisma/seed.ts (ACTUALIZADO PARA INCLUIR RESERVAS DE INVITADO)

import { PrismaClient, UserRole, EmployeeStatus, AppointmentStatus } from '@prisma/client';
import { hash } from 'bcryptjs';
import dayjs from 'dayjs';
import utc from 'dayjs/plugin/utc';
import isSameOrBefore from 'dayjs/plugin/isSameOrBefore';
import 'dayjs/locale/en';

dayjs.extend(utc);
dayjs.extend(isSameOrBefore);

const prisma = new PrismaClient();

async function main() {
  console.log('Starting database seed...');

  // Limpieza
  console.log('Cleaning up old data...');
  await prisma.review.deleteMany({}); // Limpiar nuevas tablas
  await prisma.businessSettings.updateMany({ data: { defaultServiceId: null } });
  await prisma.appointmentService.deleteMany({});
  await prisma.absence.deleteMany({});
  await prisma.dateOverride.deleteMany({});
  await prisma.appointment.deleteMany({});
  await prisma.employee.deleteMany({});
  await prisma.user.deleteMany({ where: { role: 'CUSTOMER' } });
  await prisma.service.deleteMany({});
  console.log('Cleanup complete.');

  // Admin
  await prisma.user.upsert({
    where: { email: 'admin@aquaclean.com' },
    update: {},
    create: {
      email: 'admin@aquaclean.com', name: 'Admin User',
      passwordHash: await hash('password123', 12),
      role: UserRole.ADMIN, emailVerified: new Date(),
    },
  });
  console.log(`‚úÖ Admin user seeded.`);
  
  // Servicio
  const defaultService = await prisma.service.create({
    data: {
      name: 'Servicio Completo de Detallado', duration: 75,
      description: 'El √∫nico servicio que lo tiene todo.',
      prices: { standard: 60, suv: 75 }, category: 'Completo', isActive: true,
    },
  });
  console.log(`‚úÖ Seeded 1 default service.`);

  // Ajustes
  await prisma.businessSettings.upsert({
    where: { singleton: 'SINGLETON' },
    update: { defaultServiceId: defaultService.id },
    create: {
      singleton: 'SINGLETON', defaultServiceId: defaultService.id,
      weeklySchedule: {
        monday: { open: '09:00', close: '19:00' }, tuesday: { open: '09:00', close: '19:00' },
        wednesday: { open: '09:00', close: '19:00' }, thursday: { open: '09:00', close: '19:00' },
        friday: { open: '09:00', close: '19:00' }, saturday: { open: '10:00', close: '14:00' },
        sunday: null,
      },
    },
  });
  console.log('‚úÖ Business settings created/updated.');

  // Empleados
  console.log('Seeding employees...');
  const standardWorkSchedule = {
    monday: [{ start: '09:00', end: '14:00' }, { start: '15:00', end: '19:00' }],
    tuesday: [{ start: '09:00', end: '14:00' }, { start: '15:00', end: '19:00' }],
    wednesday: [{ start: '09:00', end: '14:00' }, { start: '15:00', end: '19:00' }],
    thursday: [{ start: '09:00', end: '14:00' }, { start: '15:00', end: '19:00' }],
    friday: [{ start: '09:00', end: '14:00' }, { start: '15:00', end: '19:00' }],
    saturday: [{ start: '10:00', end: '14:00' }],
  };
  
  const employeesToCreate = [
    { email: 'juan@aquaclean.com', name: 'Juan Empleado', role: UserRole.EMPLOYEE, status: EmployeeStatus.ACTIVE, workSchedule: standardWorkSchedule, color: '#228be6' },
    { email: 'maria@aquaclean.com', name: 'Maria Recepcionista', role: UserRole.EMPLOYEE, status: EmployeeStatus.ACTIVE, workSchedule: standardWorkSchedule, color: '#e64980' },
    { email: 'carlos@aquaclean.com', name: 'Carlos Detallista', role: UserRole.EMPLOYEE, status: EmployeeStatus.ACTIVE, workSchedule: standardWorkSchedule, color: '#b84712' },
  ];

  for (const employeeData of employeesToCreate) {
    await prisma.employee.create({ data: employeeData });
  }
  console.log(`‚úÖ Seeded ${employeesToCreate.length} employees with colors.`);

  // Generador de Citas
  console.log('Generating appointment inventory...');
  const employees = await prisma.employee.findMany();
  const serviceDuration = defaultService.duration;
  let appointmentsToCreate = [];

  for (const employee of employees) {
    for (let dayOffset = 0; dayOffset < 14; dayOffset++) {
      const currentDay = dayjs().add(dayOffset, 'day').startOf('day');
      const dayOfWeek = currentDay.locale('en').format('dddd').toLowerCase();
      const daySchedule = (employee.workSchedule as any)?.[dayOfWeek];

      if (daySchedule && daySchedule.length > 0) {
        for (const shift of daySchedule) {
          const [startHour, startMinute] = shift.start.split(':').map(Number);
          const [endHour, endMinute] = shift.end.split(':').map(Number);
          const shiftStart = currentDay.hour(startHour).minute(startMinute);
          const shiftEnd = currentDay.hour(endHour).minute(endMinute);
          let currentSlotStart = shiftStart;

          while (true) {
            const currentSlotEnd = currentSlotStart.add(serviceDuration, 'minutes');
            if (currentSlotEnd.isAfter(shiftEnd)) break; 
            appointmentsToCreate.push({
              startTime: currentSlotStart.toDate(),
              endTime: currentSlotEnd.toDate(),
              employeeId: employee.id,
              status: AppointmentStatus.AVAILABLE,
            });
            currentSlotStart = currentSlotStart.add(serviceDuration, 'minutes');
          }
        }
      }
    }
  }

  console.log(`\n‚úÖ Total slots generated before saving: ${appointmentsToCreate.length}`);
  await prisma.appointment.createMany({ data: appointmentsToCreate });

  const createdAppointments = await prisma.appointment.findMany({ where: { status: AppointmentStatus.AVAILABLE } });
  for (const appt of createdAppointments) {
      await prisma.appointmentService.create({
          data: { appointmentId: appt.id, serviceId: defaultService.id }
      });
  }
  console.log(`‚úÖ Generated ${createdAppointments.length} available appointment slots in DB.`);

  console.log('Converting a portion of appointments to CONFIRMED for demo purposes...');
  let confirmedCount = 0;
  let guestCount = 0;

  for (const appt of createdAppointments) {
    if (Math.random() < 0.6) { // Afecta al 60% de las citas disponibles
      
      // --- L√ìGICA MODIFICADA ---
      // Aleatoriamente, creamos una reserva de invitado o una de usuario registrado
      if (Math.random() < 0.5) { // 50% de las confirmadas ser√°n de invitados
        await prisma.appointment.update({
          where: { id: appt.id },
          data: {
            status: AppointmentStatus.CONFIRMED,
            guestName: `Invitado ${dayjs(appt.startTime).format('HH:mm')}`,
            guestEmail: `guest.${dayjs(appt.startTime).unix()}@example.com`,
            guestPhone: '600123123',
          },
        });
        guestCount++;
      } else { // El otro 50% ser√°n de usuarios registrados
        const customerEmail = `customer.${dayjs(appt.startTime).unix()}@example.com`;
        const customer = await prisma.user.upsert({
          where: { email: customerEmail },
          update: {},
          create: {
            email: customerEmail,
            name: `Cliente ${dayjs(appt.startTime).format('HH:mm')}`,
            role: UserRole.CUSTOMER,
          },
        });
        await prisma.appointment.update({
          where: { id: appt.id },
          data: { status: AppointmentStatus.CONFIRMED, userId: customer.id },
        });
        confirmedCount++;
      }
      // --- FIN DE LA MODIFICACI√ìN ---
    }
  }
  console.log(`‚úÖ Converted ${confirmedCount} appointments to CONFIRMED for registered users.`);
  console.log(`‚úÖ Converted ${guestCount} appointments to CONFIRMED for guests.`);
  console.log('Database seed finished successfully.');
}

main()
  .catch((e) => {
    console.error('An error occurred during seeding:', e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });


// ====== [50] apps/server/src/api/adminAppointments.routes.ts ======
// File: /apps/server/src/api/adminAppointments.routes.ts (PASANDO N√öMERO DE TEL√âFONO)

import { Router } from 'express';
import { z, ZodError } from 'zod';
import dayjs from 'dayjs';
import prisma from '../lib/prisma';
import { Prisma, AppointmentStatus } from '@prisma/client';
import { notificationService } from '../lib/notificationService';

const router = Router();

const createAppointmentAdminSchema = z.object({
  customerName: z.string().min(1), customerEmail: z.string().email(),
  serviceId: z.string().cuid(), employeeId: z.string().cuid(),
  startTime: z.coerce.date(),
});

const updateAppointmentAdminSchema = createAppointmentAdminSchema.partial().extend({
  status: z.nativeEnum(AppointmentStatus).optional(),
});

const updateAppointmentDndSchema = z.object({ start: z.coerce.date(), end: z.coerce.date() });


router.get('/', async (req, res) => {
  try {
    const appointments = await prisma.appointment.findMany({
      include: {
        user: { select: { name: true, email: true } },
        services: { include: { service: { select: { id: true, name: true } } } },
        employee: { select: { color: true } },
      },
    });

    const events = appointments.map((appointment) => {
      const service = appointment.services[0]?.service;
      const customerName = appointment.user?.name || (appointment.guestName as string | undefined);
      const customerEmail = appointment.user?.email || (appointment.guestEmail as string | undefined);
      const isAvailable = appointment.status === AppointmentStatus.AVAILABLE;
      const title = isAvailable ? 'Disponible' : `${service?.name || 'Servicio'} - ${customerName || 'Cliente'}`;
      const color = isAvailable ? '#40c057' : (appointment.employee?.color || '#868e96');
      return {
        id: appointment.id, title, start: appointment.startTime, end: appointment.endTime,
        resourceId: appointment.employeeId, backgroundColor: color, borderColor: color,
        extendedProps: {
          appointmentId: appointment.id, customerName, customerEmail,
          serviceId: service?.id, employeeId: appointment.employeeId,
          start: appointment.startTime, status: appointment.status,
        }
      };
    });
    res.status(200).json(events);
  } catch (error) { 
    console.error('Error fetching admin appointments:', error);
    res.status(500).json({ message: 'Error interno del servidor.' }); 
  }
});

router.post('/', async (req, res) => {
  try {
    const validatedData = createAppointmentAdminSchema.parse(req.body);
    const service = await prisma.service.findUnique({ where: { id: validatedData.serviceId } });
    if (!service) return res.status(404).json({ message: 'Servicio no encontrado.' });
    const availableSlot = await prisma.appointment.findFirst({
        where: { startTime: validatedData.startTime, employeeId: validatedData.employeeId, status: AppointmentStatus.AVAILABLE }
    });
    if (!availableSlot) return res.status(409).json({ message: 'El hueco ya no est√° disponible.' });
    const customer = await prisma.user.upsert({
        where: { email: validatedData.customerEmail },
        update: { name: validatedData.customerName },
        create: { email: validatedData.customerEmail, name: validatedData.customerName, role: 'CUSTOMER' },
    });
    const updatedAppointment = await prisma.appointment.update({
        where: { id: availableSlot.id },
        data: { status: AppointmentStatus.CONFIRMED, userId: customer.id }
    });
    res.status(201).json(updatedAppointment);
  } catch (error) {
    if (error instanceof ZodError) return res.status(400).json({ errors: error.issues });
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});


router.put('/:id', async (req, res) => {
  try {
    const { id } = req.params;
    
    const appointmentBeforeUpdate = await prisma.appointment.findUnique({ 
        where: { id },
        include: { user: true } // Incluimos el user para tener acceso a su tel√©fono
    });

    if (!appointmentBeforeUpdate) {
      return res.status(404).json({ message: 'La cita no fue encontrada.' });
    }

    if (req.body.start && req.body.end) {
      const { start, end } = updateAppointmentDndSchema.parse(req.body);
      const updated = await prisma.appointment.update({ where: { id }, data: { startTime: start, endTime: end } });
      return res.status(200).json(updated);
    }

    const validatedData = updateAppointmentAdminSchema.parse(req.body);
    const { customerName, customerEmail, serviceId, employeeId, startTime, status } = validatedData;
    const updateData: Prisma.AppointmentUpdateInput = {};

    if (startTime) updateData.startTime = startTime;
    if (employeeId) updateData.employee = { connect: { id: employeeId } };
    if (serviceId) updateData.services = { deleteMany: {}, create: { serviceId } };
    if (status) updateData.status = status;
    if (customerEmail && customerName) {
      updateData.user = { connectOrCreate: { where: { email: customerEmail }, create: { email: customerEmail, name: customerName, role: 'CUSTOMER' } } };
    }
    if (startTime || serviceId) {
        const currentAppointment = await prisma.appointment.findUnique({ where: { id }, include: { services: true } });
        const finalServiceId = serviceId || currentAppointment?.services[0]?.serviceId;
        const finalStartTime = startTime || currentAppointment?.startTime;
        if(finalServiceId && finalStartTime) {
            const service = await prisma.service.findUnique({ where: { id: finalServiceId } });
            if (service) updateData.endTime = dayjs(finalStartTime).add(service.duration, 'minutes').toDate();
        }
    }

    const updatedAppointment = await prisma.appointment.update({
      where: { id },
      data: updateData,
      include: { user: true, employee: true, services: { include: { service: true } } },
    });

    if (
      updatedAppointment.status === AppointmentStatus.COMPLETED &&
      appointmentBeforeUpdate.status !== AppointmentStatus.COMPLETED
    ) {
      console.log(`[+] TRIGGER: La cita ${id} ha cambiado a COMPLETED. Enviando solicitud de valoraci√≥n.`);
      
      const notificationUser = updatedAppointment.user || {
        name: updatedAppointment.guestName,
        email: updatedAppointment.guestEmail,
      };
      
      // --- L√ìGICA CORREGIDA ---
      // Buscamos el tel√©fono del invitado o del usuario registrado
      // NOTA: El tel√©fono del usuario registrado no existe a√∫n en el schema. Por ahora, nos basamos en el 'guestPhone'.
      const customerPhone = updatedAppointment.guestPhone; 
      
      if (notificationUser.email && customerPhone) {
        const tempAppointmentDetails = { ...updatedAppointment, user: notificationUser };
        notificationService.sendReviewRequest(tempAppointmentDetails as any, customerPhone);
      } else {
        console.warn(`No se pudo enviar solicitud de valoraci√≥n para la cita ${id}: falta email o tel√©fono.`);
      }
    }

    res.status(200).json(updatedAppointment);
  } catch (error) {
    if (error instanceof ZodError) return res.status(400).json({ errors: error.issues });
    console.error(`Error al actualizar la cita:`, error);
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});


router.delete('/:id', async (req, res) => {
  try {
    const { id } = req.params;
    await prisma.appointment.update({
      where: { id },
      data: { status: AppointmentStatus.AVAILABLE, userId: null, guestName: null, guestEmail: null, guestPhone: null }
    });
    res.status(204).send();
  } catch (error) {
    if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
      return res.status(404).json({ message: 'La cita no fue encontrada.' });
    }
    console.error('Error cancelling appointment:', error);
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});

export default router;


// ====== [51] apps/server/src/api/adminDashboard.routes.ts ======
// File: /apps/server/src/api/adminDashboard.routes.ts (CON ENDPOINT PARA GR√ÅFICO)

import { Router } from 'express';
import dayjs from 'dayjs';
import prisma from '../lib/prisma';
import { AppointmentStatus, UserRole } from '@prisma/client';

const router = Router();

// --- ENDPOINT DE KPIs (sin cambios) ---
router.get('/kpis', async (req, res) => {
  try {
    const todayStart = dayjs().startOf('day').toDate();
    const todayEnd = dayjs().endOf('day').toDate();
    const monthStart = dayjs().startOf('month').toDate();
    const monthEnd = dayjs().endOf('month').toDate();

    const appointmentsToday = await prisma.appointment.findMany({
      where: { startTime: { gte: todayStart, lte: todayEnd }, status: AppointmentStatus.CONFIRMED },
      include: { services: { include: { service: true } } },
    });
    const appointmentsTodayCount = appointmentsToday.length;

    const potentialRevenueToday = appointmentsToday.reduce((total, appt) => {
        const servicePrice = appt.services[0]?.service.prices as { standard?: number };
        return total + (servicePrice?.standard || 0);
    }, 0);

    const newCustomersThisMonth = await prisma.user.count({
      where: { role: UserRole.CUSTOMER, emailVerified: { gte: monthStart, lte: monthEnd } },
    });

    const completedAppointmentsThisMonth = await prisma.appointment.count({
        where: { startTime: { gte: monthStart, lte: monthEnd }, status: AppointmentStatus.COMPLETED }
    });
    const noShowAppointmentsThisMonth = await prisma.appointment.count({
        where: { startTime: { gte: monthStart, lte: monthEnd }, status: AppointmentStatus.NO_SHOW }
    });
    const totalFinishedAppointments = completedAppointmentsThisMonth + noShowAppointmentsThisMonth;
    const noShowRate = totalFinishedAppointments > 0 ? (noShowAppointmentsThisMonth / totalFinishedAppointments) * 100 : 0;

    res.status(200).json({
      appointmentsToday: appointmentsTodayCount,
      potentialRevenueToday: potentialRevenueToday,
      newCustomersThisMonth: newCustomersThisMonth,
      noShowRateThisMonth: noShowRate,
    });
  } catch (error) {
    console.error('Error fetching dashboard KPIs:', error);
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});


// --- NUEVO ENDPOINT PARA EL GR√ÅFICO ---
router.get('/charts/bookings-over-time', async (req, res) => {
    try {
        const today = dayjs().endOf('day');
        const sevenDaysAgo = dayjs().subtract(6, 'day').startOf('day');

        const appointments = await prisma.appointment.findMany({
            where: {
                startTime: {
                    gte: sevenDaysAgo.toDate(),
                    lte: today.toDate(),
                },
                status: { in: [AppointmentStatus.CONFIRMED, AppointmentStatus.COMPLETED] },
            },
            select: {
                startTime: true,
            },
        });

        // Agrupamos las citas por d√≠a
        const countsByDay = new Map<string, number>();
        for (const appt of appointments) {
            const date = dayjs(appt.startTime).format('YYYY-MM-DD');
            countsByDay.set(date, (countsByDay.get(date) || 0) + 1);
        }

        // Creamos el array de datos final, rellenando con 0 los d√≠as sin citas
        const chartData = [];
        for (let i = 0; i < 7; i++) {
            const day = sevenDaysAgo.add(i, 'day');
            const dateKey = day.format('YYYY-MM-DD');
            const formattedDate = day.format('DD/MM');
            
            chartData.push({
                date: formattedDate,
                Citas: countsByDay.get(dateKey) || 0,
            });
        }

        res.status(200).json(chartData);

    } catch (error) {
        console.error('Error fetching bookings over time data:', error);
        res.status(500).json({ message: 'Error interno del servidor.' });
    }
});


export default router;


// ====== [52] apps/server/src/api/adminDateOverrides.routes.ts ======
// File: /apps/server/src/api/adminDateOverrides.routes.ts (CORREGIDO CON NORMALIZACI√ìN UTC)

import { Router } from 'express';
import { z, ZodError } from 'zod';
import dayjs from 'dayjs';
import utc from 'dayjs/plugin/utc'; // <-- Importar el plugin UTC
import prisma from '../lib/prisma';
import { Prisma } from '@prisma/client';

dayjs.extend(utc); // <-- Usar el plugin

const router = Router();

const overrideSchema = z
  .object({
    date: z.coerce.date(),
    reason: z.string().optional(),
    openTime: z.string().regex(/^\d{2}:\d{2}$/).optional().nullable(),
    closeTime: z.string().regex(/^\d{2}:\d{2}$/).optional().nullable(),
  })
  .refine(
    (data) => (data.openTime && data.closeTime) || (!data.openTime && !data.closeTime),
    {
      message: 'Se deben proporcionar tanto la hora de apertura como la de cierre, o ninguna de las dos.',
      path: ['openTime', 'closeTime'],
    }
  );

// --- OBTENER TODAS LAS ANULACIONES DE FECHA ---
router.get('/', async (req, res) => {
  try {
    const overrides = await prisma.dateOverride.findMany({
      orderBy: { date: 'asc' },
    });
    res.status(200).json(overrides);
  } catch (error) {
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});

// --- A√ëADIR UNA NUEVA ANULACI√ìN (CIERRE U HORARIO ESPECIAL) ---
router.post('/', async (req, res) => {
  try {
    const { date, reason, openTime, closeTime } = overrideSchema.parse(req.body);

    // --- CORRECCI√ìN CLAVE: NORMALIZAR LA FECHA A UTC ---
    const utcDate = dayjs(date).utc().startOf('day').toDate();
    const startOfDay = dayjs(utcDate); // Ya est√° en UTC
    const endOfDay = startOfDay.endOf('day');

    // Comprobar si ya existe una anulaci√≥n para este d√≠a
    const existingOverride = await prisma.dateOverride.findFirst({
        where: { date: utcDate },
    });

    if (existingOverride) {
        return res.status(409).json({ message: 'Ya existe una configuraci√≥n especial para este d√≠a.' });
    }
    // --- FIN DE LA CORRECCI√ìN ---


    let conflictingAppointments = [];

    if (openTime && closeTime) {
      const specialOpening = dayjs.utc(`${startOfDay.format('YYYY-MM-DD')}T${openTime}`);
      const specialClosing = dayjs.utc(`${startOfDay.format('YYYY-MM-DD')}T${closeTime}`);

      conflictingAppointments = await prisma.appointment.findMany({
        where: {
          startTime: { gte: startOfDay.toDate(), lte: endOfDay.toDate() },
          OR: [
            { startTime: { lt: specialOpening.toDate() } },
            { endTime: { gt: specialClosing.toDate() } },
          ],
        },
        include: { user: { select: { name: true } } },
      });
    } else {
      conflictingAppointments = await prisma.appointment.findMany({
        where: { startTime: { gte: startOfDay.toDate(), lte: endOfDay.toDate() } },
        include: { user: { select: { name: true } } },
      });
    }

    if (conflictingAppointments.length > 0) {
      return res.status(409).json({
        message: `La operaci√≥n entra en conflicto con ${conflictingAppointments.length} citas existentes.`,
        conflicts: conflictingAppointments,
      });
    }

    const newOverride = await prisma.dateOverride.create({
      data: { date: utcDate, reason, openTime, closeTime }, // <-- Usar la fecha normalizada
    });

    res.status(201).json(newOverride);
  } catch (error) {
    if (error instanceof ZodError) {
      return res.status(400).json({ message: 'Datos inv√°lidos.', errors: error.issues });
    }
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});

// --- ELIMINAR UNA ANULACI√ìN ---
router.delete('/:id', async (req, res) => {
  try {
    const { id } = req.params;
    await prisma.dateOverride.delete({ where: { id } });
    res.status(204).send();
  } catch (error) {
    if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
      return res.status(404).json({ message: 'La anulaci√≥n no fue encontrada.' });
    }
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});

export default router;


// ====== [53] apps/server/src/api/adminSettings.routes.ts ======
// ====== [44] apps/server/src/api/adminSettings.routes.ts ======
// File: /apps/server/src/api/adminSettings.routes.ts (ACTUALIZADO PARA GESTIONAR NOTIFICACIONES)

import { Router } from 'express';
import { z, ZodError } from 'zod';
import prisma from '../lib/prisma';
import { Prisma } from '@prisma/client';

const router = Router();

// --- ESQUEMA AMPLIADO ---
const updateSettingsSchema = z.object({
  defaultServiceId: z.string().cuid({ message: 'El ID del servicio no es v√°lido.' }).optional(),
  weeklySchedule: z.record(z.any()).optional(),

  // Campos de Email (SMTP)
  emailHost: z.string().optional(),
  emailPort: z.string().optional(),
  emailUser: z.string().optional(),
  emailPass: z.string().optional(),
  emailFrom: z.string().optional(),

  // Campos de WhatsApp (Twilio)
  twilioSid: z.string().optional(),
  twilioAuthToken: z.string().optional(),
  twilioPhoneNumber: z.string().optional(),
});

router.get('/', async (req, res) => {
  try {
    const settings = await prisma.businessSettings.findUnique({
      where: { singleton: 'SINGLETON' },
      include: { defaultService: true },
    });

    if (!settings) {
      // Si no hay settings, creamos uno por defecto para evitar errores en el frontend
      const newSettings = await prisma.businessSettings.create({
        data: {
          singleton: 'SINGLETON',
          weeklySchedule: {}, // Un horario vac√≠o por defecto
        },
      });
      const allServices = await prisma.service.findMany({ where: { isActive: true } });
      return res.status(200).json({ settings: newSettings, allServices });
    }
    
    // Transformamos el horario para que coincida con el formato del componente ScheduleEditor
    const transformedSchedule: { [key: string]: { start: string, end: string }[] } = {};
    const originalSchedule = settings.weeklySchedule as any;
    if (originalSchedule) {
        for (const day in originalSchedule) {
            const daySetting = originalSchedule[day];
            if (daySetting && daySetting.open && daySetting.close) {
                transformedSchedule[day] = [{ start: daySetting.open, end: daySetting.close }];
            } else {
                transformedSchedule[day] = [];
            }
        }
    }

    const allServices = await prisma.service.findMany({
      where: { isActive: true },
    });
    
    res.status(200).json({
      settings: { ...settings, weeklySchedule: transformedSchedule },
      allServices,
    });

  } catch (error) {
    console.error('Error al obtener la configuraci√≥n del negocio:', error);
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});

router.put('/', async (req, res) => {
  try {
    const validatedData = updateSettingsSchema.parse(req.body);
    const { weeklySchedule, ...otherSettings } = validatedData;
    
    const updatePayload: Prisma.BusinessSettingsUpdateInput = { ...otherSettings };

    // Si se recibe un weeklySchedule, lo transformamos al formato de la BBDD
    if (weeklySchedule) {
        const scheduleToSave: { [key: string]: { open: string, close: string } | null } = {};
        for (const day in weeklySchedule) {
            const shifts = weeklySchedule[day] as { start: string, end: string }[];
            if (shifts && shifts.length > 0 && shifts[0]) {
                scheduleToSave[day] = { open: shifts[0].start, close: shifts[0].end };
            } else {
                scheduleToSave[day] = null;
            }
        }
        updatePayload.weeklySchedule = scheduleToSave;
    }

    const updatedSettings = await prisma.businessSettings.update({
      where: { singleton: 'SINGLETON' },
      data: updatePayload,
    });

    res.status(200).json(updatedSettings);

  } catch (error) {
    if (error instanceof ZodError) {
      return res.status(400).json({ message: 'Datos de entrada inv√°lidos.', errors: error.issues });
    }
    if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
      return res.status(404).json({ message: 'El servicio o la configuraci√≥n no existen.' });
    }
    console.error('Error al actualizar la configuraci√≥n del negocio:', error);
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});


export default router;


// ====== [54] apps/server/src/api/auth.routes.ts ======
import { Router } from 'express';
import { compare } from 'bcryptjs';
import jwt from 'jsonwebtoken';
import { z } from 'zod';
import prisma from '../lib/prisma';
import { UserRole } from '@prisma/client';

const router = Router();

// Esquema de validaci√≥n para los datos del login
const loginSchema = z.object({
  email: z.string().email('El formato del email no es v√°lido.'),
  password: z.string().min(1, 'La contrase√±a es requerida.'),
});

router.post('/login', async (req, res) => {
  try {
    // 1. Validar los datos de entrada
    const { email, password } = loginSchema.parse(req.body);

    // 2. Buscar al usuario administrador en la base de datos
    const adminUser = await prisma.user.findUnique({
      where: { email },
    });

    // 3. Verificar si el usuario existe y si es un administrador
    if (!adminUser || adminUser.role !== UserRole.ADMIN) {
      return res.status(401).json({ message: 'Credenciales inv√°lidas.' });
    }

    // 4. Comparar la contrase√±a enviada con el hash guardado
    const isPasswordValid = await compare(password, adminUser.passwordHash!);
    if (!isPasswordValid) {
      return res.status(401).json({ message: 'Credenciales inv√°lidas.' });
    }

    // 5. Generar el Token JWT
    const jwtSecret = process.env.JWT_SECRET;
    if (!jwtSecret) {
      console.error('Error: La variable de entorno JWT_SECRET no est√° definida.');
      return res.status(500).json({ message: 'Error interno del servidor.' });
    }

    const token = jwt.sign(
      {
        userId: adminUser.id,
        email: adminUser.email,
        role: adminUser.role,
      },
      jwtSecret,
      { expiresIn: '1d' } // El token expirar√° en 1 d√≠a
    );

    // 6. Enviar el token al cliente
    res.status(200).json({
      message: 'Login exitoso.',
      token,
      user: {
        id: adminUser.id,
        name: adminUser.name,
        email: adminUser.email,
        role: adminUser.role,
      },
    });
  } catch (error) {
    console.error('Error en el login:', error);
    // Si el error es de validaci√≥n de Zod, enviamos una respuesta m√°s espec√≠fica
    if (error instanceof z.ZodError) {
      return res.status(400).json({ message: 'Datos de entrada inv√°lidos.', errors: error.issues });
    }
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});

export default router;


// ====== [55] apps/server/src/api/availability.routes.ts ======
// ====== [46] apps/server/src/api/availability.routes.ts ======
// File: /apps/server/src/api/availability.routes.ts (CORRECCI√ìN FINAL DE FORMATEO A LOCAL)

import { Router } from 'express';
import { z } from 'zod';
import dayjs from 'dayjs';
import utc from 'dayjs/plugin/utc';
import prisma from '../lib/prisma';
import { AppointmentStatus, Prisma } from '@prisma/client';

dayjs.extend(utc);

const router = Router();

const availabilityQuerySchema = z.object({
  date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, 'El formato de fecha debe ser YYYY-MM-DD'),
  employeeId: z.string().cuid().optional(),
});

router.get('/', async (req, res) => {
  try {
    console.log('\n\n--- [GET /availability] Nueva Petici√≥n de Disponibilidad ---');
    const { date, employeeId } = availabilityQuerySchema.parse(req.query);
    console.log(`1. Par√°metros recibidos: date=${date}, employeeId=${employeeId || 'ninguno'}`);

    const startOfDay = dayjs.utc(date).startOf('day');
    const endOfDay = dayjs.utc(date).endOf('day');
    const now = dayjs.utc();
    
    const gteTime = startOfDay.format('YYYY-MM-DD') === now.format('YYYY-MM-DD')
      ? now.toDate()
      : startOfDay.toDate();

    const whereClause: Prisma.AppointmentWhereInput = {
      status: AppointmentStatus.AVAILABLE,
      startTime: {
        gte: gteTime,
        lte: endOfDay.toDate(),
      },
    };

    if (employeeId) {
      whereClause.employeeId = employeeId;
    }

    console.log('2. Cl√°usula WHERE para Prisma:', JSON.stringify(whereClause, null, 2));

    const availableAppointments = await prisma.appointment.findMany({
      where: whereClause,
      orderBy: {
        startTime: 'asc',
      },
      select: {
        startTime: true,
      },
    });

    console.log(`3. Citas encontradas en la BBDD: ${availableAppointments.length} resultados.`);
    console.log('   -> Primeros resultados:', availableAppointments.slice(0, 10));

    const uniqueSlots = new Set<string>();
    availableAppointments.forEach(appt => {
      // --- L√çNEA CORREGIDA ---
      // Tomamos la fecha UTC de la BBDD y la formateamos en la zona horaria local del servidor.
      // dayjs() por defecto convierte la fecha UTC a local.
      uniqueSlots.add(dayjs(appt.startTime).format('HH:mm'));
    });

    const finalSlots = Array.from(uniqueSlots);
    console.log('4. Slots finales enviados al frontend:', finalSlots);

    res.status(200).json(finalSlots);

  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({ message: 'Datos inv√°lidos.', errors: error.issues });
    }
    console.error('[AVAILABILITY] Error fatal al buscar en inventario:', error);
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});

export default router;


// ====== [56] apps/server/src/api/bookings.routes.ts ======
// File: /apps/server/src/api/bookings.routes.ts (CON L√ìGICA PARA USUARIO LOGUEADO)

import { Router } from 'express';
import { z, ZodError } from 'zod';
import dayjs from 'dayjs';
import { hash } from 'bcryptjs';
import jwt from 'jsonwebtoken'; // <-- Importamos JWT
import prisma from '../lib/prisma';
import { AppointmentStatus, Prisma, UserRole } from '@prisma/client';
import { notificationService } from '../lib/notificationService';

const router = Router();

const createBookingSchema = z.object({
  serviceId: z.string().cuid(),
  startTime: z.coerce.date(),
  employeeId: z.string().cuid().optional(),
  customerName: z.string().min(3),
  customerEmail: z.string().email(),
  customerPhone: z.string().min(1),
  createAccount: z.boolean().optional(),
  password: z.string().optional(),
});

interface TokenPayload {
    userId: string;
    role: UserRole;
}

router.post('/', async (req, res) => {
  try {
    const validatedData = createBookingSchema.parse(req.body);
    const { 
      startTime, employeeId, customerName, customerEmail, 
      customerPhone, createAccount, password 
    } = validatedData;

    // 1. Encontrar un hueco disponible
    const startOfMinute = dayjs(startTime).startOf('minute').toDate();
    const endOfMinute = dayjs(startTime).endOf('minute').toDate();
    const availableSlot = await prisma.appointment.findFirst({
        where: {
            startTime: { gte: startOfMinute, lte: endOfMinute },
            status: AppointmentStatus.AVAILABLE,
            ...(employeeId && { employeeId: employeeId }),
        },
    });

    if (!availableSlot) {
      return res.status(409).json({ message: 'Lo sentimos, este hueco ya no est√° disponible.' });
    }

    // --- 2. L√ìGICA MEJORADA PARA DETECTAR USUARIO LOGUEADO ---
    let appointmentUpdateData: Prisma.AppointmentUpdateInput = {};
    let authenticatedUser: { id: string, name: string | null, email: string } | null = null;

    const authHeader = req.headers.authorization;
    const token = authHeader && authHeader.split(' ')[1];
    const jwtSecret = process.env.JWT_SECRET;

    if (token && jwtSecret) {
        try {
            const payload = jwt.verify(token, jwtSecret) as TokenPayload;
            if (payload.role === UserRole.CUSTOMER) {
                const user = await prisma.user.findUnique({ where: { id: payload.userId } });
                if (user) authenticatedUser = user;
            }
        } catch (error) { /* Ignoramos el token si es inv√°lido y procedemos como invitado */ }
    }

    if (authenticatedUser) {
        // --- Caso: Usuario ya logueado ---
        appointmentUpdateData.user = { connect: { id: authenticatedUser.id } };
        console.log(`[POST /bookings] Cita solicitada por usuario autenticado: ${authenticatedUser.email}`);
    } else if (createAccount && password) {
      // --- Caso: Invitado creando cuenta ---
      const passwordHash = await hash(password, 12);
      const newUser = await prisma.user.create({
        data: { name: customerName, email: customerEmail, passwordHash, role: UserRole.CUSTOMER },
      });
      appointmentUpdateData.user = { connect: { id: newUser.id } };
      authenticatedUser = newUser; // Lo tratamos como usuario para la notificaci√≥n
      console.log(`[POST /bookings] Nueva cuenta creada para ${customerEmail} y vinculada.`);
    } else {
      // --- Caso: Reserva como invitado ---
      appointmentUpdateData.guestName = customerName;
      appointmentUpdateData.guestEmail = customerEmail;
      appointmentUpdateData.guestPhone = customerPhone;
      console.log(`[POST /bookings] Cita creada como invitado para ${customerEmail}.`);
    }
    // --- FIN DE LA L√ìGICA MEJORADA ---

    // 3. Actualizar la cita
    const confirmedAppointment = await prisma.appointment.update({
        where: { id: availableSlot.id },
        data: { status: AppointmentStatus.CONFIRMED, ...appointmentUpdateData },
        include: { user: true, employee: true, services: { include: { service: true } } },
    });

    // 4. Enviar notificaci√≥n
    const finalUser = authenticatedUser || { name: customerName, email: customerEmail };
    if (finalUser) {
      const tempAppointmentDetails = { ...confirmedAppointment, user: finalUser };
      notificationService.sendBookingConfirmation(tempAppointmentDetails as any, customerPhone);
    }
    
    res.status(201).json(confirmedAppointment);

  } catch (error) {
    if (error instanceof ZodError) return res.status(400).json({ errors: error.issues });
    if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
        return res.status(409).json({ message: 'Ya existe una cuenta con este email. Por favor, inicia sesi√≥n.' });
    }
    console.error('Error al crear la reserva:', error);
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});

export default router;


// ====== [57] apps/server/src/api/customer.routes.ts ======
// File: /apps/server/src/api/customer.routes.ts (CORREGIDO)

import { Router, Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import prisma from '../lib/prisma';
// --- L√çNEA MODIFICADA ---
import { UserRole, AppointmentStatus, Prisma } from '@prisma/client';

const router = Router();

interface AuthRequest extends Request {
  user?: { userId: string; role: UserRole; };
}

const authenticateCustomer = (req: AuthRequest, res: Response, next: NextFunction) => {
  const authHeader = req.headers.authorization;
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    return res.status(401).json({ message: 'Acceso denegado. No se proporcion√≥ token.' });
  }

  const jwtSecret = process.env.JWT_SECRET;
  if (!jwtSecret) {
    return res.status(500).json({ message: 'Error de configuraci√≥n del servidor.' });
  }

  try {
    const payload = jwt.verify(token, jwtSecret) as { userId: string; role: UserRole };
    if (payload.role !== UserRole.CUSTOMER) {
        return res.status(403).json({ message: 'Acceso prohibido. Ruta solo para clientes.' });
    }
    req.user = payload;
    next();
  } catch (error) {
    return res.status(403).json({ message: 'Token no v√°lido o expirado.' });
  }
};

router.use(authenticateCustomer);

router.get('/appointments', async (req: AuthRequest, res: Response) => {
  const userId = req.user?.userId;
  try {
    const appointments = await prisma.appointment.findMany({
      where: { userId: userId },
      orderBy: { startTime: 'desc' },
      include: {
        services: { include: { service: { select: { name: true, duration: true } } } },
        employee: { select: { name: true } },
      },
    });
    res.status(200).json(appointments);
  } catch (error) {
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});

router.post('/appointments/:appointmentId/cancel', async (req: AuthRequest, res: Response) => {
    const userId = req.user?.userId;
    const { appointmentId } = req.params;

    try {
        const updatedAppointment = await prisma.appointment.update({
            where: {
                id: appointmentId,
                userId: userId,
            },
            data: {
                status: AppointmentStatus.CANCELLED,
            },
        });

        res.status(200).json({ message: 'Cita cancelada correctamente.', appointment: updatedAppointment });

    } catch (error) {
        // --- BLOQUE CATCH CORREGIDO ---
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
            return res.status(404).json({ message: 'No se encontr√≥ la cita o no tienes permiso para cancelarla.' });
        }
        // --- FIN DE LA CORRECCI√ìN ---
        console.error('Error al cancelar la cita:', error);
        res.status(500).json({ message: 'Error interno del servidor.' });
    }
});


export default router;


// ====== [58] apps/server/src/api/customerAuth.routes.ts ======
// File: /apps/server/src/api/customerAuth.routes.ts (VERSI√ìN A PRUEBA DE BALAS)

import { Router } from 'express';
import { z, ZodError } from 'zod';
import { hash, compare } from 'bcryptjs';
import jwt from 'jsonwebtoken';
import prisma from '../lib/prisma';
import { UserRole, Prisma } from '@prisma/client';

const router = Router();

const registerSchema = z.object({
  name: z.string().min(3, 'El nombre debe tener al menos 3 caracteres.'),
  email: z.string().email('El formato del email no es v√°lido.'),
  password: z.string().min(8, 'La contrase√±a debe tener al menos 8 caracteres.'),
});

const loginSchema = z.object({
  email: z.string().email('El formato del email no es v√°lido.'),
  password: z.string().min(1, 'La contrase√±a es requerida.'),
});

const generateAuthToken = (user: { id: string, email: string, role: UserRole }) => {
  const jwtSecret = process.env.JWT_SECRET;
  if (!jwtSecret) {
    console.error('Error Cr√≠tico: La variable de entorno JWT_SECRET no est√° definida.');
    throw new Error('La configuraci√≥n del servidor est√° incompleta.');
  }

  // SOLUCI√ìN DEFINITIVA: Usamos un N√öMERO (segundos) para expiresIn.
  // El .env tiene "604800s". parseInt lo convertir√° a 604800.
  const expiresInSeconds = parseInt(process.env.JWT_EXPIRES_IN || '604800', 10);

  const tokenOptions: jwt.SignOptions = {
    expiresIn: expiresInSeconds,
  };
  
  return jwt.sign(
    { userId: user.id, email: user.email, role: user.role },
    jwtSecret,
    tokenOptions
  );
};

router.post('/register', async (req, res) => {
  try {
    const { name, email, password } = registerSchema.parse(req.body);
    const passwordHash = await hash(password, 12);
    const newUser = await prisma.user.create({
      data: { name, email, passwordHash, role: UserRole.CUSTOMER, emailVerified: new Date() },
    });
    const token = generateAuthToken(newUser);
    res.status(201).json({
      message: 'Usuario registrado con √©xito.',
      token,
      user: { id: newUser.id, name: newUser.name, email: newUser.email },
    });
  } catch (error) {
    if (error instanceof ZodError) {
      return res.status(400).json({ message: 'Datos de entrada inv√°lidos.', errors: error.issues });
    }
    if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
      return res.status(409).json({ message: 'Ya existe una cuenta con este email.' });
    }
    console.error('Error en el registro de cliente:', error);
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});

router.post('/login', async (req, res) => {
  try {
    const { email, password } = loginSchema.parse(req.body);
    const user = await prisma.user.findUnique({ where: { email } });
    if (!user || !user.passwordHash) {
      return res.status(401).json({ message: 'Credenciales inv√°lidas.' });
    }
    const isPasswordValid = await compare(password, user.passwordHash);
    if (!isPasswordValid) {
      return res.status(401).json({ message: 'Credenciales inv√°lidas.' });
    }
    if (user.role !== UserRole.CUSTOMER) {
        return res.status(403).json({ message: 'Acceso no autorizado para este tipo de cuenta.' });
    }
    const token = generateAuthToken(user);
    res.status(200).json({
      message: 'Login exitoso.',
      token,
      user: { id: user.id, name: user.name, email: user.email },
    });
  } catch (error) {
    if (error instanceof ZodError) {
      return res.status(400).json({ message: 'Datos de entrada inv√°lidos.', errors: error.issues });
    }
    console.error('Error en el login de cliente:', error);
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});

export default router;


// ====== [59] apps/server/src/api/employees.routes.ts ======
// File: /apps/server/src/api/employees.routes.ts (ORDEN CORREGIDO)

import { Router } from 'express';
import { z, ZodError } from 'zod';
import { Prisma, EmployeeStatus } from '@prisma/client';
import prisma from '../lib/prisma';
import { createEmployeeSchema } from '@aquaclean/types';

const router = Router();

// --- GESTI√ìN DEL PERFIL DEL EMPLEADO Y RUTAS P√öBLICAS ---

// Ruta para el panel de admin
router.get('/', async (req, res) => {
  try {
    const { status } = req.query;
    let whereClause = {};
    if (status === 'ACTIVE' || status === 'ARCHIVED') {
      whereClause = { status: status as EmployeeStatus };
    }
    const employees = await prisma.employee.findMany({ where: whereClause, orderBy: { name: 'asc' } });
    res.status(200).json(employees);
  } catch (error) {
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});

// --- RUTA P√öBLICA (MOVIDA HACIA ARRIBA) ---
router.get('/public', async (req, res) => {
  try {
    const publicEmployees = await prisma.employee.findMany({
      where: { status: 'ACTIVE' },
      select: { id: true, name: true, bio: true, imageUrl: true },
      orderBy: { name: 'asc' },
    });
    res.status(200).json(publicEmployees);
  } catch (error) {
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});

// --- RUTA GEN√âRICA CON :id (AHORA VA DESPU√âS DE LA ESPEC√çFICA) ---
router.get('/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const employee = await prisma.employee.findUnique({ where: { id } });
    if (!employee) return res.status(404).json({ message: 'Empleado no encontrado.' });
    res.status(200).json(employee);
  } catch (error) {
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});

router.post('/', async (req, res) => {
  try {
    const validatedData = createEmployeeSchema.parse(req.body);
    const { workSchedule, ...restOfData } = validatedData;
    const newEmployee = await prisma.employee.create({
      data: {
        ...restOfData,
        workSchedule: (workSchedule as Prisma.JsonObject) ?? Prisma.JsonNull,
      },
    });
    res.status(201).json(newEmployee);
  } catch (error) {
    if (error instanceof ZodError) return res.status(400).json({ errors: error.issues });
    if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
      return res.status(409).json({ message: 'Ya existe un empleado con ese email.' });
    }
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});

router.put('/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const updateSchema = createEmployeeSchema.partial();
    const validatedData = updateSchema.parse(req.body);
    const { workSchedule, ...restOfData } = validatedData;
    const updatedEmployee = await prisma.employee.update({
      where: { id },
      data: {
        ...restOfData,
        ...(workSchedule && {
          workSchedule: workSchedule as Prisma.JsonObject,
        }),
      },
    });
    res.status(200).json(updatedEmployee);
  } catch (error) {
    if (error instanceof ZodError) return res.status(400).json({ errors: error.issues });
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      if (error.code === 'P2025') return res.status(404).json({ message: 'Empleado no encontrado.' });
      if (error.code === 'P2002') return res.status(409).json({ message: 'Ya existe otro empleado con ese email.' });
    }
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});

// --- GESTI√ìN DE AUSENCIAS (VACACIONES, ETC.) ---
// ... (el resto del archivo no cambia) ...

const absenceSchema = z.object({
  startDate: z.coerce.date(),
  endDate: z.coerce.date(),
  reason: z.string().optional(),
});

router.get('/:employeeId/absences', async (req, res) => {
  try {
    const { employeeId } = req.params;
    const absences = await prisma.absence.findMany({ where: { employeeId } });
    res.status(200).json(absences);
  } catch (error) {
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});

router.post('/:employeeId/absences', async (req, res) => {
  try {
    const { employeeId } = req.params;
    const validatedData = absenceSchema.parse(req.body);
    const newAbsence = await prisma.absence.create({
      data: { ...validatedData, employeeId },
    });
    res.status(201).json(newAbsence);
  } catch (error) {
    if (error instanceof ZodError) return res.status(400).json({ errors: error.issues });
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});

router.delete('/:employeeId/absences/:absenceId', async (req, res) => {
  try {
    const { absenceId } = req.params;
    await prisma.absence.delete({ where: { id: absenceId } });
    res.status(204).send();
  } catch (error) {
    if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
      return res.status(404).json({ message: 'Ausencia no encontrada.' });
    }
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});

export default router;


// ====== [60] apps/server/src/api/reviews.routes.ts ======
// File: /apps/server/src/api/reviews.routes.ts (CON RUTA P√öBLICA GET)

import { Router } from 'express';
import { z, ZodError } from 'zod';
import jwt from 'jsonwebtoken';
import prisma from '../lib/prisma';
import { Prisma, ReviewStatus } from '@prisma/client';

const router = Router();

// --- ESQUEMAS ---
const createReviewSchema = z.object({
  token: z.string().min(1, 'El token es requerido.'),
  rating: z.number().min(1).max(5),
  comment: z.string().optional(),
});

const updateReviewStatusSchema = z.object({
  status: z.nativeEnum(ReviewStatus),
});

interface ReviewTokenPayload {
  appointmentId: string;
}

// ===============================================
// --- RUTA P√öBLICA PARA OBTENER VALORACIONES ---
// ===============================================
router.get('/', async (req, res) => {
    try {
        const reviews = await prisma.review.findMany({
            where: { status: ReviewStatus.APPROVED },
            orderBy: { createdAt: 'desc' },
            take: 6, // Mostramos las 6 m√°s recientes
            include: {
                appointment: {
                    select: {
                        // Seleccionamos el nombre del cliente, ya sea de un usuario registrado o de un invitado
                        user: { select: { name: true } },
                        guestName: true,
                    }
                }
            }
        });

        // Formateamos los datos para el p√∫blico, evitando exponer informaci√≥n sensible
        const publicReviews = reviews.map(review => ({
            id: review.id,
            rating: review.rating,
            comment: review.comment,
            customerName: review.appointment.user?.name || review.appointment.guestName,
            createdAt: review.createdAt,
        }));

        res.status(200).json(publicReviews);
    } catch (error) {
        console.error('Error al obtener las valoraciones p√∫blicas:', error);
        res.status(500).json({ message: 'Error interno del servidor.' });
    }
});


// =============================================
// --- RUTA P√öBLICA PARA ENVIAR VALORACI√ìN ---
// =============================================
router.post('/', async (req, res) => {
  try {
    const { token, rating, comment } = createReviewSchema.parse(req.body);
    const jwtSecret = process.env.JWT_SECRET;
    if (!jwtSecret) {
      return res.status(500).json({ message: 'Error de configuraci√≥n del servidor.' });
    }

    let payload: ReviewTokenPayload;
    try {
      payload = jwt.verify(token, jwtSecret) as ReviewTokenPayload;
    } catch (error) {
      return res.status(401).json({ message: 'El token de valoraci√≥n no es v√°lido o ha expirado.' });
    }

    const { appointmentId } = payload;
    const targetAppointment = await prisma.appointment.findUnique({
      where: { id: appointmentId }, include: { review: true },
    });

    if (!targetAppointment) return res.status(404).json({ message: 'La cita asociada no fue encontrada.' });
    if (targetAppointment.review) return res.status(409).json({ message: 'Esta cita ya ha sido valorada.' });

    const newReview = await prisma.review.create({
      data: {
        rating, comment, status: ReviewStatus.PENDING,
        appointment: { connect: { id: targetAppointment.id } },
        employee: { connect: { id: targetAppointment.employeeId } },
        ...(targetAppointment.userId && { user: { connect: { id: targetAppointment.userId } } }),
      },
    });

    res.status(201).json(newReview);
  } catch (error) {
    if (error instanceof ZodError) return res.status(400).json({ errors: error.issues });
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});


// =======================================================
// --- RUTAS DE ADMINISTRACI√ìN PARA MODERAR VALORACIONES ---
// =======================================================
router.get('/admin', async (req, res) => {
    try {
        const reviews = await prisma.review.findMany({
            orderBy: { createdAt: 'desc' },
            include: {
                employee: { select: { name: true } },
                appointment: {
                    include: {
                        user: { select: { name: true } },
                        services: { include: { service: { select: { name: true } } } }
                    }
                }
            }
        });
        const formattedReviews = reviews.map(review => ({
            id: review.id, rating: review.rating, comment: review.comment,
            status: review.status, createdAt: review.createdAt, employeeName: review.employee.name,
            customerName: review.appointment.user?.name || review.appointment.guestName,
            serviceName: review.appointment.services[0]?.service.name || 'Servicio Desconocido',
        }));
        res.status(200).json(formattedReviews);
    } catch (error) {
        res.status(500).json({ message: 'Error interno del servidor.' });
    }
});

router.put('/admin/:id', async (req, res) => {
    try {
        const { id } = req.params;
        const { status } = updateReviewStatusSchema.parse(req.body);
        const updatedReview = await prisma.review.update({ where: { id }, data: { status } });
        res.status(200).json(updatedReview);
    } catch (error) {
        if (error instanceof ZodError) return res.status(400).json({ errors: error.issues });
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
            return res.status(404).json({ message: 'La valoraci√≥n no fue encontrada.' });
        }
        res.status(500).json({ message: 'Error interno del servidor.' });
    }
});


export default router;


// ====== [61] apps/server/src/api/services.routes.ts ======
// File: /apps/server/src/api/services.routes.ts (RECONSTRUIDO)

import { Router } from 'express';
import { ZodError } from 'zod';
import { Prisma } from '@prisma/client';
import prisma from '../lib/prisma';
import { createServiceSchema } from '@aquaclean/types';

const router = Router();

// --- OBTENER TODOS LOS SERVICIOS ---
router.get('/', async (req, res) => {
  try {
    const services = await prisma.service.findMany({
      orderBy: { name: 'asc' },
    });
    res.status(200).json(services);
  } catch (error) {
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});

// --- CREAR UN NUEVO SERVICIO ---
router.post('/', async (req, res) => {
  try {
    const validatedData = createServiceSchema.parse(req.body);
    const newService = await prisma.service.create({
      data: validatedData,
    });
    res.status(201).json(newService);
  } catch (error) {
    if (error instanceof ZodError) {
      return res.status(400).json({ message: 'Datos de entrada inv√°lidos.', errors: error.issues });
    }
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});

// --- ACTUALIZAR UN SERVICIO EXISTENTE ---
router.put('/:id', async (req, res) => {
  try {
    const { id } = req.params;
    // Hacemos el esquema parcial para permitir actualizaciones de solo algunos campos
    const updateSchema = createServiceSchema.partial();
    const validatedData = updateSchema.parse(req.body);

    const updatedService = await prisma.service.update({
      where: { id },
      data: validatedData,
    });
    res.status(200).json(updatedService);
  } catch (error) {
    if (error instanceof ZodError) {
      return res.status(400).json({ message: 'Datos de entrada inv√°lidos.', errors: error.issues });
    }
    if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
      return res.status(404).json({ message: 'Servicio no encontrado.' });
    }
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});

// --- ELIMINAR UN SERVICIO ---
router.delete('/:id', async (req, res) => {
  try {
    const { id } = req.params;

    // L√≥gica de seguridad: Comprobar si hay citas asociadas
    const appointmentCount = await prisma.appointmentService.count({
      where: { serviceId: id },
    });

    if (appointmentCount > 0) {
      return res.status(409).json({ // 409 Conflict
        message: `No se puede eliminar el servicio porque tiene ${appointmentCount} citas asociadas. Por favor, desact√≠valo en su lugar.`,
      });
    }

    await prisma.service.delete({
      where: { id },
    });
    res.status(204).send(); // 204 No Content
  } catch (error) {
    if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
      return res.status(404).json({ message: 'Servicio no encontrado.' });
    }
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});

export default router;


// ====== [62] apps/server/src/lib/availabilityService.ts ======
// File: /apps/server/src/lib/availabilityService.ts (CON LOGS DE DEPURACI√ìN EN isEmployeeAvailable)

import dayjs from 'dayjs';
import utc from 'dayjs/plugin/utc';
import isSameOrAfter from 'dayjs/plugin/isSameOrAfter';
import isSameOrBefore from 'dayjs/plugin/isSameOrBefore';
import isBetween from 'dayjs/plugin/isBetween';
import 'dayjs/locale/en';
import { Employee, Absence } from '@prisma/client';
import prisma from './prisma';

dayjs.extend(utc);
dayjs.extend(isSameOrAfter);
dayjs.extend(isSameOrBefore);
dayjs.extend(isBetween);
dayjs.locale('en');

export function isEmployeeAvailable(
  employee: Employee & { absences: Absence[] },
  slot: dayjs.Dayjs,
  serviceDuration: number
): boolean {
  const dayOfWeek = slot.locale('en').format('dddd').toLowerCase();
  const workSchedule = employee.workSchedule as any;
  const daySchedule = workSchedule?.[dayOfWeek];

  if (!daySchedule || daySchedule.length === 0) {
    return false;
  }

  // --- LOGS DE DEPURACI√ìN ---
  const slotEnd = slot.add(serviceDuration, 'minutes');
  console.log(`\n[DEBUG] Comprobando Empleado: ${employee.name} | Slot: ${slot.format('HH:mm')} - ${slotEnd.format('HH:mm')} | D√≠a: ${dayOfWeek}`);
  // --- FIN DE LOGS ---

  const worksDuringSlot = (daySchedule as any[]).some(shift => {
    const shiftStart = dayjs.utc(`${slot.format('YYYY-MM-DD')}T${shift.start}`);
    const shiftEnd = dayjs.utc(`${slot.format('YYYY-MM-DD')}T${shift.end}`);

    const isAfterStart = slot.isSameOrAfter(shiftStart);
    const isBeforeEnd = slotEnd.isSameOrBefore(shiftEnd);

    // --- LOGS DE DEPURACI√ìN ---
    console.log(`  -> Turno: ${shift.start}-${shift.end} (${shiftStart.format('HH:mm')}-${shiftEnd.format('HH:mm')} UTC)`);
    console.log(`     Slot empieza >= Turno empieza? ${isAfterStart} (${slot.format('HH:mm')} >= ${shiftStart.format('HH:mm')})`);
    console.log(`     Slot termina <= Turno termina? ${isBeforeEnd} (${slotEnd.format('HH:mm')} <= ${shiftEnd.format('HH:mm')})`);
    // --- FIN DE LOGS ---

    return isAfterStart && isBeforeEnd;
  });

  if (!worksDuringSlot) {
    console.log(`[DEBUG] RESULTADO: ‚ùå ${employee.name} NO trabaja en este slot.`);
    return false;
  }
  
  const hasAbsence = employee.absences.some(absence => {
    const absenceStart = dayjs.utc(absence.startDate).startOf('day');
    const absenceEnd = dayjs.utc(absence.endDate).endOf('day');
    const hasConflict = slot.isBetween(absenceStart, absenceEnd, null, '[]');
    if (hasConflict) {
        console.log(`[DEBUG] Conflicto de ausencia encontrado: ${absenceStart.format('YYYY-MM-DD')} a ${absenceEnd.format('YYYY-MM-DD')}`);
    }
    return hasConflict;
  });

  if (hasAbsence) {
    console.log(`[DEBUG] RESULTADO: ‚ùå ${employee.name} tiene una ausencia programada.`);
    return false;
  }

  console.log(`[DEBUG] RESULTADO: ‚úÖ ${employee.name} EST√Å disponible para este slot.`);
  return true;
};

export async function findAvailableEmployeeForSlot(startTime: Date, endTime: Date, serviceDuration: number): Promise<string | undefined> {
  const overlappingAppointments = await prisma.appointment.findMany({
    where: { OR: [ { startTime: { lt: endTime }, endTime: { gt: startTime } } ] },
    select: { employeeId: true },
  });
  const busyEmployeeIds = new Set(overlappingAppointments.map(a => a.employeeId));

  const potentialEmployees = await prisma.employee.findMany({
    where: { 
      status: 'ACTIVE', 
      id: { notIn: Array.from(busyEmployeeIds) },
      absences: { none: { startDate: { lte: endTime }, endDate: { gte: startTime } } } 
    },
    include: { absences: true }
  });
  
  const startTimeUtc = dayjs.utc(startTime);

  const availableEmployee = potentialEmployees.find(employee => {
    return isEmployeeAvailable(employee, startTimeUtc, serviceDuration);
  });

  return availableEmployee ? availableEmployee.id : undefined;
}


// ====== [63] apps/server/src/lib/cronService.ts ======
// File: /apps/server/src/lib/cronService.ts (NUEVO ARCHIVO)

import cron from 'node-cron';
import dayjs from 'dayjs';
import prisma from './prisma';
import { AppointmentStatus } from '@prisma/client';
import { notificationService } from './notificationService';
import type { FullAppointmentDetails } from './notificationService';

const startReminderService = () => {
  // Esta tarea se ejecutar√° al principio de cada hora (minuto 0).
  // Formato cron: minuto(0-59) hora(0-23) d√≠a-del-mes(1-31) mes(1-12) d√≠a-de-la-semana(0-7)
  cron.schedule('0 * * * *', async () => {
    console.log(`\n--- [CRON JOB] Ejecutando tarea de recordatorios de citas - ${new Date().toISOString()} ---`);

    try {
      // 1. Definimos la ventana de tiempo para buscar citas.
      // Buscamos citas que ocurran entre 24 y 25 horas desde ahora.
      const now = dayjs();
      const reminderWindowStart = now.add(24, 'hour').toDate();
      const reminderWindowEnd = now.add(25, 'hour').toDate();

      console.log(`Buscando citas entre: ${reminderWindowStart.toISOString()} y ${reminderWindowEnd.toISOString()}`);

      // 2. Buscamos en la base de datos.
      const appointmentsToSendReminder = await prisma.appointment.findMany({
        where: {
          status: AppointmentStatus.CONFIRMED,
          reminderSent: false,
          startTime: {
            gte: reminderWindowStart,
            lt: reminderWindowEnd,
          },
        },
        include: {
          user: true,
          employee: true,
          services: { include: { service: true } },
        },
      });

      if (appointmentsToSendReminder.length === 0) {
        console.log('No se encontraron citas que necesiten un recordatorio en esta ejecuci√≥n.');
        return;
      }

      console.log(`Se encontraron ${appointmentsToSendReminder.length} citas para enviar recordatorio.`);

      // 3. Procesamos cada cita encontrada.
      for (const appointment of appointmentsToSendReminder) {
        if (appointment.user) {
          // 3a. Enviamos la notificaci√≥n.
          await notificationService.sendAppointmentReminder(appointment as FullAppointmentDetails);
          
          // 3b. Actualizamos la cita para marcar el recordatorio como enviado.
          await prisma.appointment.update({
            where: { id: appointment.id },
            data: { reminderSent: true },
          });
          console.log(`Recordatorio para la cita ID ${appointment.id} marcado como enviado en la BBDD.`);
        }
      }

    } catch (error) {
      console.error('Error durante la ejecuci√≥n del cron job de recordatorios:', error);
    } finally {
        console.log('--- [CRON JOB] Tarea de recordatorios finalizada. ---');
    }
  });

  console.log('‚úÖ Servicio de recordatorios (Cron Job) inicializado y programado.');
};

export const reminderService = {
  start: startReminderService,
};


// ====== [64] apps/server/src/lib/cronService_24h.ts ======
// File: /apps/server/src/lib/cronService.ts (NUEVO ARCHIVO)

import cron from 'node-cron';
import dayjs from 'dayjs';
import prisma from './prisma';
import { AppointmentStatus } from '@prisma/client';
import { notificationService } from './notificationService';
import type { FullAppointmentDetails } from './notificationService';

const startReminderService = () => {
  // Esta tarea se ejecutar√° al principio de cada hora (minuto 0).
  // Formato cron: minuto(0-59) hora(0-23) d√≠a-del-mes(1-31) mes(1-12) d√≠a-de-la-semana(0-7)
  cron.schedule('0 * * * *', async () => {
    console.log(`\n--- [CRON JOB] Ejecutando tarea de recordatorios de citas - ${new Date().toISOString()} ---`);

    try {
      // 1. Definimos la ventana de tiempo para buscar citas.
      // Buscamos citas que ocurran entre 24 y 25 horas desde ahora.
      const now = dayjs();
      const reminderWindowStart = now.add(24, 'hour').toDate();
      const reminderWindowEnd = now.add(25, 'hour').toDate();

      console.log(`Buscando citas entre: ${reminderWindowStart.toISOString()} y ${reminderWindowEnd.toISOString()}`);

      // 2. Buscamos en la base de datos.
      const appointmentsToSendReminder = await prisma.appointment.findMany({
        where: {
          status: AppointmentStatus.CONFIRMED,
          reminderSent: false,
          startTime: {
            gte: reminderWindowStart,
            lt: reminderWindowEnd,
          },
        },
        include: {
          user: true,
          employee: true,
          services: { include: { service: true } },
        },
      });

      if (appointmentsToSendReminder.length === 0) {
        console.log('No se encontraron citas que necesiten un recordatorio en esta ejecuci√≥n.');
        return;
      }

      console.log(`Se encontraron ${appointmentsToSendReminder.length} citas para enviar recordatorio.`);

      // 3. Procesamos cada cita encontrada.
      for (const appointment of appointmentsToSendReminder) {
        if (appointment.user) {
          // 3a. Enviamos la notificaci√≥n.
          await notificationService.sendAppointmentReminder(appointment as FullAppointmentDetails);
          
          // 3b. Actualizamos la cita para marcar el recordatorio como enviado.
          await prisma.appointment.update({
            where: { id: appointment.id },
            data: { reminderSent: true },
          });
          console.log(`Recordatorio para la cita ID ${appointment.id} marcado como enviado en la BBDD.`);
        }
      }

    } catch (error) {
      console.error('Error durante la ejecuci√≥n del cron job de recordatorios:', error);
    } finally {
        console.log('--- [CRON JOB] Tarea de recordatorios finalizada. ---');
    }
  });

  console.log('‚úÖ Servicio de recordatorios (Cron Job) inicializado y programado.');
};

export const reminderService = {
  start: startReminderService,
};


// ====== [65] apps/server/src/lib/notificationService.ts ======
// File: /apps/server/src/lib/notificationService.ts (CON SOLICITUD MULTICANAL Y TOKEN SEGURO)

import nodemailer from 'nodemailer';
import twilio from 'twilio';
import jwt from 'jsonwebtoken'; // <-- Importamos JWT
import { Appointment, Employee, Service, User } from '@prisma/client';
import dayjs from 'dayjs';
import 'dayjs/locale/es';
import prisma from './prisma';

dayjs.locale('es');

export type FullAppointmentDetails = Appointment & {
  user: User | { name: string | null; email: string | null; };
  employee: Employee;
  services: { service: Service }[];
};

let transporter: nodemailer.Transporter | null = null;

async function getTransporter() {
  if (transporter) { return transporter; }
  const settings = await prisma.businessSettings.findUnique({ where: { singleton: 'SINGLETON' } });
  if (settings && settings.emailHost && settings.emailPort && settings.emailUser && settings.emailPass) {
    console.log('--- Configuraci√≥n SMTP encontrada en la BBDD. Usando transporter real. ---');
    transporter = nodemailer.createTransport({
      host: settings.emailHost,
      port: Number(settings.emailPort),
      secure: Number(settings.emailPort) === 465,
      auth: { user: settings.emailUser, pass: settings.emailPass },
    });
    return transporter;
  }
  console.log('--- No se encontr√≥ configuraci√≥n SMTP. Usando simulador Ethereal. ---');
  const testAccount = await nodemailer.createTestAccount();
  console.log('User:', testAccount.user, 'Pass:', testAccount.pass);
  transporter = nodemailer.createTransport({
    host: 'smtp.ethereal.email',
    port: 587,
    secure: false,
    auth: { user: testAccount.user, pass: testAccount.pass },
  });
  return transporter;
}

async function sendWhatsAppConfirmation(appointmentDetails: FullAppointmentDetails, customerPhone: string) {
  try {
    const settings = await prisma.businessSettings.findUnique({ where: { singleton: 'SINGLETON' } });
    if (!settings || !settings.twilioSid || !settings.twilioAuthToken || !settings.twilioPhoneNumber) {
      console.log('--- Faltan credenciales de Twilio en la BBDD. Omitiendo env√≠o de WhatsApp. ---');
      return;
    }
    console.log('--- Credenciales de Twilio encontradas. Intentando enviar WhatsApp. ---');
    const client = twilio(settings.twilioSid, settings.twilioAuthToken);
    const { user, services, startTime } = appointmentDetails;
    const service = services[0]?.service;
    if (!service) return;

    const formattedDate = dayjs(startTime).format('D [de] MMMM');
    const formattedTime = dayjs(startTime).format('HH:mm');

    const fromNumber = settings.twilioPhoneNumber;
    const toNumber = `whatsapp:${customerPhone.startsWith('+') ? customerPhone : `+34${customerPhone}`.replace(/\s+/g, '')}`;

    console.log(`  -> Intentando enviar desde: ${fromNumber}`);
    console.log(`  -> Intentando enviar a: ${toNumber}`);

    await client.messages.create({
      from: fromNumber,
      to: toNumber,
      body: `¬°Hola ${user.name}! üëã Tu cita en AquaClean para un *${service.name}* el *${formattedDate}* a las *${formattedTime}h* est√° confirmada. ¬°Te esperamos!`,
    });

    console.log(`‚úÖ WhatsApp de confirmaci√≥n enviado con √©xito a: ${toNumber}`);

  } catch (error) {
    console.error('Error al enviar el WhatsApp de confirmaci√≥n:', error);
  }
}

async function sendBookingConfirmation(appointmentDetails: FullAppointmentDetails, customerPhone: string) {
  try {
    const mailTransporter = await getTransporter();
    const { user, employee, services, startTime } = appointmentDetails;
    const service = services[0]?.service;
    if (!service || !user.email) { return; }
    const formattedDateTime = dayjs(startTime).format('dddd, D [de] MMMM [de] YYYY [a las] HH:mm');
    const settings = await prisma.businessSettings.findUnique({ where: { singleton: 'SINGLETON' } });
    const fromEmail = settings?.emailFrom || '"AquaClean Car Wash" <noreply@aquaclean.com>';
    const businessEmail = settings?.emailUser || 'business@aquaclean.com';
    const customerMailOptions = {
      from: fromEmail,
      to: user.email,
      subject: `¬°Tu cita en AquaClean est√° confirmada para el ${dayjs(startTime).format('DD/MM/YYYY')}!`,
      html: `<p>Hola ${user.name || 'Cliente'},</p><p>Tu cita ha sido confirmada con los siguientes detalles:</p><ul><li><strong>Servicio:</strong> ${service.name}</li><li><strong>Profesional:</strong> ${employee.name}</li><li><strong>Fecha y Hora:</strong> ${formattedDateTime}</li></ul><p>Te esperamos.</p>`,
    };
    const businessMailOptions = {
      from: fromEmail,
      to: businessEmail,
      subject: `üì¢ Nueva Reserva: ${service.name} para ${user.name}`,
      html: `<p>Nueva reserva:</p><ul><li><strong>Cliente:</strong> ${user.name} (${user.email})</li><li><strong>Servicio:</strong> ${service.name}</li><li><strong>Profesional:</strong> ${employee.name}</li><li><strong>Fecha y Hora:</strong> ${formattedDateTime}</li></ul>`,
    };
    const [customerInfo, businessInfo] = await Promise.all([
      mailTransporter.sendMail(customerMailOptions),
      mailTransporter.sendMail(businessMailOptions),
    ]);
    if (customerInfo.accepted.length > 0) { console.log('‚úÖ Email de confirmaci√≥n enviado con √©xito a:', user.email); }
    if (businessInfo.accepted.length > 0) { console.log('‚úÖ Email de notificaci√≥n enviado con √©xito a:', businessEmail); }
    const previewUrl = nodemailer.getTestMessageUrl(customerInfo);
    if (previewUrl) { console.log('üîó Vista previa (Ethereal):', previewUrl); }

    await sendWhatsAppConfirmation(appointmentDetails, customerPhone);

  } catch (error) {
    console.error('Error durante el proceso de notificaci√≥n:', error);
  }
}

async function sendAppointmentReminder(appointmentDetails: FullAppointmentDetails) {
  try {
    const mailTransporter = await getTransporter();
    const { user, services, startTime } = appointmentDetails;
    const service = services[0]?.service;
    if (!service || !user || !user.email) return;

    const formattedTime = dayjs(startTime).format('HH:mm');
    const settings = await prisma.businessSettings.findUnique({ where: { singleton: 'SINGLETON' } });
    const fromEmail = settings?.emailFrom || '"AquaClean Car Wash" <noreply@aquaclean.com>';

    const customerMailOptions = {
      from: fromEmail,
      to: user.email,
      subject: `Recordatorio: Tu cita en AquaClean es ma√±ana a las ${formattedTime}h`,
      html: `<p>Hola ${user.name || 'Cliente'},</p><p>Este es un recordatorio de tu cita para un <strong>${service.name}</strong> ma√±ana a las <strong>${formattedTime}h</strong>.</p><p>Si necesitas realizar alg√∫n cambio, por favor, ponte en contacto con nosotros.</p><p>¬°Te esperamos!</p>`,
    };

    const info = await mailTransporter.sendMail(customerMailOptions);

    if (info.accepted.length > 0) {
      console.log(`‚úÖ Email de RECORDATORIO enviado con √©xito a: ${user.email} para la cita ID: ${appointmentDetails.id}`);
    }
    const previewUrl = nodemailer.getTestMessageUrl(info);
    if (previewUrl) {
      console.log('üîó Vista previa del recordatorio (Ethereal):', previewUrl);
    }
    
  } catch (error) {
    console.error(`Error al enviar el recordatorio para la cita ID ${appointmentDetails.id}:`, error);
  }
}

// --- NUEVA FUNCI√ìN AUXILIAR PARA WHATSAPP ---
async function sendWhatsAppReviewRequest(appointmentDetails: FullAppointmentDetails, reviewUrl: string, customerPhone: string) {
  try {
    const settings = await prisma.businessSettings.findUnique({ where: { singleton: 'SINGLETON' } });
    if (!settings || !settings.twilioSid || !settings.twilioAuthToken || !settings.twilioPhoneNumber) {
      console.log('--- Faltan credenciales de Twilio. Omitiendo WhatsApp de valoraci√≥n. ---');
      return;
    }

    const client = twilio(settings.twilioSid, settings.twilioAuthToken);
    const { user } = appointmentDetails;
    const fromNumber = settings.twilioPhoneNumber;
    const toNumber = `whatsapp:${customerPhone.startsWith('+') ? customerPhone : `+34${customerPhone}`.replace(/\s+/g, '')}`;

    await client.messages.create({
      from: fromNumber,
      to: toNumber,
      body: `¬°Hola ${user.name}! üëã Esperamos que tu coche haya quedado impecable. ¬øTe importar√≠a dejarnos tu opini√≥n en 1 minuto? Tu feedback nos ayuda a mejorar. ¬°Gracias!\n\n${reviewUrl}`,
    });

    console.log(`‚úÖ WhatsApp de SOLICITUD DE VALORACI√ìN enviado con √©xito a: ${toNumber}`);
  } catch (error) {
    console.error(`Error al enviar WhatsApp de valoraci√≥n para la cita ID ${appointmentDetails.id}:`, error);
  }
}

// --- FUNCI√ìN 'sendReviewRequest' MODIFICADA ---
async function sendReviewRequest(appointmentDetails: FullAppointmentDetails, customerPhone: string) {
  try {
    const jwtSecret = process.env.JWT_SECRET;
    if (!jwtSecret) {
      console.error('No se puede generar el token de valoraci√≥n: JWT_SECRET no definido.');
      return;
    }

    // 1. Generamos un token JWT que contiene el ID de la cita y expira en 7 d√≠as
    const reviewToken = jwt.sign(
      { appointmentId: appointmentDetails.id },
      jwtSecret,
      { expiresIn: '7d' }
    );
    const reviewUrl = `http://localhost:5173/review?token=${reviewToken}`;

    const mailTransporter = await getTransporter();
    const { user, services } = appointmentDetails;
    const service = services[0]?.service;
    if (!service || !user || !user.email) return;

    const settings = await prisma.businessSettings.findUnique({ where: { singleton: 'SINGLETON' } });
    const fromEmail = settings?.emailFrom || '"AquaClean" <noreply@aquaclean.com>';
    
    console.log(`[+] Programando solicitud de valoraci√≥n para la cita ID: ${appointmentDetails.id}`);

    // 2. L√≥gica de env√≠o de Email
    const customerMailOptions = {
      from: fromEmail,
      to: user.email,
      subject: `¬°Gracias por tu visita a AquaClean! ¬øQu√© tal ha ido?`,
      html: `
        <p>Hola ${user.name || 'Cliente'},</p>
        <p>¬°Esperamos que tu coche haya quedado impecable! ‚ú®</p>
        <p>Tu opini√≥n es muy importante. ¬øTe importar√≠a dedicar un minuto a valorar tu experiencia?</p>
        <p><a href="${reviewUrl}" style="padding: 10px 15px; background-color: #228be6; color: white; text-decoration: none; border-radius: 5px;">Dejar mi valoraci√≥n</a></p>
        <p>¬°Gracias por confiar en AquaClean!</p>
      `,
    };

    const info = await mailTransporter.sendMail(customerMailOptions);
    console.log(`‚úÖ Email de SOLICITUD DE VALORACI√ìN enviado con √©xito a: ${user.email}`);
    const previewUrl = nodemailer.getTestMessageUrl(info);
    if (previewUrl) console.log('üîó Vista previa (Ethereal):', previewUrl);

    // 3. Llamamos a la nueva funci√≥n para enviar por WhatsApp
    await sendWhatsAppReviewRequest(appointmentDetails, reviewUrl, customerPhone);

  } catch (error) {
    console.error(`Error al enviar la solicitud de valoraci√≥n para la cita ID ${appointmentDetails.id}:`, error);
  }
}

export const notificationService = {
  sendBookingConfirmation,
  sendAppointmentReminder,
  sendReviewRequest,
};


// ====== [66] apps/server/src/lib/prisma.ts ======
// File: /apps/server/src/lib/prisma.ts

import { PrismaClient } from '@prisma/client';

// Se recomienda instanciar PrismaClient una sola vez en tu aplicaci√≥n.
// Esto evita agotar el n√∫mero de conexiones a la base de datos.
// https://www.prisma.io/docs/guides/performance-and-optimization/connection-management#prismaclient-in-long-running-applications

const prisma = new PrismaClient();

export default prisma;


// ====== [67] apps/server/src/server.ts ======
// File: /apps/server/src/server.ts (CONECTANDO RUTAS DEL PANEL DE CLIENTE)

import express, { Request, Response } from 'express';
import cors from 'cors';
import dotenv from 'dotenv';

// Importamos nuestros enrutadores
import servicesRouter from './api/services.routes';
import employeesRouter from './api/employees.routes';
import authRouter from './api/auth.routes';
import availabilityRouter from './api/availability.routes';
import bookingsRouter from './api/bookings.routes';
import adminAppointmentsRouter from './api/adminAppointments.routes';
import adminSettingsRouter from './api/adminSettings.routes';
import adminDateOverridesRouter from './api/adminDateOverrides.routes';
import customerAuthRouter from './api/customerAuth.routes';
import reviewsRouter from './api/reviews.routes';
import adminDashboardRouter from './api/adminDashboard.routes';
import { reminderService } from './lib/cronService';

// --- IMPORTACI√ìN A√ëADIDA ---
import customerRouter from './api/customer.routes';

// Cargar variables de entorno
dotenv.config();

const app = express();
const PORT = process.env.PORT || 3001;

// Middlewares b√°sicos
app.use(cors({ origin: process.env.CORS_ALLOWED_ORIGIN || 'http://localhost:5173' }));
app.use(express.json());

// --- RUTAS DE LA API ---

// Rutas P√∫blicas y de Autenticaci√≥n de Cliente
app.use('/api/services', servicesRouter);
app.use('/api/employees', employeesRouter);
app.use('/api/availability', availabilityRouter);
app.use('/api/bookings', bookingsRouter);
app.use('/api/customer', customerAuthRouter);
app.use('/api/reviews', reviewsRouter);

// Rutas Protegidas espec√≠ficas del Cliente Logueado
app.use('/api/me', customerRouter); // <-- RUTA A√ëADIDA

// Ruta de Autenticaci√≥n Admin
app.use('/api/auth', authRouter);

// Rutas Espec√≠ficas del Panel de Administraci√≥n
app.use('/api/admin/appointments', adminAppointmentsRouter);
app.use('/api/admin/settings', adminSettingsRouter);
app.use('/api/admin/overrides', adminDateOverridesRouter);
app.use('/api/admin/dashboard', adminDashboardRouter);

// Ruta de prueba
app.get('/api', (req: Request, res: Response) => {
  res.json({ message: 'üëã Hello from the AquaClean API!' });
});

// Iniciar el servidor
app.listen(PORT, () => {
  console.log(`üöÄ Server is running on http://localhost:${PORT}`);
  reminderService.start();
});


// ====== [68] apps/server/tsconfig.json ======
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "dist",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "noEmit": false
  },
  "include": ["src/**/*.ts", "prisma/**/*.ts"],
  "exclude": ["node_modules", "dist"]
}


// ====== [69] docs/PROJECT_SPECIFICATION.md ======
<!-- File: /docs/PROJECT_SPECIFICATION.md - v1.1 -->

# Propuesta y Especificaci√≥n del Proyecto: AquaClean Car Wash

## 1. Visi√≥n del Proyecto

Construir una aplicaci√≥n web a medida de alto rendimiento que act√∫e como el motor central del negocio. La plataforma digitalizar√° por completo la experiencia del cliente, desde la reserva hasta la valoraci√≥n, y proporcionar√° al personal herramientas de gesti√≥n avanzadas para optimizar las operaciones, automatizar el marketing y potenciar el crecimiento.

## 2. Arquitectura Tecnol√≥gica

El proyecto se construir√° sobre un stack tecnol√≥gico moderno, robusto y escalable, garantizando un desarrollo eficiente y un producto final de m√°xima calidad.

| √Årea                                     | Tecnolog√≠as                                                    |
| :--------------------------------------- | :------------------------------------------------------------- |
| **Lenguaje Principal**                   | **TypeScript**                                                 |
| **Frontend**                             | React 18, Vite, Mantine UI                                     |
| **Gesti√≥n de Estado (Frontend)**         | Zustand                                                        |
| **Backend**                              | Node.js, Express.js, Zod                                       |
| **ORM y Base de Datos**                  | Prisma, PostgreSQL                                             |
| **Testing**                              | Vitest, React Testing Library                                  |
| **Herramientas de Desarrollo y Calidad** | pnpm Monorepo, Turborepo, ESLint, Prettier, Husky, lint-staged |

## 3. Desglose Detallado de Funcionalidades

Esta secci√≥n act√∫a como un √≠ndice hacia los documentos de especificaci√≥n detallada para cada m√≥dulo del sistema.

- **Sistema de Autenticaci√≥n**
  - Flujos de registro, login (email/Google), verificaci√≥n y recuperaci√≥n de contrase√±a.
  - **[Ver especificaciones detalladas en `01-authentication.md`](./features/01-authentication.md)**

- **Sitio P√∫blico y Presentaci√≥n**
  - Detalle de las secciones p√∫blicas (Inicio, Servicios, Equipo, Valoraciones, Tarjetas Regalo).
  - **[Ver especificaciones detalladas en `02-public-site.md`](./features/02-public-site.md)**

- **Flujo de Reserva del Cliente**
  - El paso a paso detallado del proceso de reserva online.
  - **[Ver especificaciones detalladas en `03-booking-flow.md`](./features/03-booking-flow.md)**

- **Panel de Cliente**
  - Funcionalidades del √°rea de cliente (Mis Citas, Mis Veh√≠culos, Bonos, Perfil).
  - **[Ver especificaciones detalladas en `04-customer-panel.md`](./features/04-customer-panel.md)**

- **Panel de Administraci√≥n: Gesti√≥n Base**
  - Configuraci√≥n de Servicios, Empleados, Horarios y Clientes.
  - **[Ver especificaciones detalladas en `05-admin-panel-core-management.md`](./features/05-admin-panel-core-management.md)**

- **Panel de Administraci√≥n: Operaciones Diarias**
  - Herramientas del d√≠a a d√≠a (Dashboard, Planning Visual, Gesti√≥n de Citas).
  - **[Ver especificaciones detalladas en `06-admin-panel-operations.md`](./features/06-admin-panel-operations.md)**

- **Sistema de Valoraciones**
  - Flujo de solicitud de valoraciones y panel de moderaci√≥n de rese√±as.
  - **[Ver especificaciones detalladas en `07-reviews-system.md`](./features/07-reviews-system.md)**

- **M√≥dulos de Marketing y Monetizaci√≥n**
  - Gesti√≥n de bonos, programas de fidelizaci√≥n y suscripciones.
  - **[Ver especificaciones detalladas en `08-marketing-monetization.md`](./features/08-marketing-monetization.md)**

- **Sistema de Notificaciones**
  - Detalle de todos los emails y mensajes de WhatsApp autom√°ticos.
  - **[Ver especificaciones detalladas en `09-notifications-system.md`](./features/09-notifications-system.md)**

- **Integraciones Externas**
  - Especificaciones de la sincronizaci√≥n con Google Calendar y la pasarela de pago Stripe.
  - **[Ver especificaciones detalladas en `10-external-integrations.md`](./features/10-external-integrations.md)**



// ====== [70] docs/features/01-authentication.md ======
<!-- File: /docs/features/01-authentication.md - v1.0 -->
````markdown
# 1. Sistema de Autenticaci√≥n

## 1.1. Objetivo

Permitir a los usuarios crear una cuenta segura y acceder a su panel personal. Ofrecer m√©todos de registro modernos y de baja fricci√≥n para maximizar la conversi√≥n de visitante a cliente registrado, incluyendo el registro cl√°sico por email y el inicio de sesi√≥n social con Google.

## 1.2. Flujos de Usuario (User Stories)

### Registro con Email y Contrase√±a

1.  Como nuevo usuario, quiero poder hacer clic en "Registrarse".
2.  Quiero ver un formulario que me pida Nombre, Email y Contrase√±a.
3.  La contrase√±a debe tener un indicador de seguridad visual (ej: m√≠nimo 8 caracteres, una may√∫scula, un n√∫mero).
4.  Al enviar el formulario, quiero recibir un email para verificar que mi correo es real.
5.  La aplicaci√≥n debe informarme de que revise mi bandeja de entrada para completar el registro.
6.  Al hacer clic en el enlace de verificaci√≥n del email, mi cuenta se activar√° y ser√© redirigido a la p√°gina de "Inicio de Sesi√≥n".

### Registro / Inicio de Sesi√≥n con Google (OAuth)

1.  Como usuario, quiero ver un bot√≥n "Continuar con Google" en las p√°ginas de registro e inicio de sesi√≥n.
2.  Al hacer clic, quiero que se abra el pop-up de autenticaci√≥n de Google.
3.  Tras autorizar los permisos, si es mi primera vez, se debe crear una cuenta en el sistema autom√°ticamente con mi nombre y email de Google.
4.  Si ya tengo una cuenta asociada a ese email, se debe iniciar sesi√≥n.
5.  En ambos casos, debo ser redirigido a mi "Panel de Cliente" (`/dashboard`).

### Inicio de Sesi√≥n Cl√°sico

1.  Como usuario registrado, quiero poder introducir mi email y contrase√±a para acceder.
2.  Quiero una opci√≥n de "Recordar sesi√≥n" (checkbox) para no tener que iniciar sesi√≥n cada vez.
3.  Si introduzco credenciales incorrectas, quiero ver un mensaje de error claro.
4.  Quiero un enlace de "¬øHas olvidado tu contrase√±a?" por si no la recuerdo.

### Recuperaci√≥n de Contrase√±a

1.  Al hacer clic en "¬øHas olvidado tu contrase√±a?", quiero ir a una p√°gina donde introduzco mi direcci√≥n de email.
2.  Tras enviar mi email, quiero recibir un correo con un enlace seguro y de un solo uso para establecer una nueva contrase√±a.
3.  Al hacer clic en el enlace, quiero ser llevado a una p√°gina donde pueda introducir y confirmar mi nueva contrase√±a.
4.  Tras cambiarla con √©xito, quiero ser redirigido a la p√°gina de "Inicio de Sesi√≥n".

## 1.3. Componentes de UI (Vistas Necesarias)

- P√°gina de Registro: `/auth/register`
- P√°gina de Inicio de Sesi√≥n: `/auth/login`
- P√°gina de "Verifica tu Email": `/auth/verify-request` (P√°gina informativa que se muestra tras el registro).
- P√°gina de "Contrase√±a Olvidada": `/auth/forgot-password`
- P√°gina para "Restablecer Contrase√±a": `/auth/reset-password?token=[TOKEN]`

## 1.4. Modelo de Datos (Esquema Prisma)

```prisma
// Este esquema define la estructura de la base de datos para la autenticaci√≥n.
// Sigue el est√°ndar de NextAuth.js/Auth.js para m√°xima compatibilidad.

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  passwordHash  String?   // Hash de la contrase√±a para usuarios de email/pass
  image         String?
  accounts      Account[]
  sessions      Session[]
  appointments  Appointment[]
  // ... otros campos relacionados con el cliente
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String  // ej. "google"
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}
```
````

## 1.5. Endpoints de la API

- `POST /api/auth/register`: Recibe `{ name, email, password }`. Crea el usuario (inactivo), genera un token de verificaci√≥n y env√≠a el email.
- `POST /api/auth/login`: Recibe `{ email, password }`. Valida las credenciales y devuelve una sesi√≥n (cookie JWT).
- `GET /api/auth/verify-email?token=[TOKEN]`: Valida el token de email, marca `emailVerified` en la base de datos y activa la cuenta.
- `POST /api/auth/forgot-password`: Recibe `{ email }`. Genera un token de reseteo y lo env√≠a por email.
- `POST /api/auth/reset-password`: Recibe `{ token, newPassword }`. Valida el token y actualiza el `passwordHash` del usuario.
- `GET /api/auth/providers/google`: Redirige al usuario a la p√°gina de consentimiento de Google (inicia el flujo OAuth).
- `GET /api/auth/providers/google/callback`: Endpoint al que Google redirige tras la autorizaci√≥n. Procesa los datos del usuario, crea/loguea al usuario y establece la sesi√≥n.
- `POST /api/auth/logout`: Cierra la sesi√≥n del usuario.

```

```




// ====== [71] docs/features/02-public-site.md ======
<!-- File: /docs/features/02-public-site.md - v1.1 (ACTUALIZADO) -->

# 2. Sitio P√∫blico y Presentaci√≥n

## 2.1. Objetivo

Construir la cara visible del negocio. Esta √°rea debe ser visualmente atractiva, profesional, r√°pida y estar optimizada para convertir visitantes en clientes. Cada p√°gina tiene el prop√≥sito de informar, generar confianza y guiar al usuario hacia la acci√≥n principal: la reserva de una cita.

## 2.2. Desglose de P√°ginas y Secciones

### P√°gina de Inicio (`/`)

**Estado: Implementado.** La p√°gina de inicio est√° funcional y sus botones de llamada a la acci√≥n redirigen directamente al flujo de reserva (`/booking`).

**Prop√≥sito:** La primera impresi√≥n. Debe captar la atenci√≥n del usuario en segundos y comunicar el valor y la calidad del servicio.

### P√°gina de Servicios (`/services`)

**Estado: Implementado.**

**Prop√≥sito:** Actuar como un cat√°logo digital informativo. Aunque ya no es un paso obligatorio en la reserva, permite a los clientes interesados conocer en detalle los diferentes tratamientos que se han ofrecido o se podr√≠an ofrecer.

**Componentes Clave:**

- **Listado de Servicios:**
  - Una cuadr√≠cula con los servicios. Cada "tarjeta" de servicio incluye: nombre, descripci√≥n, duraci√≥n y precio.

**Datos Requeridos (API):**

- ‚úÖ `GET /api/services`

### P√°gina "Nuestro Equipo" (`/team`)

**Estado: Implementado.**

**Prop√≥sito:** Humanizar la marca y generar confianza, presentando al personal que realiza los servicios.

**Componentes Clave:**

- **Perfiles de Empleados:**
  - Una secci√≥n para cada t√©cnico con su foto, nombre, cargo y una breve biograf√≠a.
- **Llamada a la Acci√≥n:**
  - Cada perfil tiene un bot√≥n "Ver Servicios" que gu√≠a al usuario hacia el flujo de reserva.
- **(Futuro):** El bot√≥n podr√≠a evolucionar a "Reservar con [Nombre]", pre-seleccionando a ese empleado en la p√°gina de booking.

**Datos Requeridos (API):**

- ‚úÖ `GET /api/employees` (Endpoint p√∫blico).

### P√°gina de Valoraciones de Clientes (`/reviews`)

**Estado: Pendiente.**

**Prop√≥sito:** Proveer prueba social masiva y transparente, mostrando las experiencias de otros clientes.

### P√°gina de Tarjetas Regalo (`/gift-cards`)

**Estado: Pendiente.**

**Prop√≥sito:** Crear una nueva l√≠nea de ingresos permitiendo a los usuarios regalar servicios.



// ====== [72] docs/features/03-booking-flow.md ======
// ====== [58] docs/features/03-booking-flow.md ======

<!-- File: /docs/features/03-booking-flow.md - v1.3 (Funcional) -->

# 3. Flujo de Reserva del Cliente

## 3.1. Objetivo

Dise√±ar un proceso de reserva online que sea intuitivo, r√°pido y sin fricciones. El objetivo es guiar al usuario desde la selecci√≥n del profesional (opcional) hasta la confirmaci√≥n de la cita en el menor n√∫mero de pasos posible, minimizando la tasa de abandono y maximizando las conversiones.

## 3.2. Puntos de Entrada al Flujo

Un usuario puede iniciar el proceso de reserva desde m√∫ltiples puntos en la web:

- Bot√≥n "Reservar Ahora" en la p√°gina de Inicio, que dirige a `/booking`.
- Bot√≥n "Reservar Cita" en la cabecera, que dirige a `/booking`.
- (Futuro) Bot√≥n "Reservar con [Nombre]" en la p√°gina de equipo, que dirigir√° a `/booking` con el empleado ya pre-seleccionado.

## 3.3. Desglose del Proceso por Pasos

El flujo se presenta como un asistente multi-paso en la p√°gina `/booking`.

### Paso 1: Selecci√≥n de Profesional (Opcional) y Fecha/Hora

**UI/UX:**

- **Selecci√≥n de Profesional:**
  - Se muestra un selector (`Select`) que permite al usuario elegir un empleado espec√≠fico o mantener la opci√≥n por defecto: **"Cualquier Profesional"**.
- **Selecci√≥n de Fecha:**
  - Se muestra un componente de calendario (`DatePicker`).
- **Selecci√≥n de Hora:**
  - Al cargar la p√°gina (y cada vez que se cambia de profesional o de d√≠a), se realiza una llamada a la API para obtener los huecos de tiempo disponibles.
  - Se muestra una cuadr√≠cula con los "slots" de tiempo disponibles (ej: 09:00, 10:15, 11:30).
  - El usuario selecciona un slot.
- El bot√≥n "Siguiente" se activa una vez se ha seleccionado una fecha y una hora.

**L√≥gica de Negocio:**

- **Estado: Implementado.** La API de disponibilidad (`GET /api/availability`) lee el inventario de citas disponibles y funciona correctamente.

**API Calls:**

- ‚úÖ `GET /api/employees/public`
- ‚úÖ `GET /api/availability?date=[YYYY-MM-DD]`
- ‚úÖ `GET /api/availability?date=[YYYY-MM-DD]&employeeId=[ID]`

### Paso 2: Informaci√≥n Personal

**UI/UX:**

- Un formulario (`@mantine/form`) solicita los datos del cliente: Nombre, Email y N√∫mero de Tel√©fono.
- El bot√≥n "Siguiente" se activa cuando todos los campos obligatorios est√°n validados.

### Paso 3: Resumen y Confirmaci√≥n

**UI/UX:**

- Se muestra un resumen completo y claro de toda la selecci√≥n.
- El bot√≥n final es "Confirmar Reserva".

**L√≥gica de Negocio:**

- Al hacer clic en "Confirmar", se env√≠a toda la informaci√≥n a la API de creaci√≥n de reservas.
- **Estado: Implementado.** El backend busca un hueco disponible que coincida con la selecci√≥n y lo actualiza con los datos del cliente, cambiando su estado a `CONFIRMED`.

**API Calls:**

- [‚úÖ] `POST /api/bookings` <!-- L√çNEA MODIFICADA -->

## 3.4. Flujo Post-Reserva

- **P√°gina de √âxito:**
  - Funcional.
- **Notificaciones Autom√°ticas:**
  - **Estado: Implementado (base).** La l√≥gica de env√≠o est√° lista y se integra con Ethereal para simulaci√≥n.



// ====== [73] docs/features/04-customer-panel.md ======
<!-- File: /docs/features/04-customer-panel.md - v1.0 -->
# 4. Panel de Cliente

## 4.1. Objetivo

Crear un √°rea privada y segura donde los clientes registrados puedan gestionar su relaci√≥n con el negocio de forma aut√≥noma. El panel debe proporcionar un valor a√±adido que fomente el registro y la fidelizaci√≥n, ofreciendo conveniencia, control y acceso a su historial y beneficios.

## 4.2. Desglose de Secciones del Panel

El panel de cliente estar√° disponible en la ruta `/dashboard` y sub-rutas, y ser√° accesible solo para usuarios autenticados.

### Secci√≥n: Mis Citas (`/dashboard/appointments`)

**Prop√≥sito:** El centro de operaciones del cliente. Proporciona una visi√≥n completa de su historial y sus pr√≥ximas citas.

**Componentes Clave:**

- **Pesta√±as de Navegaci√≥n:** "Pr√≥ximas Citas" y "Historial de Citas".
- **Vista "Pr√≥ximas Citas":**
  - Listado de citas pendientes.
  - Cada cita mostrar√°: Fecha, Hora, Servicio(s), Empleado asignado, Precio.
  - **Acciones por Cita:**
    - **Cancelar Cita:** Bot√≥n para solicitar la cancelaci√≥n. Se aplican reglas de negocio (ej: no se puede cancelar con menos de 24h de antelaci√≥n). Un modal pedir√° confirmaci√≥n.
    - **Solicitar Cambio:** Bot√≥n que abre un modal donde el cliente puede sugerir una nueva fecha/hora. Esto enviar√° una notificaci√≥n al administrador para su aprobaci√≥n manual.
    - **A√±adir al Calendario:** Opci√≥n para descargar un archivo `.ics`.
- **Vista "Historial de Citas":**
  - Listado de citas completadas.
  - Cada cita mostrar√° la misma informaci√≥n que las pr√≥ximas.
  - **Acciones por Cita:**
    - **Reservar de Nuevo:** Bot√≥n que inicia el flujo de reserva con el mismo servicio, veh√≠culo y (si est√° disponible) empleado ya pre-seleccionados.
    - **Dejar Valoraci√≥n:** Si la cita es reciente y a√∫n no ha sido valorada, se mostrar√° un bot√≥n para escribir una rese√±a.
    - **Ver Factura:** (Opcional, futuro) Enlace para ver/descargar la factura del servicio.

**API Calls:**

- `GET /api/me/appointments?status=upcoming`
- `GET /api/me/appointments?status=completed`
- `POST /api/me/appointments/[id]/cancel`
- `POST /api/me/appointments/[id]/reschedule-request`

### Secci√≥n: Mis Veh√≠culos (`/dashboard/vehicles`)

**Prop√≥sito:** Agilizar el proceso de reserva permitiendo al cliente guardar y gestionar la informaci√≥n de sus coches.

**Componentes Clave:**

- **Listado de Veh√≠culos Guardados:**
  - Una vista de "tarjetas" con cada veh√≠culo.
  - Cada tarjeta mostrar√°: Alias (ej: "Mi Coche"), Marca, Modelo y Tama√±o.
- **Acciones:**
  - **A√±adir Nuevo Veh√≠culo:** Bot√≥n que abre un formulario modal para introducir los datos de un nuevo coche.
  - **Editar/Eliminar:** Opciones en cada tarjeta para modificar los datos o eliminar el veh√≠culo del perfil.

**API Calls:**

- `GET /api/me/vehicles`
- `POST /api/me/vehicles`
- `PUT /api/me/vehicles/[id]`
- `DELETE /api/me/vehicles/[id]`

### Secci√≥n: Mis Bonos y Beneficios (`/dashboard/benefits`)

**Prop√≥sito:** Dar visibilidad sobre los programas de fidelizaci√≥n y los productos comprados, incentivando su uso.

**Componentes Clave:**

- **Secci√≥n de Bonos:**
  - Si el cliente ha comprado bonos (ej: "Bono 5 Lavados Premium"), se listar√°n aqu√≠.
  - Cada bono mostrar√°: Nombre del bono, Servicios restantes (ej: "3 de 5 restantes"), Fecha de caducidad (si aplica).
- **Secci√≥n de Puntos de Fidelizaci√≥n:**
  - Visualizaci√≥n de los puntos acumulados.
  - Informaci√≥n sobre c√≥mo canjear los puntos (ej: "500 puntos = 1 Lavado B√°sico Gratis").

**API Calls:**

- `GET /api/me/benefits`

### Secci√≥n: Mi Perfil (`/dashboard/profile`)

**Prop√≥sito:** Permitir al usuario mantener su informaci√≥n personal actualizada.

**Componentes Clave:**

- **Formulario de Datos Personales:**
  - Campos para editar: Nombre, Apellido, N√∫mero de Tel√©fono.
  - El email se mostrar√° pero no ser√° editable por ser el identificador principal de la cuenta.
- **Formulario de Cambio de Contrase√±a:**
  - Campos para: Contrase√±a Actual, Nueva Contrase√±a, Confirmar Nueva Contrase√±a.
  - (Este formulario solo ser√° visible para usuarios registrados con email/contrase√±a, no para los de OAuth).
- **Gesti√≥n de Notificaciones:**
  - Checkboxes para que el usuario elija sus preferencias (ej: "Recibir recordatorios por WhatsApp", "Recibir ofertas por email").

**API Calls:**

- `PUT /api/me/profile`
- `POST /api/me/change-password`




// ====== [74] docs/features/05-admin-panel-core-management.md ======
<!-- File: /docs/features/05-admin-panel-core-management.md - v1.2 (Actualizado con Anulaciones por Fecha) -->

# 5. Panel de Administraci√≥n: Gesti√≥n de la Configuraci√≥n Base

## 5.1. Objetivo

Proporcionar al administrador del negocio un control total sobre las entidades fundamentales de la plataforma. Esta secci√≥n se centra en la configuraci√≥n "maestra" que define c√≥mo opera el negocio: qu√© servicios se ofrecen, qui√©n trabaja, cu√°ndo trabajan y cu√°ndo descansan.

## 5.2. Desglose de Secciones

Estas secciones estar√°n bajo la ruta `/admin` y requerir√°n un rol de "Administrador".

### Secci√≥n: Gesti√≥n de Servicios (`/admin/services`)

**Estado: Implementado.** Se ha implementado un CRUD completo para el cat√°logo de servicios.

**Prop√≥sito:** Gestionar los servicios que ofrece el negocio.

**Componentes Clave:**

- **Vista de Listado:**
  - Una tabla que lista todos los servicios creados.
  - Columnas: Nombre, Duraci√≥n, Precio, **Estado (Activo/Inactivo)**.
  - Acciones por fila: "Editar", "Eliminar" (con modal de confirmaci√≥n y protecci√≥n contra borrado si hay citas asociadas).
  - Un `Switch` para cambiar r√°pidamente el estado `Activo/Inactivo` de un servicio.
- **Formulario de Creaci√≥n/Edici√≥n (en un Modal):**
  - Campos para: Nombre, Descripci√≥n, Duraci√≥n (en minutos), Precio, Categor√≠a y Estado.

**API Calls:**

- ‚úÖ `GET /api/services`
- ‚úÖ `POST /api/services`
- ‚úÖ `PUT /api/services/[id]`
- ‚úÖ `DELETE /api/services/[id]` (con l√≥gica de protecci√≥n).

### Secci√≥n: Gesti√≥n de Empleados y Horarios (`/admin/employees`)

**Estado: Implementado.** Se ha implementado una gesti√≥n avanzada de los empleados y su disponibilidad.

**Prop√≥sito:** Gestionar los perfiles del personal y, fundamentalmente, sus horarios de trabajo y ausencias, que son la base del sistema de disponibilidad.

**Componentes Clave:**

- **Vista de Listado:**
  - Una tabla con todos los empleados, filtrable por estado **(Activos/Archivados)**.
  - Acciones por fila: "Editar", "Archivar" y "Reactivar".
- **Modal de Edici√≥n Avanzado (con Pesta√±as):**
  - **Pesta√±a "Perfil":** Formulario para datos b√°sicos (Nombre, Email, Rol, Foto, Bio).
  - **Pesta√±a "Horario Laboral":**
    - Un editor visual para los 7 d√≠as de la semana.
    - Permite definir **m√∫ltiples turnos de trabajo por d√≠a** (ej: para configurar pausas de almuerzo).
  - **Pesta√±a "Ausencias y Vacaciones":**
    - Un calendario para a√±adir y visualizar bloqueos de d√≠as completos (vacaciones, bajas, etc.).
    - **Sistema de Detecci√≥n de Conflictos:** Si se intenta programar una ausencia en fechas donde el empleado ya tiene citas, el sistema lo notifica y muestra un modal para resolver el conflicto.

**API Calls:**

- ‚úÖ `GET /api/employees?status=[STATUS]`
- ‚úÖ `POST /api/employees`
- ‚úÖ `PUT /api/employees/[id]` (para perfil, horario y estado).
- ‚úÖ `GET /api/employees/[id]/absences`
- ‚úÖ `POST /api/employees/[id]/absences` (con l√≥gica de detecci√≥n de conflictos).
- ‚úÖ `DELETE /api/employees/[id]/absences/[id]`

### Secci√≥n: Configuraci√≥n del Negocio (`/admin/settings`)

**Estado: Implementado.**

**Prop√≥sito:** Un panel centralizado para gestionar las configuraciones globales y las excepciones del horario del negocio.

**Componentes Clave:**

- **Selecci√≥n del Servicio por Defecto:**
  - ‚úÖ Un `Select` que permite elegir cu√°l de los servicios **activos** se ofrecer√° a los clientes.
- **Formulario de Horario Semanal Est√°ndar:**
  - ‚úÖ Una interfaz visual (`ScheduleEditor`) para definir las horas de apertura y cierre recurrentes para cada d√≠a de la semana.
- **Gesti√≥n de Anulaciones por Fecha:**
  - ‚úÖ Una interfaz de calendario que permite anular el horario est√°ndar para fechas espec√≠ficas.
  - ‚úÖ Soporte para **Cierres de D√≠a Completo** (ej: festivos nacionales).
  - ‚úÖ Soporte para **Horarios Especiales** (ej: jornada reducida para un d√≠a concreto).
  - ‚úÖ Sistema de detecci√≥n de conflictos que avisa si se intenta modificar un d√≠a con citas ya programadas.

**API Calls:**

- ‚úÖ `GET /api/admin/settings` (para el horario y servicio por defecto).
- ‚úÖ `PUT /api/admin/settings`
- ‚úÖ `GET /api/admin/overrides` (para las anulaciones de fecha).
- ‚úÖ `POST /api/admin/overrides` (con l√≥gica de detecci√≥n de conflictos).
- ‚úÖ `DELETE /api/admin/overrides/[id]`

### Secci√≥n: Gesti√≥n de Clientes (`/admin/clients`)

**Estado: Pendiente.**

**Prop√≥sito:** Un CRM (Customer Relationship Management) simple para tener una visi√≥n 360 de cada cliente.



// ====== [75] docs/features/06-admin-panel-operations.md ======
<!-- File: /docs/features/06-admin-panel-operations.md - v1.2 (ACTUALIZADO) -->

# 6. Panel de Administraci√≥n: Operaciones Diarias

## 6.1. Objetivo

Equipar al administrador con las herramientas interactivas necesarias para la gesti√≥n del d√≠a a d√≠a del lavadero. Esta secci√≥n se enfoca en la visualizaci√≥n de la actividad, la manipulaci√≥n de la agenda y el seguimiento de cada cita de forma individual. Es el centro neur√°lgico para las operaciones en tiempo real.

## 6.2. Desglose de Secciones

### Secci√≥n: Dashboard de Anal√≠ticas (`/admin/dashboard`)

**Prop√≥sito:** La p√°gina de inicio del panel de administraci√≥n. Debe proporcionar una instant√°nea clara y r√°pida de la salud y la actividad del negocio.

**Componentes Clave:**

- **Tarjetas de KPIs (Indicadores Clave de Rendimiento):**
  - **Citas para Hoy:** N√∫mero total de citas programadas para el d√≠a actual.
  - **Ingresos del D√≠a:** Suma de los precios de las citas de hoy.
  - **Ocupaci√≥n Semanal:** Porcentaje de horas reservadas frente a horas disponibles para la semana en curso.
  - **Nuevos Clientes (Mes):** N√∫mero de clientes que se han registrado este mes.
- **Gr√°ficos Visuales (`Chart.js`):**
  - **Reservas por D√≠a:** Un gr√°fico de barras mostrando el n√∫mero de citas para cada d√≠a de la √∫ltima semana.
  - **Servicios M√°s Populares:** Un gr√°fico de tarta o de barras mostrando el top 5 de servicios m√°s reservados en los √∫ltimos 30 d√≠as.
- **Actividad Reciente:**
  - Un listado de las 5-10 pr√≥ximas citas del d√≠a.
  - Un feed de las √∫ltimas acciones importantes (ej: "Juan P√©rez ha cancelado su cita", "Nuevo cliente registrado: Mar√≠a L√≥pez").

**API Calls:**

- `GET /api/admin/dashboard/kpis`
- `GET /api/admin/dashboard/charts`
- `GET /api/admin/dashboard/activity`

### Secci√≥n: Planning Visual (Calendario) (`/admin/planning`)

**Prop√≥sito:** La herramienta m√°s importante para la gesti√≥n de la agenda. Permite una visualizaci√≥n clara de la carga de trabajo y una manipulaci√≥n r√°pida de las citas.

**Componentes Clave:**

- **Integraci√≥n de `FullCalendar`:**
  - **Estado: Implementado.** Se ha integrado la librer√≠a `FullCalendar` con los plugins `resourceTimeline`, `dayGrid`, `timeGrid` e `interaction`.
  - **Vista Semanal por Empleado (Resource Timeline):** Es la vista por defecto. Muestra los d√≠as de la semana en el eje X y los empleados como "recursos" en el eje Y. Las citas aparecen como bloques en la fila del empleado correspondiente.
  - **Otras Vistas:** Botones para cambiar a vista de D√≠a (`resourceTimelineDay`) o Mes (`dayGridMonth`).
  - **Navegaci√≥n:** Flechas para avanzar y retroceder por semanas/d√≠as.
- **Interactividad:**
  - **[‚úÖ] Reagendar y Reasignar (Drag & Drop):** El administrador puede arrastrar una cita a otra hora/d√≠a para reagendarla, o a la fila de otro empleado para reasignarla. Los cambios se guardan autom√°ticamente en la base de datos.
  - **[‚úÖ] Crear Cita Manualmente:** Al hacer clic en un hueco vac√≠o del calendario, se abre un modal para crear una nueva cita (ideal para reservas telef√≥nicas), pre-rellenando el empleado y la hora de inicio.
  - **[‚úÖ] Ver/Editar/Anular Cita:** Al hacer clic en una cita existente, se abre un modal con todos los detalles, permitiendo su edici√≥n completa (cambiar servicio, datos del cliente, etc.) y ofreciendo la opci√≥n de anular la cita (con un modal de confirmaci√≥n).
- **C√≥digo de Colores:** (Futuro) Las citas pueden tener colores diferentes seg√∫n su estado (ej: Azul para confirmadas, Verde para completadas, Gris para canceladas).

**API Calls:**

- ‚úÖ `GET /api/admin/appointments?start=[DATE]&end=[DATE]` (FullCalendar llama a esta API para obtener los eventos).
- ‚úÖ `PUT /api/admin/appointments/[id]` (Se llama a esta API al soltar una cita despu√©s de arrastrarla y para guardar ediciones desde el modal).
- ‚úÖ `POST /api/admin/appointments` (Para crear citas manualmente desde el modal).
- ‚úÖ `DELETE /api/admin/appointments/[id]` (Para anular citas desde el modal).

### Secci√≥n: Gesti√≥n de Citas (`/admin/appointments`)

**Prop√≥sito:** Proporcionar una vista de tabla detallada de todas las citas, con potentes herramientas de b√∫squeda y filtrado para encontrar y gestionar cualquier reserva espec√≠fica.

**Componentes Clave:**

- **Tabla de Datos Avanzada (`Mantine Data Table`):**
  - **B√∫squeda Global:** Un campo de b√∫squeda para encontrar citas por nombre del cliente, email, tel√©fono o servicio.
  - **Filtros Avanzados:** Dropdowns para filtrar por:
    - Rango de Fechas.
    - Empleado.
    - Estado de la Cita (Confirmada, Completada, Cancelada, Pendiente de Pago, etc.).
- **Columnas de la Tabla:**
  - ID de Cita, Cliente, Servicio(s), Fecha y Hora, Empleado, Duraci√≥n, Precio, Estado.
- **Acciones por Fila:**
  - **Ver Detalles:** Abre el mismo panel/modal que desde el calendario.
  - **Cambiar Estado:** Un dropdown para cambiar r√°pidamente el estado de una cita (ej: marcar como "Completada" al finalizar el servicio).
  - **Reenviar Email de Confirmaci√≥n:** Un bot√≥n para volver a enviar la notificaci√≥n al cliente.
  - **Gestionar Pago:** Ver el estado del pago de Stripe y realizar acciones (ej: registrar un pago en efectivo si fuera el caso).

**API Calls:**

- `GET /api/admin/appointments` (con todos los par√°metros de b√∫squeda y filtrado).
- `PUT /api/admin/appointments/[id]/status`



// ====== [76] docs/features/07-reviews-system.md ======
<!-- File: /docs/features/07-reviews-system.md - v1.0 -->
````markdown
# 7. Sistema de Valoraciones y Rese√±as

## 7.1. Objetivo

Implementar un ciclo de feedback completo que permita recopilar valoraciones de los clientes de forma automatizada y utilizar esas rese√±as como una potente herramienta de marketing y prueba social. El sistema debe dar al administrador control total sobre qu√© valoraciones se muestran p√∫blicamente.

## 7.2. Flujo del Cliente para Dejar una Valoraci√≥n

El proceso est√° dise√±ado para ser lo m√°s simple y proactivo posible, maximizando la tasa de respuesta.

1.  **Disparador (Trigger):** Un administrador cambia el estado de una cita a "Completada" en el panel de administraci√≥n.
2.  **Espera Programada:** El sistema espera un tiempo configurable (ej: 3 horas) para dar tiempo al cliente a disfrutar del resultado antes de pedirle una opini√≥n.
3.  **Notificaci√≥n Autom√°tica:** Pasado el tiempo de espera, se env√≠a un email y/o un mensaje de WhatsApp al cliente.
    - El mensaje agradece su visita.
    - Incluye una llamada a la acci√≥n clara, como "Valora tu experiencia en 1 minuto".
    - Proporciona dos enlaces:
      - **Enlace principal:** Un link seguro, √∫nico y de un solo uso que dirige a la p√°gina de valoraci√≥n del propio sitio web.
      - **Enlace secundario (opcional):** Un enlace directo para dejar una rese√±a en el perfil de Google Business de la empresa.
4.  **P√°gina de Valoraci√≥n:**
    - Al hacer clic en el enlace principal, el usuario llega a una p√°gina simple y sin distracciones.
    - La p√°gina ya sabe de qu√© cita se trata gracias al token en la URL.
    - **Formulario:**
      - **Calificaci√≥n General (Estrellas):** Un selector de 1 a 5 estrellas (obligatorio).
      - **Comentario:** Un √°rea de texto para que el cliente escriba su opini√≥n (opcional).
      - **Calificaci√≥n del Empleado (Opcional):** Si se desea, se puede a√±adir un segundo selector de estrellas para valorar espec√≠ficamente al t√©cnico que le atendi√≥.
    - **Env√≠o:** Al enviar, la valoraci√≥n se guarda en la base de datos con el estado inicial de **"Pendiente"**.

## 7.3. Panel de Moderaci√≥n para el Administrador (`/admin/reviews`)

**Prop√≥sito:** Dar al due√±o del negocio el control total sobre la reputaci√≥n online que se muestra en su propia web.

**Componentes Clave:**

- **Vista Principal:**
  - Una vista de "bandeja de entrada" con todas las valoraciones recibidas, ordenadas por fecha (las m√°s recientes primero).
  - Filtros para ver rese√±as por estado: "Pendientes", "Aprobadas", "Ocultas".
- **Tarjeta de Valoraci√≥n Individual:**
  - Cada valoraci√≥n pendiente se muestra claramente con toda su informaci√≥n:
    - Nombre del Cliente.
    - Servicio recibido.
    - Empleado que lo atendi√≥.
    - Fecha de la cita.
    - Calificaci√≥n en estrellas.
    - Texto completo del comentario.
- **Acciones de Moderaci√≥n:**
  - **Aprobar:** Cambia el estado a "Aprobada". La valoraci√≥n ser√° ahora visible en las secciones p√∫blicas de la web.
  - **Ocultar:** Cambia el estado a "Oculta". La valoraci√≥n se guarda para registros internos y anal√≠ticas, pero **no ser√° visible p√∫blicamente**. No se elimina.
  - **Destacar (Checkbox/Toggle):** Una opci√≥n adicional en las rese√±as aprobadas para marcarlas como "Destacadas" y que aparezcan en la p√°gina de inicio.

## 7.4. Modelo de Datos (Esquema Prisma)

```prisma
model Review {
  id            String      @id @default(cuid())
  rating        Int         // Calificaci√≥n de 1 a 5
  comment       String?     @db.Text
  status        ReviewStatus @default(PENDING) // PENDING, APPROVED, HIDDEN
  isFeatured    Boolean     @default(false)    // Para la homepage

  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  // Relaciones
  appointment   Appointment @relation(fields: [appointmentId], references: [id])
  appointmentId String      @unique // Cada cita solo puede tener una rese√±a

  user          User        @relation(fields: [userId], references: [id])
  userId        String

  employee      Employee    @relation(fields: [employeeId], references: [id])
  employeeId    String
}

enum ReviewStatus {
  PENDING
  APPROVED
  HIDDEN
}
```
````

## 7.5. Endpoints de la API

- `GET /api/reviews/request?token=[TOKEN]`: Valida el token de un solo uso y muestra la p√°gina/formulario para dejar la valoraci√≥n.
- `POST /api/reviews?token=[TOKEN]`: Endpoint para que el cliente env√≠e su valoraci√≥n. Valida el token antes de guardar los datos.
- `GET /api/reviews`: Endpoint p√∫blico que devuelve todas las rese√±as con estado "APROBADA" para las p√°ginas `/reviews` y la homepage. Permite filtrar por empleado y servicio.
- `GET /api/admin/reviews`: Endpoint protegido para que el administrador obtenga todas las rese√±as, incluyendo las pendientes y ocultas.
- `PUT /api/admin/reviews/[id]`: Endpoint protegido para que el administrador actualice el estado (`status`) o la propiedad `isFeatured` de una rese√±a.

```

```




// ====== [77] docs/features/08-marketing-monetization.md ======
<!-- File: /docs/features/08-marketing-monetization.md - v1.0 -->
````markdown
# 8. M√≥dulos de Marketing y Monetizaci√≥n

## 8.1. Objetivo

Crear un conjunto de herramientas integradas en la plataforma para diversificar las fuentes de ingresos, aumentar el valor de vida del cliente (LTV) y fomentar la lealtad a la marca. Estos m√≥dulos transforman la web de una simple herramienta de reservas a una plataforma de crecimiento para el negocio.

## 8.2. Desglose de M√≥dulos

### M√≥dulo 1: Gesti√≥n de Bonos (Bundles)

**Prop√≥sito:** Incentivar la compra por adelantado de m√∫ltiples servicios a un precio reducido, asegurando ingresos y visitas futuras.

**Funcionalidad en el Panel de Administraci√≥n (`/admin/marketing/bonuses`):**

- **CRUD de Bonos:** Interfaz para crear, editar y desactivar ofertas de bonos.
- **Formulario de Creaci√≥n/Edici√≥n:**
  - **Nombre del Bono:** Ej: "Bono 5 Lavados Premium".
  - **Servicio Asociado:** Selecci√≥n de un √∫nico servicio del cat√°logo.
  - **Cantidad de Usos:** Ej: 5.
  - **Precio Total:** Precio con descuento por el paquete completo.
  - **Periodo de Validez (Opcional):** Ej: "V√°lido por 12 meses desde la compra".
  - **Estado:** Activo / Inactivo.

**Experiencia del Cliente:**

- Una secci√≥n en el sitio p√∫blico para comprar estos bonos.
- El pago se realiza a trav√©s de Stripe.
- En su "Panel de Cliente", el usuario puede ver sus bonos activos y los usos restantes.
- Durante el flujo de reserva, si el cliente elige un servicio para el que tiene un bono con usos disponibles, el sistema le ofrecer√° la opci√≥n de "Usar 1 cr√©dito del bono" en lugar de pagar.

**Modelo de Datos (Prisma):**

```prisma
// Definici√≥n del bono que se puede comprar
model BonusOffering {
  id          String   @id @default(cuid())
  name        String
  price       Float
  uses        Int
  validityDays Int?
  isActive    Boolean  @default(true)

  service     Service  @relation(fields: [serviceId], references: [id])
  serviceId   String
}

// Instancia de un bono comprado por un cliente
model PurchasedBonus {
  id              String   @id @default(cuid())
  usesRemaining   Int
  expiresAt       DateTime?

  user            User     @relation(fields: [userId], references: [id])
  userId          String

  bonusOffering   BonusOffering @relation(fields: [bonusOfferingId], references: [id])
  bonusOfferingId String
}
```
````

### M√≥dulo 2: Tarjetas Regalo (Gift Cards)

**Prop√≥sito:** Abrir una nueva v√≠a de ingresos permitiendo que los servicios del lavadero sean regalados, ideal para ocasiones especiales.

**Funcionalidad en el Panel de Administraci√≥n:**

- No requiere gesti√≥n activa m√°s all√° de tener los servicios marcados como "regalables".
- Una secci√≥n para visualizar las tarjetas regalo vendidas y su estado (canjeada/no canjeada).

**Experiencia del Cliente (Comprador y Receptor):**

- P√°gina p√∫blica `/gift-cards` para la compra.
- El comprador elige un servicio, introduce los datos del destinatario y un mensaje personalizado.
- Tras el pago con Stripe, el sistema genera un **c√≥digo de regalo √∫nico**.
- Se env√≠a un email al destinatario (o al comprador) con un dise√±o de tarjeta regalo digital que incluye el c√≥digo.
- El receptor de la tarjeta puede canjear el c√≥digo durante el paso de pago del flujo de reserva, lo que aplicar√° un descuento del 100%.

**Modelo de Datos (Prisma):**

```prisma
model GiftCard {
  id            String    @id @default(cuid())
  code          String    @unique // C√≥digo alfanum√©rico √∫nico
  isRedeemed    Boolean   @default(false)
  redeemedAt    DateTime?
  recipientEmail String?
  message       String?   @db.Text

  // Relaciones
  service       Service   @relation(fields: [serviceId], references: [id])
  serviceId     String

  purchaseOrder Order     @relation(fields: [orderId], references: [id])
  orderId       String
}
```

### M√≥dulo 3: Suscripciones (Club de Lavado)

**Prop√≥sito:** Generar ingresos mensuales recurrentes y predecibles, creando una base de clientes de alta fidelidad.

**Funcionalidad en el Panel de Administraci√≥n (`/admin/marketing/subscriptions`):**

- **CRUD de Planes de Suscripci√≥n:**
  - **Nombre del Plan:** Ej: "Club AquaClean Oro".
  - **Precio Mensual:** Ej: 49.99‚Ç¨.
  - **Beneficios Incluidos:**
    - Una interfaz para definir cu√°ntos usos de qu√© servicios incluye al mes (ej: "2 Lavados Premium", "4 Lavados B√°sicos").
  - **Integraci√≥n con Stripe Products & Prices** para gestionar la facturaci√≥n recurrente.

**Experiencia del Cliente:**

- P√°gina p√∫blica `/club` para ver y suscribirse a los planes.
- El pago mensual es autom√°tico a trav√©s de Stripe.
- En su panel, el cliente ve su estado de suscripci√≥n y los servicios que puede usar ese mes.
- Al igual que con los bonos, al reservar un servicio incluido en su plan, puede canjearlo sin coste adicional.

### M√≥dulo 4: Programa de Fidelizaci√≥n (Puntos)

**Prop√≥sito:** Recompensar la recurrencia, incentivando a los clientes a volver para acumular beneficios.

**Funcionalidad en el Panel de Administraci√≥n (`/admin/marketing/loyalty`):**

- **Configuraci√≥n del Programa:**
  - Definir la regla de acumulaci√≥n (ej: "1‚Ç¨ gastado = 1 punto").
  - Definir las recompensas (ej: "500 puntos = 1 Lavado B√°sico Gratis").
- El sistema asignar√° los puntos autom√°ticamente despu√©s de cada cita completada.

**Experiencia del Cliente:**

- En su panel (`/dashboard/benefits`), el cliente ve su saldo de puntos.
- El cliente es notificado cuando alcanza los puntos necesarios para una recompensa.
- Se le proporciona un c√≥digo de descuento o una opci√≥n en el flujo de reserva para canjear su recompensa.

## 8.3. Endpoints de la API

- `GET /api/bonuses`: Devuelve los bonos disponibles para la compra.
- `POST /api/bonuses/purchase`: Inicia la compra de un bono.
- `POST /api/gift-cards/purchase`: Inicia la compra de una tarjeta regalo.
- `POST /api/bookings/redeem`: Endpoint para canjear bonos, tarjetas regalo o puntos durante la reserva.
- `GET /api/admin/marketing/...`: Endpoints protegidos para toda la gesti√≥n de estos m√≥dulos.

```

```




// ====== [78] docs/features/09-notifications-system.md ======
<!-- File: /docs/features/09-notifications-system.md - v1.0 -->
# 9. Sistema de Notificaciones

## 9.1. Objetivo

Establecer un sistema de comunicaci√≥n proactivo y automatizado para mantener informados tanto a los clientes como al personal del negocio en cada etapa clave del ciclo de vida de una cita. Los objetivos principales son: mejorar la experiencia del cliente, reducir dr√°sticamente la tasa de no presentaci√≥n (no-shows) y minimizar la carga de trabajo administrativo.

## 9.2. Stack Tecnol√≥gico

| Canal        | Tecnolog√≠a                 | Prop√≥sito                                                                                                                                                   |
| :----------- | :------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Email**    | **Nodemailer**             | Env√≠o de correos electr√≥nicos transaccionales robustos. Se utilizar√°n plantillas HTML (ej: `mjml` o `react-email`) para un dise√±o profesional y responsivo. |
| **WhatsApp** | **Twilio API (o similar)** | Env√≠o de mensajes de WhatsApp para notificaciones de alta prioridad como recordatorios y confirmaciones.                                                    |

## 9.3. Notificaciones para el Cliente

Estas notificaciones se env√≠an al cliente para guiarlo y mantenerlo informado.

| Evento Desencadenante                | Canal(es)       | Contenido Clave                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| :----------------------------------- | :-------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **Registro de Nueva Cuenta**         | Email           | **Asunto:** "Confirma tu cuenta en AquaClean".<br>Contiene un enlace de verificaci√≥n √∫nico y de un solo uso para activar la cuenta.                                                                                                                                                                                                                                                                                                                                             |
| **Solicitud de Contrase√±a Olvidada** | Email           | **Asunto:** "Restablece tu contrase√±a de AquaClean".<br>Contiene un enlace seguro para que el usuario pueda establecer una nueva contrase√±a.                                                                                                                                                                                                                                                                                                                                    |
| **Reserva de Cita Exitosa**          | Email, WhatsApp | **Asunto (Email):** "Tu cita en AquaClean est√° confirmada para el [Fecha] a las [Hora]".<br> **Mensaje (WhatsApp):** "¬°Hola [Nombre]! üëã Tu cita en AquaClean para un [Servicio] el [Fecha] a las [Hora] est√° confirmada. ¬°Te esperamos!".<br>El email **debe** incluir un archivo adjunto `.ics` para que el cliente pueda a√±adir la cita a su calendario (Google, Apple, etc.) con un solo clic. Tambi√©n incluir√° un resumen completo: servicio, empleado, direcci√≥n y coste. |
| **Recordatorio de Cita (24h antes)** | Email, WhatsApp | **Asunto (Email):** "Recordatorio: Tu cita en AquaClean es ma√±ana".<br> **Mensaje (WhatsApp):** "¬°Recordatorio! Ma√±ana a las [Hora] tienes tu cita para un [Servicio] en AquaClean. Si necesitas cambiarla, cont√°ctanos. ¬°Nos vemos pronto!".<br>Incluye opciones para confirmar la asistencia o contactar para reagendar.                                                                                                                                                      |
| **Cancelaci√≥n de Cita**              | Email           | **Asunto:** "Tu cita en AquaClean ha sido cancelada".<br>Confirma que la cita para el [Fecha] ha sido cancelada correctamente. Si aplica, informa sobre la pol√≠tica de reembolso.                                                                                                                                                                                                                                                                                               |
| **Cita Marcada como "Completada"**   | Email, WhatsApp | **Asunto (Email):** "¬°Gracias por tu visita a AquaClean! ¬øQu√© tal ha ido?".<br> **Mensaje (WhatsApp):** "¬°Gracias por visitarnos, [Nombre]! Esperamos que tu coche haya quedado impecable ‚ú®. ¬øTe importar√≠a dejarnos tu opini√≥n en 1 minuto? [Enlace a la p√°gina de valoraci√≥n]".<br>Se env√≠a tras un lapso de tiempo configurable (ej: 3 horas). Contiene el enlace para dejar una rese√±a en la web y/o en Google.                                                            |

## 9.4. Notificaciones para la Empresa (Administrador)

Estas notificaciones se env√≠an al personal para mantenerlos al tanto de la actividad de los clientes en tiempo real.

| Evento Desencadenante             | Canal(es)       | Contenido Clave                                                                                                                                                                                                                                                                                                                                     |
| :-------------------------------- | :-------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Nueva Reserva Realizada**       | Email, WhatsApp | **Asunto (Email):** "Nueva Reserva: [Servicio] para el [Fecha] a las [Hora]".<br> **Mensaje (WhatsApp):** "üîî ¬°Nueva Reserva! Cliente: [Nombre Cliente]. Servicio: [Servicio]. D√≠a: [Fecha] a las [Hora]. Empleado: [Nombre Empleado]".<br>Proporciona todos los detalles de la nueva cita para una visi√≥n r√°pida sin necesidad de entrar al panel. |
| **Cliente Cancela una Cita**      | Email, WhatsApp | **Asunto (Email):** "Cancelaci√≥n de Cita: [Nombre Cliente] para el [Fecha]".<br> **Mensaje (WhatsApp):** "‚ö†Ô∏è Cancelaci√≥n. El cliente [Nombre Cliente] ha cancelado su cita para el [Fecha] a las [Hora]".<br>Permite al administrador reaccionar r√°pidamente y, si es necesario, contactar a otros clientes para ocupar el hueco.                   |
| **Cliente Solicita Cambiar Cita** | Email           | **Asunto:** "Solicitud de Cambio de Cita de [Nombre Cliente]".<br>Informa al administrador que un cliente ha solicitado un cambio y le dirige al panel de administraci√≥n para gestionar la petici√≥n.                                                                                                                                                |

## 9.5. Implementaci√≥n en el Backend

- Se crear√° un `NotificationService` centralizado en el backend.
- Este servicio ser√° invocado por otros servicios de la aplicaci√≥n (ej: `BookingService`, `AuthService`) cuando ocurran los eventos relevantes.
- El `NotificationService` contendr√° la l√≥gica para:
  1.  Seleccionar la plantilla de mensaje adecuada (para email o WhatsApp).
  2.  Rellenar la plantilla con los datos din√°micos (nombre del cliente, fecha de la cita, etc.).
  3.  Invocar al proveedor correspondiente (`Nodemailer` o `Twilio`) para realizar el env√≠o.
- Se implementar√° un sistema de colas (opcional pero recomendado para escalar) para procesar los env√≠os de notificaciones de forma as√≠ncrona, evitando que la aplicaci√≥n se ralentice mientras espera la respuesta de las APIs externas.




// ====== [79] docs/features/10-external-integrations.md ======
<!-- File: /docs/features/10-external-integrations.md - v1.0 -->
````markdown
# 10. Integraciones Externas

## 10.1. Objetivo

Integrar la plataforma con servicios de terceros l√≠deres en su sector para incorporar funcionalidades cr√≠ticas de forma robusta y segura. Esto nos permite centrarnos en el valor a√±adido de nuestra aplicaci√≥n mientras delegamos tareas complejas como el procesamiento de pagos y la sincronizaci√≥n de calendarios a APIs especializadas.

## 10.2. Pasarela de Pagos: Stripe

**Prop√≥sito:** Gestionar todas las transacciones monetarias de la plataforma, desde citas individuales hasta la compra de bonos y suscripciones recurrentes.

### Funcionalidades Clave

- **Procesamiento de Pagos √önicos:** Aceptar pagos con tarjeta de cr√©dito/d√©bito para reservas de citas y compra de tarjetas regalo.
- **Gesti√≥n de Suscripciones:** Automatizar los cobros mensuales para los clientes del "Club de Lavado" a trav√©s de **Stripe Billing**.
- **Seguridad y Cumplimiento PCI:** Delegar el manejo de la informaci√≥n sensible de las tarjetas a Stripe, asegurando el m√°ximo nivel de seguridad y cumplimiento normativo.
- **Portal de Cliente de Stripe (Opcional):** Permitir a los clientes suscritos gestionar sus m√©todos de pago y facturas directamente a trav√©s de un portal alojado por Stripe.

### Flujo de Implementaci√≥n

1.  **Configuraci√≥n:**

    - Se crear√°n cuentas de Producto y Precio en el dashboard de Stripe para cada servicio, bono y plan de suscripci√≥n.
    - Las claves de API (p√∫blica y secreta) de Stripe se configurar√°n en las variables de entorno del backend.

2.  **Flujo de Pago √önico (para Citas/Regalos):**

    - **Frontend:**
      - Se utilizar√° la librer√≠a `@stripe/react-stripe-js`.
      - Al llegar al paso de pago, el cliente solicitar√° un `client_secret` a nuestra API.
      - Se renderizar√° el componente `PaymentElement` de Stripe, que es un formulario de pago seguro y unificado.
    - **Backend:**
      - Se crear√° un endpoint `POST /api/payments/create-intent`.
      - Este endpoint calcular√° el importe total y crear√° un `PaymentIntent` en Stripe, devolviendo su `client_secret` al frontend.
    - **Confirmaci√≥n:**
      - Tras el env√≠o del formulario por parte del cliente, Stripe procesar√° el pago.
      - El backend escuchar√° los **Webhooks** de Stripe (evento `payment_intent.succeeded`) para confirmar el pago de forma fiable y, en ese momento, finalizar√° la creaci√≥n de la reserva en la base de datos.

3.  **Flujo de Suscripciones:**
    - Se utilizar√° Stripe Checkout o el Payment Element para la suscripci√≥n inicial.
    - El backend crear√° un `Customer` en Stripe para cada usuario que se suscriba.
    - Se crear√°n objetos `Subscription` en Stripe, que gestionar√°n los cobros recurrentes autom√°ticamente.
    - Los Webhooks (`invoice.paid`, `customer.subscription.deleted`, etc.) ser√°n esenciales para mantener el estado de la suscripci√≥n sincronizado en nuestra base de datos.

### Modelo de Datos (Prisma)

```prisma
model User {
  // ... campos existentes
  stripeCustomerId String? @unique // ID del cliente en Stripe
}

model Appointment {
  // ... campos existentes
  paymentIntentId String? @unique // ID del intento de pago de Stripe
  paymentStatus   PaymentStatus @default(PENDING)
}

enum PaymentStatus {
  PENDING
  SUCCEEDED
  FAILED
}
```
````

## 10.3. Sincronizaci√≥n de Calendario: Google Calendar

**Prop√≥sito:** Ofrecer una conexi√≥n opcional para el administrador que sincroniza la agenda de la plataforma con un Google Calendar de la empresa, mejorando la visibilidad y la gesti√≥n de la disponibilidad desde fuera de la aplicaci√≥n.

### Funcionalidades Clave

- **Sincronizaci√≥n de Citas (App -> Google Calendar):**
  - Cuando una cita se crea, reagenda o cancela en nuestra plataforma, el evento correspondiente se crea, actualiza o elimina autom√°ticamente en el Google Calendar del negocio.
- **Sincronizaci√≥n de Disponibilidad (Google Calendar -> App):**
  - Cuando el administrador crea un evento manual en su Google Calendar (ej: "Cita M√©dica", "Reuni√≥n"), el sistema de nuestra aplicaci√≥n lo detectar√° como un "bloqueo de tiempo".
  - Ese intervalo de tiempo se marcar√° como no disponible en el calculador de disponibilidad de la web, evitando que los clientes puedan reservar en ese hueco.

### Flujo de Implementaci√≥n

1.  **Autorizaci√≥n (OAuth 2.0):**

    - En el panel de administraci√≥n, habr√° una secci√≥n de "Integraciones".
    - El administrador har√° clic en "Conectar con Google Calendar".
    - Esto iniciar√° un flujo de consentimiento de OAuth 2.0 donde el administrador autoriza a nuestra aplicaci√≥n a gestionar su calendario.
    - El backend recibir√° y almacenar√° de forma segura las credenciales de OAuth (access token y refresh token) asociadas a la cuenta del negocio.

2.  **Creaci√≥n y Modificaci√≥n de Eventos:**

    - Cuando se crea una cita, el backend utilizar√° las credenciales guardadas para llamar a la API de Google Calendar y crear un nuevo evento.
    - La informaci√≥n del evento incluir√°: nombre del servicio, nombre del cliente y empleado asignado.
    - El `googleEventId` devuelto por la API se guardar√° en nuestro modelo `Appointment`.
    - Para actualizar o cancelar, se usar√° ese `googleEventId` guardado para modificar el evento correcto.

3.  **Lectura de Disponibilidad:**
    - Cuando el sistema calcula los huecos disponibles para un d√≠a, adem√°s de mirar las citas en nuestra propia base de datos, har√° una llamada a la API de Google (`freebusy`) para consultar los periodos de tiempo ocupados en el calendario del administrador.
    - Estos periodos ocupados se restar√°n de la disponibilidad total.

### Modelo de Datos (Prisma)

```prisma
model Appointment {
  // ... campos existentes
  googleEventId String? @unique // ID del evento en Google Calendar
}

// Modelo para guardar las credenciales de la empresa
model AccountSettings {
  id                    String @id @default(cuid())
  googleAccessToken     String? @db.Text
  googleRefreshToken    String? @db.Text
  googleTokenExpiryDate DateTime?
  // ... otras configuraciones del negocio
}
```




// ====== [80] package.json ======
{
  "name": "aquaclean-car-wash-monorepo",
  "version": "1.0.0",
  "private": true,
  "description": "Plataforma de gesti√≥n y reservas para AquaClean Car Wash",
  "author": "R3v180",
  "license": "UNLICENSED",
  "scripts": {
    "dev": "turbo run dev --parallel",
    "build": "turbo run build",
    "lint": "turbo run lint",
    "format": "prettier --write \"**/*.{ts,tsx,md,json}\""
  },
  "devDependencies": {
    "@typescript-eslint/eslint-plugin": "^7.10.0",
    "@typescript-eslint/parser": "^7.10.0",
    "eslint": "^8.57.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-react": "^7.34.1",
    "eslint-plugin-react-hooks": "^4.6.2",
    "prettier": "^3.2.5",
    "turbo": "^1.13.3",
    "typescript": "^5.4.5",
    "zod": "^3.23.8"
  },
  "packageManager": "pnpm@9.1.1"
}


// ====== [81] packages/config/eslint-preset.js ======
// File: /packages/config/eslint-preset.js - v1.0

module.exports = {
  extends: [
    'eslint:recommended',
    'plugin:@typescript-eslint/recommended',
    'plugin:react/recommended',
    'plugin:react-hooks/recommended',
    'prettier',
  ],
  parser: '@typescript-eslint/parser',
  plugins: ['@typescript-eslint'],
  env: {
    browser: true,
    node: true,
    es2021: true,
  },
  settings: {
    react: {
      version: 'detect',
    },
  },
  rules: {
    // Reglas de TypeScript
    '@typescript-eslint/no-unused-vars': [
      'warn',
      { argsIgnorePattern: '^_', varsIgnorePattern: '^_' },
    ],
    '@typescript-eslint/no-explicit-any': 'warn',

    // Reglas de React
    'react/prop-types': 'off', // No necesitamos prop-types porque usamos TypeScript
    'react/react-in-jsx-scope': 'off', // No es necesario importar React en el scope con React 17+
    'react/jsx-uses-react': 'off',

    // Reglas generales de ESLint
    'no-console': ['warn', { allow: ['warn', 'error'] }],
  },
  ignorePatterns: [
    'node_modules/',
    'dist/',
    'build/',
    '.turbo/',
    'coverage/',
  ],
};


// ====== [82] packages/config/package.json ======
{
  "name": "@aquaclean/config",
  "version": "1.0.0",
  "private": true,
  "main": "index.js",
  "files": [
    "eslint-preset.js"
  ],
  "devDependencies": {
    "@typescript-eslint/eslint-plugin": "^7.10.0",
    "@typescript-eslint/parser": "^7.10.0",
    "eslint": "^8.57.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-react": "^7.34.1",
    "eslint-plugin-react-hooks": "^4.6.2",
    "typescript": "^5.4.5"
  }
}


// ====== [83] packages/types/package.json ======
{
  "name": "@aquaclean/types",
  "version": "1.0.0",
  "private": true,
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    ".": {
      "import": "./dist/index.js",
      "require": "./dist/index.js",
      "types": "./dist/index.d.ts"
    }
  },
  "scripts": {
    "build": "tsc",
    "dev": "tsc --watch",
    "lint": "eslint . --ext .ts"
  },
  "peerDependencies": {
    "zod": ">=3.0.0"
  },
  "devDependencies": {
    "typescript": "^5.4.5"
  }
}


// ====== [84] packages/types/src/employee.schema.ts ======
// File: /packages/types/src/employee.schema.ts (ACTUALIZADO CON CAMPO DE COLOR)

import { z } from 'zod';

// Esquema para la creaci√≥n/edici√≥n de un nuevo empleado
export const createEmployeeSchema = z.object({
  name: z.string().min(1, { message: 'El nombre es requerido.' }).min(3, { message: 'El nombre debe tener al menos 3 caracteres.' }),

  email: z.string().min(1, { message: 'El email es requerido.' }).email({ message: 'El formato del email no es v√°lido.' }),

  role: z.enum(['ADMIN', 'EMPLOYEE']),

  bio: z.string().optional(),

  imageUrl: z
    .string()
    .url({ message: 'La URL de la imagen no es v√°lida.' })
    .or(z.literal(''))
    .optional(),
  
  status: z.enum(['ACTIVE', 'ARCHIVED']).optional(),
  
  // --- CAMPO A√ëADIDO ---
  color: z.string().optional(),
  
  workSchedule: z.record(z.string(), z.unknown()).optional(),
});


// ====== [85] packages/types/src/index.ts ======
// File: /packages/types/src/index.ts (ACTUALIZADO)

// Exportamos los esquemas desde su nueva ubicaci√≥n local
export * from './service.schema';
export * from './employee.schema'; // <-- L√çNEA A√ëADIDA

// Exportamos las interfaces de tipos
export * from './service';

export interface User {
  id: string;
  name: string | null;
  email: string;
  emailVerified: Date | null;
  image: string | null;
  role: 'ADMIN' | 'CUSTOMER';
}


// ====== [86] packages/types/src/service.schema.ts ======
// File: /packages/types/src/service.schema.ts (ACTUALIZADO)

import { z } from 'zod';

// Definimos el esquema de validaci√≥n para la creaci√≥n/edici√≥n de un servicio.
export const createServiceSchema = z.object({
  name: z.string().min(1, { message: 'El nombre es requerido.' }).min(3, { message: 'El nombre debe tener al menos 3 caracteres.' }),

  description: z.string().min(1, { message: 'La descripci√≥n es requerida.' }).min(10, { message: 'La descripci√≥n debe tener al menos 10 caracteres.' }),

  duration: z.coerce.number()
    .int({ message: 'La duraci√≥n debe ser un n√∫mero entero.' })
    .positive({ message: 'La duraci√≥n debe ser un n√∫mero positivo.' }),

  prices: z.record(z.string(), z.number()).refine(obj => Object.keys(obj).length > 0, {
    message: 'Se requiere al menos un precio.',
  }),
  
  category: z.string().min(1, { message: 'La categor√≠a es requerida.' }),

  // --- L√çNEA A√ëADIDA ---
  isActive: z.boolean().optional(),

  isAddon: z.boolean().optional(),
  isGiftable: z.boolean().optional(),
  isFeatured: z.boolean().optional(),
});


// ====== [87] packages/types/src/service.ts ======
// File: /packages/types/src/service.ts (ACTUALIZADO)

export interface Service {
  id: string;
  name: string;
  description: string;
  duration: number; // en minutos
  // --- L√çNEA MODIFICADA ---
  prices: {
    standard: number;
    // Podemos a√±adir m√°s tipos de precios en el futuro si es necesario
    [key: string]: number; 
  };
  // --- FIN DE LA MODIFICACI√ìN ---
  category: string;
  isActive: boolean;
  isAddon: boolean;
  isGiftable: boolean;
  isFeatured: boolean;
}


// ====== [88] packages/types/tsconfig.json ======
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "dist",
    "declaration": true,
    "noEmit": false
  },
  "include": ["src/**/*.ts"],
  "exclude": ["node_modules", "dist"]
}


// ====== [89] tsconfig.base.json ======
// File: /tsconfig.base.json - v1.0
{
  "compilerOptions": {
    /* Base Options */
    "esModuleInterop": true,
    "skipLibCheck": true,
    "target": "ESNext",
    "allowJs": true,
    "resolveJsonModule": true,
    "moduleResolution": "bundler",
    "isolatedModules": true,

    /* Strictness */
    "strict": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitAny": true,

    /* Transpilation */
    "module": "ESNext",
    "jsx": "react-jsx",
    "noEmit": true,

    /* Path Aliases */
    "baseUrl": ".",
    "paths": {
      "@aquaclean/types": ["packages/types/src"],
      "@aquaclean/config/*": ["packages/config/*"]
    }
  }
}


// ====== [90] tsconfig.json ======
// File: /tsconfig.json - v1.0
{
  "files": [],
  "references": [
    { "path": "apps/client" },
    { "path": "apps/server" },
    { "path": "packages/types" },
    { "path": "packages/config" }
  ]
}


// ====== [91] turbo.json ======
{
  "$schema": "./.schemas/turbo-schema-v1.json",
  "globalDependencies": ["tsconfig.base.json"],
  "pipeline": {
    "dev": {
      "cache": false,
      "persistent": true
    },
    "build": {
      "dependsOn": ["^build"],
      "outputs": ["dist/**"]
    },
    "lint": {
      "outputs": []
    },
    "format": {
      "outputs": []
    }
  }
}

