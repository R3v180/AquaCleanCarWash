# √çNDICE DE ARCHIVOS (ESTRUCTURA REFACTORIZADA)

1. .gitignore
2. .schemas/turbo-schema-v1.json
3. PROXIMOS_PASOS.md
4. README.md
5. ROADMAP.md
6. WORKFLOW.md
7. apps/client/index.html
8. apps/client/package.json
9. apps/client/src/App.tsx
10. apps/client/src/components/admin/AbsenceCalendar.tsx
11. apps/client/src/components/admin/AppointmentForm.tsx
12. apps/client/src/components/admin/ConflictResolutionModal.tsx
13. apps/client/src/components/admin/ScheduleEditor.tsx
14. apps/client/src/components/admin/ServiceForm.tsx
15. apps/client/src/components/booking/BookingDateTimePicker.tsx
16. apps/client/src/components/common/PublicFooter.module.css
17. apps/client/src/components/common/PublicFooter.tsx
18. apps/client/src/components/common/PublicHeader.module.css
19. apps/client/src/components/common/PublicHeader.tsx
20. apps/client/src/custom.d.ts
21. apps/client/src/layouts/AdminLayout.tsx
22. apps/client/src/layouts/PublicLayout.tsx
23. apps/client/src/lib/apiClient.ts
24. apps/client/src/main.tsx
25. apps/client/src/pages/admin/AdminDashboardPage.tsx
26. apps/client/src/pages/admin/AdminLoginPage.tsx
27. apps/client/src/pages/admin/AdminPlanningPage.tsx
28. apps/client/src/pages/admin/BusinessSettingsPage.tsx
29. apps/client/src/pages/admin/EmployeesManagementPage.tsx
30. apps/client/src/pages/admin/ServicesManagementPage.tsx
31. apps/client/src/pages/public/BookingPage.tsx
32. apps/client/src/pages/public/HomePage.module.css
33. apps/client/src/pages/public/HomePage.tsx
34. apps/client/src/pages/public/ServicesPage.tsx
35. apps/client/src/pages/public/TeamPage.tsx
36. apps/client/tsconfig.json
37. apps/client/tsconfig.node.json
38. apps/server/.env
39. apps/server/package.json
40. apps/server/prisma/schema.prisma
41. apps/server/prisma/seed.ts
42. apps/server/src/api/adminAppointments.routes.ts
43. apps/server/src/api/adminDateOverrides.routes.ts
44. apps/server/src/api/adminSettings.routes.ts
45. apps/server/src/api/auth.routes.ts
46. apps/server/src/api/availability.routes.ts
47. apps/server/src/api/bookings.routes.ts
48. apps/server/src/api/employees.routes.ts
49. apps/server/src/api/services.routes.ts
50. apps/server/src/lib/availabilityService.ts
51. apps/server/src/lib/notificationService.ts
52. apps/server/src/lib/prisma.ts
53. apps/server/src/server.ts
54. apps/server/tsconfig.json
55. docs/PROJECT_SPECIFICATION.md
56. docs/features/01-authentication.md
57. docs/features/02-public-site.md
58. docs/features/03-booking-flow.md
59. docs/features/04-customer-panel.md
60. docs/features/05-admin-panel-core-management.md
61. docs/features/06-admin-panel-operations.md
62. docs/features/07-reviews-system.md
63. docs/features/08-marketing-monetization.md
64. docs/features/09-notifications-system.md
65. docs/features/10-external-integrations.md
66. package.json
67. packages/config/eslint-preset.js
68. packages/config/package.json
69. packages/types/package.json
70. packages/types/src/employee.schema.ts
71. packages/types/src/index.ts
72. packages/types/src/service.schema.ts
73. packages/types/src/service.ts
74. packages/types/tsconfig.json
75. tsconfig.base.json
76. tsconfig.json
77. turbo.json


# CONTENIDO DE ARCHIVOS


// ====== [1] .gitignore ======
# Ignorar dependencias
node_modules/

# Ignorar archivos de build y distribuci√≥n
dist/
build/

# Ignorar variables de entorno
.env
.env.*
!.env.example

# Archivos de sistema operativo
.DS_Store

# Logs y archivos de debug
*.log
.pnpm-debug.log*

# Ignorar cach√© de herramientas
.eslintcache
.vite-cache


// ====== [2] .schemas/turbo-schema-v1.json ======
{
  "$id": "https://json.schemastore.org/turbo",
  "title": "Turborepo configuration file",
  "type": "object",
  "properties": {
    "$schema": {
      "type": "string"
    },
    "extends": {
      "description": "A list of packages to extend the configuration from. Can be a path to a local file or a package name.",
      "type": "array",
      "items": {
        "type": "string"
      }
    },
    "globalDependencies": {
      "description": "A list of file glob patterns that Turborepo will use to determine if a task should be executed.",
      "type": "array",
      "items": {
        "type": "string"
      }
    },
    "globalEnv": {
      "description": "A list of environment variables that are used by all tasks. These variables are passed to the tasks as environment variables.",
      "type": "array",
      "items": {
        "type": "string"
      }
    },
    "pipeline": {
      "description": "The pipeline configuration for the Turborepo.",
      "type": "object",
      "additionalProperties": {
        "type": "object",
        "properties": {
          "cache": {
            "description": "Whether or not to cache the task.",
            "type": "boolean"
          },
          "dependsOn": {
            "description": "A list of tasks that this task depends on.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "outputs": {
            "description": "A list of file glob patterns that are the outputs of the task.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "env": {
            "description": "A list of environment variables that are used by the task.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "outputMode": {
            "description": "The output mode of the task.",
            "type": "string",
            "enum": [
              "full",
              "hash-only",
              "new-only",
              "none"
            ]
          },
          "persistent": {
            "description": "Whether or not the task is a persistent task.",
            "type": "boolean"
          }
        },
        "additionalProperties": false
      }
    }
  },
  "additionalProperties": false
}


// ====== [3] PROXIMOS_PASOS.md ======
<!-- File: /PROXIMOS_PASOS.md - v2.0 (Informe de Situaci√≥n) -->

# Informe de Situaci√≥n y Pr√≥ximos Pasos

Este documento describe el estado actual del desarrollo, detalla el bug cr√≠tico que bloquea el progreso y define el plan de acci√≥n inmediato para resolverlo.

---

### ‚úÖ **Trabajo Realizado (Resumen para Contexto)**

1.  **Gesti√≥n de Servicios y Empleados:** Se han implementado CRUDs completos para servicios y empleados, incluyendo estados (`Activo`/`Inactivo`, `Activo`/`Archivado`), horarios semanales por turnos y gesti√≥n de ausencias.

2.  **Motor de Disponibilidad (Backend):** La API de disponibilidad (`/api/availability`) ha sido reconstruida para calcular los huecos disponibles bas√°ndose en la capacidad combinada de los empleados, sus horarios, ausencias y el horario general del negocio.

3.  **Gesti√≥n de Horarios del Negocio (Avanzado):**
    - Se implement√≥ la interfaz para que el administrador configure el horario semanal del negocio.
    - El sistema fue evolucionado para soportar **Anulaciones por Fecha**, permitiendo al administrador configurar tanto **cierres de d√≠a completo (festivos)** como **horarios especiales (jornada reducida)**, los cuales tienen prioridad sobre el horario semanal.

4.  **Flujo de Reservas (Backend - Intento de Finalizaci√≥n):** Se implement√≥ la l√≥gica de auto-asignaci√≥n de empleados en la API `POST /bookings`.

5.  **Sistema de Notificaciones (Base):** Se ha instalado `Nodemailer` y se ha creado la estructura inicial de un `NotificationService` con un sistema de simulaci√≥n de env√≠o de emails v√≠a Ethereal.

---

### üî¥ **PROBLEMA CR√çTICO ACTUAL (BLOQUEANTE)**

Actualmente, el proyecto se encuentra bloqueado por un bug cr√≠tico de inconsistencia en el motor de disponibilidad, conocido como la **"paradoja de la disponibilidad"**.

**Descripci√≥n del Bug:**

1.  La API que muestra los huecos al cliente (`GET /api/availability`) llama a la funci√≥n de validaci√≥n `isEmployeeAvailable` y determina correctamente que un empleado est√° disponible para un tramo horario (ej: 09:00), mostrando el hueco en la interfaz. **(Comportamiento Correcto)**.

2.  Sin embargo, al intentar reservar ese mismo hueco, la API de creaci√≥n de reservas (`POST /bookings`) llama a la **misma funci√≥n `isEmployeeAvailable`** con los **mismos par√°metros**, y esta devuelve `false`, concluyendo err√≥neamente que el empleado no est√° disponible.

3.  Esto provoca que la API de reservas devuelva un error `409 Conflict`, bloqueando todas las reservas con auto-asignaci√≥n y rompiendo el flujo principal de la aplicaci√≥n.

**Causa Ra√≠z Identificada (Gracias a los Logs):**

Los logs de depuraci√≥n han confirmado que la contradicci√≥n ocurre dentro de la funci√≥n `isEmployeeAvailable` en el archivo `apps/server/src/lib/availabilityService.ts`. El problema reside en la l√≥gica de comparaci√≥n de los l√≠mites de fecha/hora (ej: `slot.isSameOrAfter(shiftStart)`), que se comporta de manera inconsistente. La misma comparaci√≥n `09:00 >= 09:00` devuelve `true` en un contexto y `false` en otro, lo que es l√≥gicamente imposible y apunta a un bug muy sutil.

---

### üéØ **√öNICO OBJETIVO INMEDIATO: Resoluci√≥n del Bug**

1.  **Depurar y Corregir `isEmployeeAvailable`:** Iniciar una nueva sesi√≥n de desarrollo enfocada exclusivamente en analizar los logs detallados de la funci√≥n `isEmployeeAvailable` para encontrar la causa ra√≠z de la inconsistencia en la comparaci√≥n de fechas y aplicar una soluci√≥n definitiva. El objetivo es que la funci√≥n devuelva siempre `true` cuando un tramo horario encaja perfectamente en un turno de trabajo.

**Nota:** Todas las dem√°s tareas, incluyendo la finalizaci√≥n del sistema de notificaciones, quedan en pausa hasta que este bug bloqueante sea resuelto.



// ====== [4] README.md ======
<!-- File: /README.md - v1.3 (ACTUALIZADO) -->
<div align="center">
  <img src="./docs/assets/logo.png" alt="AquaClean Car Wash Logo" width="200"/>
</div>

# AquaClean Car Wash - Plataforma de Gesti√≥n y Reservas

![Versi√≥n](https://img.shields.io/badge/version-1.0.0-blue)
![Estado](https://img.shields.io/badge/status-en--desarrollo-green)
![Licencia](https://img.shields.io/badge/licencia-privada-red)

Una soluci√≥n web completa para lavaderos de coches que automatiza las reservas, optimiza la gesti√≥n de clientes y potencia el marketing digital. Este proyecto est√° dise√±ado para ser una base robusta y reutilizable para negocios del sector.

---

## üé• Demo Visual

<!-- TODO: A√±adir un GIF animado mostrando el flujo de reserva del cliente y el panel de administraci√≥n -->
<div align="center">
  *Pr√≥ximamente: Una demostraci√≥n visual del producto en acci√≥n.*
</div>

---

## ‚ú® Caracter√≠sticas Principales

| Caracter√≠stica                          | Estado                       | Descripci√≥n                                                                                                                                                                               |
| :-------------------------------------- | :--------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| üìÖ **Sistema de Reservas 24/7**         | üü¢ Parcialmente Implementado | Permite a los clientes seleccionar un profesional, ver su disponibilidad en tiempo real y reservar una cita.                                                                              |
| üìä **Panel de Administraci√≥n Completo** | üü¢ Parcialmente Implementado | Un centro de control para gestionar citas, servicios y empleados. Incluye un planning visual interactivo, **gesti√≥n de turnos semanales, y un calendario de ausencias para el personal.** |
| üì± **Dise√±o 100% Adaptativo**           | ‚è≥ Pendiente                 | Experiencia de usuario impecable en cualquier dispositivo: m√≥vil, tablet y ordenador.                                                                                                     |
| üîî **Notificaciones Autom√°ticas**       | ‚è≥ Pendiente                 | Confirmaciones y recordatorios por Email y WhatsApp para reducir las ausencias y mantener a todos informados.                                                                             |
| ‚≠ê **Sistema de Valoraciones**          | ‚è≥ Pendiente                 | Automatiza la solicitud de rese√±as y permite moderarlas antes de mostrarlas p√∫blicamente en la web.                                                                                       |
| üí≥ **M√∫ltiples V√≠as de Ingreso**        | ‚è≥ Pendiente                 | Soporte para bonos, tarjetas regalo y suscripciones mensuales para fidelizar clientes y generar ingresos recurrentes.                                                                     |
| üîó **Integraciones Clave**              | ‚è≥ Pendiente                 | Sincronizaci√≥n bidireccional con Google Calendar y pasarela de pagos segura con Stripe.                                                                                                   |

---

## üõ†Ô∏è Stack Tecnol√≥gico

| √Årea                                     | Tecnolog√≠as                                                        |
| :--------------------------------------- | :----------------------------------------------------------------- |
| **Frontend**                             | React 18, TypeScript, Vite, Mantine UI, Zustand                    |
| **Backend**                              | Node.js, Express.js, TypeScript, Prisma, Zod                       |
| **Base de Datos**                        | PostgreSQL                                                         |
| **Testing**                              | Vitest, React Testing Library                                      |
| **Herramientas de Desarrollo y Calidad** | pnpm (Monorepo), Git, GitHub, ESLint, Prettier, Husky, lint-staged |

---

## üöÄ C√≥mo Empezar (Gu√≠a para Desarrolladores)

<details>
<summary><strong>Haz clic aqu√≠ para ver las instrucciones de instalaci√≥n y ejecuci√≥n</strong></summary>

### Requisitos Previos

- Node.js (v20+)
- pnpm (v9+)
- Git
- Una instancia de PostgreSQL en ejecuci√≥n

### Pasos para la Instalaci√≥n

1.  **Clonar el repositorio:**

    ```bash
    git clone https://github.com/R3v180/AquaCleanCarWash.git
    cd AquaCleanCarWash
    ```

2.  **Instalar dependencias:**

    ```bash
    pnpm install
    ```

    _Nota: Este comando tambi√©n instalar√° y configurar√° **Husky**. A partir de ahora, se ejecutar√°n comprobaciones de calidad de c√≥digo (ESLint, Prettier) autom√°ticamente antes de cada `git commit`._

3.  **Configurar variables de entorno:**
    - Habr√° un archivo `.env.example` en la carpeta del servidor (`apps/server`).
    - C√≥pialo a un nuevo archivo llamado `.env` en la misma carpeta.
    - Rellena las variables (credenciales de la base de datos, claves de API, etc.).
      _Nota: Estos archivos se crear√°n durante el desarrollo del backend._

4.  **Ejecutar las migraciones de la base de datos:**

    ```bash
    # Ejecuta el script 'migrate:dev' solo en el workspace del servidor
    pnpm --filter server run migrate:dev
    ```

5.  **Poblar la base de datos con datos de prueba:**

    ```bash
    # Este comando es esencial para tener servicios, empleados y un admin de prueba
    pnpm --filter server run prisma:seed
    ```

6.  **Iniciar los servidores de desarrollo:**
    ```bash
    # Este comando iniciar√° el frontend y el backend simult√°neamente
    pnpm dev
    ```

</details>

---

## üó∫Ô∏è Roadmap del Proyecto

Para ver el plan de desarrollo detallado por fases, consulta nuestro archivo [**ROADMAP.md**](./ROADMAP.md).

## üìÑ Especificaciones Completas

Toda la funcionalidad del proyecto est√° documentada en detalle en nuestra [**Especificaci√≥n de Proyecto**](./docs/PROJECT_SPECIFICATION.md).



// ====== [5] ROADMAP.md ======
<!-- File: /ROADMAP.md - v1.8 (Actualizado con Estado de Bug) -->

# Roadmap del Proyecto AquaClean Car Wash

Este documento describe el plan de desarrollo por fases para la plataforma. El objetivo es lanzar un Producto M√≠nimo Viable (MVP) funcional y luego iterar sobre √©l a√±adiendo capas de valor en versiones posteriores.

---

## üöß Versi√≥n 1.0: MVP - Lanzamiento y Operaciones Core

**Objetivo:** Poner en marcha la funcionalidad esencial para que el negocio pueda recibir y gestionar reservas online.

- **‚úÖ Sitio P√∫blico B√°sico:**
  - [‚úÖ] P√°gina de Inicio (Homepage) y Navegaci√≥n principal.
  - [‚úÖ] P√°gina de Servicios detallada.
  - [‚úÖ] Perfiles p√∫blicos del equipo (`/team`).

- **üü° Flujo de Reserva (Sin Pago) - EN REVISI√ìN:**
  - [‚úÖ] L√≥gica de Disponibilidad (API y Componente de Frontend).
  - [‚úÖ] Conexi√≥n del flujo (Selecci√≥n de servicio -> Calendario).
  - [‚úÖ] Formulario de datos de cliente.
  - [‚úÖ] Creaci√≥n final de la cita en la base de datos.
  - [üî¥ BUG BLOQUEANTE] **Auto-asignaci√≥n de empleado para "Cualquier Profesional".**

- **‚úÖ Panel de Administraci√≥n Esencial:**
  - **‚úÖ Gesti√≥n Core:** CRUD completo para Servicios (con estado activo/inactivo) y Empleados (con estado activo/archivado).
  - **‚úÖ Operaciones:** Planning visual de citas (FullCalendar).
    - ‚úÖ Visualizaci√≥n y Reagendamiento (Drag & Drop) funcional.
    - ‚úÖ Creaci√≥n manual, edici√≥n y anulaci√≥n de citas (modales).
  - **‚úÖ Gesti√≥n Avanzada de Horarios (Empleados y Negocio):**
    - ‚úÖ Editor de turnos semanales por empleado.
    - ‚úÖ Calendario visual para gestionar vacaciones y ausencias (con detecci√≥n de conflictos).
    - ‚úÖ Interfaz para Horario General del Negocio.
    - ‚úÖ **Sistema de Anulaciones por Fecha (Festivos y Horarios Especiales).**
  - ‚úÖ **Autenticaci√≥n:** Login seguro para el administrador.

- **[ ] Notificaciones Cr√≠ticas (Email):**
  - [ ] Email de confirmaci√≥n de cita para el cliente.
  - [ ] Email de notificaci√≥n de nueva cita para la empresa.

---

## ‚ú® Versi√≥n 1.1: Fidelizaci√≥n y Experiencia de Cliente

**Objetivo:** Mejorar la retenci√≥n de clientes y automatizar el marketing de reputaci√≥n.

- **[ ] Panel de Cliente Completo:**
  - [ ] Registro de usuarios (Email/Google) con verificaci√≥n.
  - [ ] Login y gesti√≥n de perfil.
  - [ ] Historial de citas y opci√≥n "Reservar de Nuevo".
  - [ ] Gesti√≥n de m√∫ltiples veh√≠culos.

- **[ ] Sistema de Valoraciones y Rese√±as:**
  - [ ] Email/WhatsApp autom√°tico post-servicio para solicitar valoraci√≥n.
  - [ ] Panel de moderaci√≥n de rese√±as en el √°rea de administraci√≥n.
  - [ ] Visualizaci√≥n de rese√±as aprobadas en el sitio p√∫blico.

- **[ ] Integraci√≥n con Pasarela de Pagos (Stripe):**
  - [ ] Integraci√≥n b√°sica para pagos en el flujo de reserva.

- **[ ] Integraci√≥n con Google Calendar:**
  - [ ] Sincronizaci√≥n bidireccional para citas y bloqueos.

---

## üöÄ Versi√≥n 1.2: Monetizaci√≥n Avanzada y Anal√≠ticas

**Objetivo:** Introducir nuevas v√≠as de ingresos y proporcionar herramientas de inteligencia de negocio.

- **[ ] M√≥dulos de Marketing y Monetizaci√≥n:**
  - [ ] Creaci√≥n y gesti√≥n de Bonos de lavados.
  - [ ] Venta de Tarjetas Regalo digitales.
  - [ ] Sistema de suscripciones mensuales (Club de Lavado).

- **[ ] Dashboard de Anal√≠ticas:**
  - [ ] Gr√°ficos con m√©tricas clave (ingresos, ocupaci√≥n, servicios populares, etc.).

- **[ ] Notificaciones Avanzadas (WhatsApp):**
  - [ ] Recordatorios de citas autom√°ticos por WhatsApp.
  - [ ] Notificaciones de nuevas citas por WhatsApp para la empresa.

---

## üí° Futuro (Ideas a Considerar)

- **Pagos Configurables:** Permitir al administrador elegir si las reservas requieren pago (completo/parcial) o no.
- PWA para Empleados: Una aplicaci√≥n "instalable" para que los empleados gestionen su agenda diaria.
- Precios Din√°micos: Configuraci√≥n de tarifas especiales para horas de alta/baja demanda.
- Tienda Online: Venta de productos de detailing directamente desde la web.
- Integraci√≥n con Software de Contabilidad.



// ====== [6] WORKFLOW.md ======
# Nuestro Workflow de Desarrollo Colaborativo

Este documento describe nuestro m√©todo de trabajo para el desarrollo del proyecto AquaClean Car Wash. El objetivo es mantener un ritmo eficiente, minimizar errores y asegurar que ambos estemos siempre sincronizados.

## Principios Fundamentales

1.  **Un Archivo a la Vez (One-File-Flow):** El n√∫cleo de nuestro workflow. La IA proporcionar√° el c√≥digo completo para **un √∫nico archivo** a la vez. Esto nos permite implementar, probar y depurar de forma aislada y controlada antes de pasar a la siguiente pieza del puzle.

2.  **C√≥digo Siempre Completo:** Nunca se proporcionar√°n fragmentos, "diffs" o instrucciones parciales. Cada bloque de c√≥digo corresponder√° al **contenido 100% actualizado y completo del archivo** en cuesti√≥n.

3.  **El Contexto es la √önica Fuente de Verdad:** La sesi√≥n siempre comenzar√° con un prompt detallado que incluye el estado actual del proyecto y el c√≥digo completo. La IA basar√° **todas sus respuestas y c√≥digo √∫nicamente en este contexto**, sin hacer suposiciones sobre el `schema.prisma` u otras partes del c√≥digo que no est√©n expl√≠citamente proporcionadas.

4.  **Pasos Claros y Definidos:** Cada acci√≥n estar√° precedida por un an√°lisis y seguida de instrucciones claras:
    - **An√°lisis:** Se explicar√° qu√© vamos a hacer y por qu√©.
    - **C√≥digo:** Se proporcionar√° el bloque de c√≥digo completo.
    - **Gu√≠a de Pruebas:** Cuando sea aplicable, se incluir√° una gu√≠a detallada para verificar que la nueva funcionalidad se ha implementado correctamente.

5.  **Ciclo de Feedback Estricto:** El flujo de trabajo es un di√°logo constante:
    - **IA:** Proporciona el c√≥digo para el Archivo N.
    - **Desarrollador:** Implementa el c√≥digo.
    - **Desarrollador:** Si hay un error de compilador o de ejecuci√≥n, proporciona el **mensaje de error exacto y completo**.
    - **IA:** Analiza el error y proporciona una versi√≥n corregida del Archivo N.
    - **Desarrollador:** Confirma que el error se ha solucionado.
    - **IA:** Procede a proporcionar el c√≥digo para el Archivo N+1.

6.  **Commits y Documentaci√≥n como Hitos:** Al completar una funcionalidad significativa (ej: "Flujo de Reserva", "Planning Visual"), haremos una pausa para:
    - **Realizar un `git commit`** con un mensaje descriptivo.
    - **Actualizar la documentaci√≥n** (`ROADMAP.md`, `README.md`, especificaciones en `docs/features/`) para que refleje el nuevo estado del proyecto.

---

### Ejemplo de Flujo de Trabajo T√≠pico

1.  **Inicio:** El desarrollador inicia la conversaci√≥n con un prompt que incluye el `WORKFLOW.md`, el resumen de la sesi√≥n anterior y el estado actual del c√≥digo del proyecto.
2.  **IA:** Confirma la asimilaci√≥n del contexto y propone el primer archivo a modificar (ej: `apps/server/api/example.routes.ts`). Proporciona el c√≥digo completo.
3.  **Desarrollador:** Implementa y confirma que todo est√° OK.
4.  **IA:** Proporciona el siguiente archivo (ej: `apps/client/pages/ExamplePage.tsx`).
5.  **Desarrollador:** Implementa el c√≥digo pero recibe un error de TypeScript en VS Code.
6.  **Desarrollador:** Copia y pega el error completo en el chat.
7.  **IA:** Analiza el error, se disculpa, explica la causa y proporciona una versi√≥n corregida y completa de `apps/client/pages/ExamplePage.tsx`.
8.  **Desarrollador:** Confirma que la correcci√≥n funciona y completa la gu√≠a de pruebas.
9.  **IA:** Reconoce la finalizaci√≥n de la funcionalidad y sugiere un mensaje de `git commit` y las actualizaciones de documentaci√≥n pertinentes.



// ====== [7] apps/client/index.html ======
<!-- File: /apps/client/index.html - v1.0 -->
<!doctype html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AquaClean Car Wash</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>


// ====== [8] apps/client/package.json ======
{
  "name": "client",
  "version": "1.0.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview"
  },
  "dependencies": {
    "@fullcalendar/core": "^6.1.19",
    "@fullcalendar/daygrid": "^6.1.19",
    "@fullcalendar/interaction": "^6.1.19",
    "@fullcalendar/react": "^6.1.19",
    "@fullcalendar/resource-timeline": "^6.1.19",
    "@fullcalendar/timegrid": "^6.1.19",
    "@mantine/core": "^7.10.2",
    "@mantine/dates": "^7.10.2",
    "@mantine/form": "^7.10.2",
    "@mantine/hooks": "^7.10.2",
    "@mantine/notifications": "^7.10.2",
    "@tabler/icons-react": "^3.35.0",
    "axios": "^1.7.2",
    "dayjs": "^1.11.11",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.23.1",
    "zustand": "^4.5.2"
  },
  "devDependencies": {
    "@aquaclean/config": "workspace:*",
    "@aquaclean/types": "workspace:*",
    "@types/react": "^18.2.66",
    "@types/react-dom": "^18.2.22",
    "@vitejs/plugin-react": "^4.2.1",
    "eslint": "^8.57.0",
    "postcss": "^8.4.38",
    "postcss-preset-mantine": "^1.15.0",
    "postcss-simple-vars": "^7.0.1",
    "typescript": "^5.4.5",
    "vite": "^5.2.0"
  }
}


// ====== [9] apps/client/src/App.tsx ======
// File: /apps/client/src/App.tsx (ACTUALIZADO)

import { Route, Routes } from 'react-router-dom';
import { HomePage } from './pages/public/HomePage';
import { AdminLayout } from './layouts/AdminLayout';
import { PublicLayout } from './layouts/PublicLayout';
import { AdminDashboardPage } from './pages/admin/AdminDashboardPage';
import { ServicesManagementPage } from './pages/admin/ServicesManagementPage';
import { AdminLoginPage } from './pages/admin/AdminLoginPage';
import { EmployeesManagementPage } from './pages/admin/EmployeesManagementPage';
import { ServicesPage } from './pages/public/ServicesPage';
import { BookingPage } from './pages/public/BookingPage';
import { AdminPlanningPage } from './pages/admin/AdminPlanningPage';
import { TeamPage } from './pages/public/TeamPage';
// --- L√çNEA A√ëADIDA ---
import { BusinessSettingsPage } from './pages/admin/BusinessSettingsPage'; // <-- IMPORTAMOS LA FUTURA P√ÅGINA

function App() {
  return (
    <Routes>
      {/* Rutas P√∫blicas */}
      <Route element={<PublicLayout />}>
        <Route path="/" element={<HomePage />} />
        <Route path="/services" element={<ServicesPage />} />
        <Route path="/booking" element={<BookingPage />} />
        <Route path="/team" element={<TeamPage />} />
      </Route>

      {/* Ruta de Login para Admin (sin layout) */}
      <Route path="/admin/login" element={<AdminLoginPage />} />

      {/* Rutas de Administraci√≥n Protegidas */}
      <Route path="/admin" element={<AdminLayout />}>
        <Route index element={<AdminDashboardPage />} />
        <Route path="services" element={<ServicesManagementPage />} />
        <Route path="employees" element={<EmployeesManagementPage />} />
        <Route path="planning" element={<AdminPlanningPage />} />
        {/* --- L√çNEA A√ëADIDA --- */}
        <Route path="settings" element={<BusinessSettingsPage />} /> {/* <-- L√çNEA A√ëADIDA */}
      </Route>
    </Routes>
  );
}

export default App;


// ====== [10] apps/client/src/components/admin/AbsenceCalendar.tsx ======
// File: /apps/client/src/components/admin/AbsenceCalendar.tsx (CORRECCI√ìN FINAL-FINAL)

import { useState } from 'react';
// --- L√çNEA MODIFICADA ---
import { DatePickerInput } from '@mantine/dates'; 
import { Button, Group, Text, Paper, ActionIcon, Stack, Divider, Title } from '@mantine/core';
// --- FIN DE LA MODIFICACI√ìN ---
import { IconTrash } from '@tabler/icons-react';
import dayjs from 'dayjs';

export interface Absence {
  id: string;
  startDate: Date;
  endDate: Date;
  reason?: string | null;
}

interface AbsenceCalendarProps {
  absences: Absence[];
  onAddAbsence: (dates: [Date, Date]) => void;
  onDeleteAbsence: (absenceId: string) => void;
}

export function AbsenceCalendar({ absences, onAddAbsence, onDeleteAbsence }: AbsenceCalendarProps) {
  const [value, setValue] = useState<[Date | null, Date | null]>([null, null]);

  const handleAddAbsence = () => {
    if (value[0] && value[1]) {
      const sortedDates: [Date, Date] = [
        dayjs(value[0]).startOf('day').toDate(),
        dayjs(value[1]).endOf('day').toDate()
      ].sort((a, b) => a.getTime() - b.getTime()) as [Date, Date];
      
      onAddAbsence(sortedDates);
      setValue([null, null]);
    }
  };

  return (
    <Stack>
      <Title order={4}>Seleccionar Rango de Fechas</Title>
      
      {/* --- COMPONENTE CORREGIDO --- */}
      <DatePickerInput
        type="range"
        label="Selecciona un rango de d√≠as"
        placeholder="Desde... hasta..."
        value={value}
        onChange={setValue}
        minDate={new Date()}
        clearable // A√±adimos la opci√≥n de limpiar la selecci√≥n
      />
      {/* --- FIN DE LA CORRECCI√ìN --- */}

      <Button
        onClick={handleAddAbsence}
        disabled={!value[0] || !value[1]}
      >
        A√±adir Ausencia Programada
      </Button>

      <Divider my="md" label="Ausencias Programadas" />

      <Stack>
        {absences.length > 0 ? (
          absences.map((absence) => (
            <Paper withBorder p="xs" key={absence.id}>
              <Group justify="space-between">
                <Text size="sm">
                  Del {dayjs(absence.startDate).format('DD/MM/YYYY')} al {dayjs(absence.endDate).format('DD/MM/YYYY')}
                </Text>
                <ActionIcon color="red" variant="light" onClick={() => onDeleteAbsence(absence.id)}>
                  <IconTrash size={16} />
                </ActionIcon>
              </Group>
            </Paper>
          ))
        ) : (
          <Text c="dimmed" ta="center" size="sm">
            Este empleado no tiene ausencias programadas.
          </Text>
        )}
      </Stack>
    </Stack>
  );
}


// ====== [11] apps/client/src/components/admin/AppointmentForm.tsx ======
// File: /apps/client/src/components/admin/AppointmentForm.tsx (ACTUALIZADO)

import { useEffect, useState } from 'react';
import { useForm } from '@mantine/form';
import { TextInput, Select, Button, Group, Stack, LoadingOverlay, Modal, Text } from '@mantine/core'; // Modal, Text a√±adidos
import { DateTimePicker } from '@mantine/dates';
import { notifications } from '@mantine/notifications';
import { useDisclosure } from '@mantine/hooks'; // useDisclosure a√±adido
import apiClient from '../../lib/apiClient';
import type { Service } from '@aquaclean/types';

interface Employee {
  id: string;
  name: string;
}

interface AppointmentFormProps {
  initialData?: any;
  onSuccess: () => void;
  onClose: () => void;
}

export function AppointmentForm({ initialData, onSuccess, onClose }: AppointmentFormProps) {
  const [services, setServices] = useState<{ value: string; label: string }[]>([]);
  const [employees, setEmployees] = useState<{ value: string; label: string }[]>([]);
  const [loadingData, setLoadingData] = useState(true);
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  // Estado para el modal de confirmaci√≥n de anulaci√≥n
  const [deleteModalOpened, { open: openDeleteModal, close: closeDeleteModal }] = useDisclosure(false);

  const form = useForm({
    initialValues: {
      customerName: '',
      customerEmail: '',
      serviceId: '',
      employeeId: '',
      startTime: null as Date | null,
    },
  });

  useEffect(() => {
    if (initialData) {
      form.setValues({
        customerName: initialData.customerName || '',
        customerEmail: initialData.customerEmail || '',
        serviceId: initialData.serviceId || '',
        employeeId: initialData.employeeId || '',
        startTime: initialData.start ? new Date(initialData.start) : null,
      });
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [initialData]);

  useEffect(() => {
    const fetchData = async () => {
      setLoadingData(true);
      try {
        const [servicesResponse, employeesResponse] = await Promise.all([
          apiClient.get<Service[]>('/services'),
          apiClient.get<Employee[]>('/employees'),
        ]);
        setServices(servicesResponse.data.map(s => ({ value: s.id, label: s.name })));
        setEmployees(employeesResponse.data.map(e => ({ value: e.id, label: e.name })));
      } catch (error) { console.error("Error fetching data for form", error); }
      finally { setLoadingData(false); }
    };
    fetchData();
  }, []);

  const handleSubmit = async (values: typeof form.values) => {
    setIsSubmitting(true);
    try {
      if (initialData?.type === 'edit') {
        await apiClient.put(`/admin/appointments/${initialData.appointmentId}`, values);
        notifications.show({ title: 'Cita Actualizada', message: 'Los cambios en la cita han sido guardados.', color: 'blue' });
      } else {
        await apiClient.post('/admin/appointments', values);
        notifications.show({ title: 'Cita Creada', message: 'La nueva cita ha sido guardada en el calendario.', color: 'green' });
      }
      onSuccess();
    } catch (error) {
      notifications.show({ title: 'Error al Guardar', message: 'No se pudo guardar la cita. Int√©ntalo de nuevo.', color: 'red' });
    } finally {
      setIsSubmitting(false);
    }
  };
  
  // --- L√ìGICA DE ANULACI√ìN ---
  const handleDelete = async () => {
    setIsSubmitting(true);
    try {
      await apiClient.delete(`/admin/appointments/${initialData.appointmentId}`);
      notifications.show({
        title: 'Cita Anulada',
        message: 'La cita ha sido eliminada del calendario.',
        color: 'orange',
      });
      onSuccess(); // Reutilizamos onSuccess para cerrar modal y refrescar
    } catch (error) {
      notifications.show({ title: 'Error al Anular', message: 'No se pudo anular la cita.', color: 'red' });
    } finally {
      setIsSubmitting(false);
      closeDeleteModal();
    }
  };

  return (
    <>
      <Modal opened={deleteModalOpened} onClose={closeDeleteModal} title="Confirmar Anulaci√≥n" centered>
        <Text>¬øEst√°s seguro de que quieres anular esta cita? Esta acci√≥n no se puede deshacer.</Text>
        <Group justify="flex-end" mt="md">
          <Button variant="default" onClick={closeDeleteModal}>Cancelar</Button>
          <Button color="red" onClick={handleDelete} loading={isSubmitting}>Anular Cita</Button>
        </Group>
      </Modal>

      <form onSubmit={form.onSubmit(handleSubmit)}>
        <LoadingOverlay visible={loadingData} />
        <Stack>
          <TextInput label="Nombre del Cliente" {...form.getInputProps('customerName')} required />
          <TextInput type="email" label="Email del Cliente" {...form.getInputProps('customerEmail')} required />
          <DateTimePicker label="Fecha y Hora de la Cita" {...form.getInputProps('startTime')} valueFormat="DD/MM/YYYY HH:mm" required />
          <Select label="Servicio" data={services} {...form.getInputProps('serviceId')} searchable required />
          <Select label="Empleado Asignado" data={employees} {...form.getInputProps('employeeId')} required />
          
          <Group justify="space-between" mt="md">
            {/* El bot√≥n de anular solo aparece en modo edici√≥n */}
            {initialData?.type === 'edit' ? (
              <Button variant="outline" color="red" onClick={openDeleteModal} disabled={isSubmitting}>
                Anular Cita
              </Button>
            ) : <div />} {/* Placeholder para mantener el espacio */}
            
            <Group>
              <Button variant="default" onClick={onClose} disabled={isSubmitting}>
                Cancelar
              </Button>
              <Button type="submit" loading={isSubmitting}>
                Guardar Cambios
              </Button>
            </Group>
          </Group>
        </Stack>
      </form>
    </>
  );
}


// ====== [12] apps/client/src/components/admin/ConflictResolutionModal.tsx ======
// File: /apps/client/src/components/admin/ConflictResolutionModal.tsx (NUEVO ARCHIVO)

import { Modal, Text, Alert, List, ThemeIcon, Button, Group } from '@mantine/core';
import { IconAlertTriangle, IconCalendarEvent } from '@tabler/icons-react';
import dayjs from 'dayjs';

// Definimos un tipo para las citas en conflicto que recibiremos de la API
interface Conflict {
  id: string;
  startTime: string;
  user: {
    name: string | null;
  };
}

interface ConflictResolutionModalProps {
  opened: boolean;
  onClose: () => void;
  conflicts: Conflict[];
}

export function ConflictResolutionModal({ opened, onClose, conflicts }: ConflictResolutionModalProps) {
  return (
    <Modal
      opened={opened}
      onClose={onClose}
      title="Conflicto de Citas"
      centered
      size="lg"
    >
      <Alert
        variant="light"
        color="orange"
        title="Acci√≥n Requerida"
        icon={<IconAlertTriangle />}
        mb="md"
      >
        No se puede programar la ausencia porque entra en conflicto con las siguientes {conflicts.length} citas ya existentes. Debes cancelarlas o reasignarlas manualmente antes de poder registrar la ausencia.
      </Alert>

      <Text fw={500} mb="xs">Citas en conflicto:</Text>
      <List
        spacing="xs"
        size="sm"
        center
        icon={
          <ThemeIcon color="orange" size={24} radius="xl">
            <IconCalendarEvent size={16} />
          </ThemeIcon>
        }
      >
        {conflicts.map((conflict) => (
          <List.Item key={conflict.id}>
            {dayjs(conflict.startTime).format('DD/MM/YYYY [a las] HH:mm')} - Cliente: <strong>{conflict.user.name || 'N/A'}</strong>
          </List.Item>
        ))}
      </List>
      
      <Group justify="flex-end" mt="xl">
        <Button variant="outline" onClick={onClose}>
          Entendido
        </Button>
      </Group>

    </Modal>
  );
}


// ====== [13] apps/client/src/components/admin/ScheduleEditor.tsx ======
// File: /apps/client/src/components/admin/ScheduleEditor.tsx (CORREGIDO)

import { Button, Group, ActionIcon, Stack, Text, Box } from '@mantine/core';
import { TimeInput } from '@mantine/dates'; // <-- IMPORTACI√ìN CORREGIDA
import { IconPlus, IconTrash } from '@tabler/icons-react';

type Shift = { start: string; end: string };
export type WeeklySchedule = {
  [key: string]: Shift[];
};

interface ScheduleEditorProps {
  value: WeeklySchedule;
  onChange: (schedule: WeeklySchedule) => void;
}

const DAYS_OF_WEEK = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];
const DAY_LABELS: { [key: string]: string } = {
  monday: 'Lunes',
  tuesday: 'Martes',
  wednesday: 'Mi√©rcoles',
  thursday: 'Jueves',
  friday: 'Viernes',
  saturday: 'S√°bado',
  sunday: 'Domingo',
};

export function ScheduleEditor({ value, onChange }: ScheduleEditorProps) {
  
  const handleTimeChange = (day: string, shiftIndex: number, field: 'start' | 'end', time: string) => {
    const newSchedule = { ...value };
    if (newSchedule[day]?.[shiftIndex]) {
      newSchedule[day]![shiftIndex]![field] = time;
      onChange(newSchedule);
    }
  };

  const addShift = (day: string) => {
    const newSchedule = { ...value };
    if (!newSchedule[day]) {
      newSchedule[day] = [];
    }
    newSchedule[day]!.push({ start: '09:00', end: '17:00' });
    onChange(newSchedule);
  };

  const removeShift = (day: string, shiftIndex: number) => {
    const newSchedule = { ...value };
    newSchedule[day]?.splice(shiftIndex, 1);
    onChange(newSchedule);
  };

  return (
    <Stack gap="xl">
      {DAYS_OF_WEEK.map((day) => (
        <Box key={day}>
          <Text fw={500} tt="capitalize">{DAY_LABELS[day]}</Text>
          <Stack gap="xs" mt="xs">
            {value[day]?.map((shift, index) => (
              <Group key={index} grow>
                <TimeInput
                  label="Inicio"
                  value={shift.start}
                  // --- L√çNEA CORREGIDA ---
                  onChange={(e: React.ChangeEvent<HTMLInputElement>) => handleTimeChange(day, index, 'start', e.currentTarget.value)}
                />
                <TimeInput
                  label="Fin"
                  value={shift.end}
                  // --- L√çNEA CORREGIDA ---
                  onChange={(e: React.ChangeEvent<HTMLInputElement>) => handleTimeChange(day, index, 'end', e.currentTarget.value)}
                />
                <ActionIcon
                  color="red"
                  variant="light"
                  onClick={() => removeShift(day, index)}
                  style={{ marginTop: 25 }}
                >
                  <IconTrash size={16} />
                </ActionIcon>
              </Group>
            ))}
             <Button
                leftSection={<IconPlus size={14} />}
                variant="light"
                onClick={() => addShift(day)}
                fullWidth
             >
                A√±adir Turno
            </Button>
          </Stack>
        </Box>
      ))}
    </Stack>
  );
}


// ====== [14] apps/client/src/components/admin/ServiceForm.tsx ======
// File: /apps/client/src/components/admin/ServiceForm.tsx (CORREGIDO)

import { useEffect } from 'react';
import { TextInput, Textarea, NumberInput, Button, Group, Stack, Switch } from '@mantine/core';
import { useForm, zodResolver } from '@mantine/form';
import { createServiceSchema } from '@aquaclean/types';
import type { Service } from '@aquaclean/types';

interface ServiceFormProps {
  initialData?: Partial<Service>; 
  onSuccess: (service: Partial<Service>) => void; // Aceptamos un servicio parcial
  onClose: () => void;
  isSubmitting: boolean;
}

export function ServiceForm({ initialData, onSuccess, onClose, isSubmitting }: ServiceFormProps) {
  
  const form = useForm({
    validate: zodResolver(createServiceSchema),
    initialValues: {
      name: '',
      description: '',
      duration: 60,
      prices: { standard: 50 },
      category: 'General',
      isActive: true,
    },
  });

  useEffect(() => {
    if (initialData) {
      form.setValues(initialData);
    }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [initialData]);

  // --- L√ìGICA CORREGIDA ---
  const handleSubmit = (values: typeof form.values) => {
    // Fusionamos los datos iniciales (que contienen el ID) con los nuevos valores del formulario.
    // Esto asegura que al editar, no perdamos el ID del servicio.
    const finalData = { ...initialData, ...values };
    onSuccess(finalData); 
  };
  // --- FIN DE LA CORRECCI√ìN ---

  const isEditMode = Boolean(initialData?.id);

  return (
    <form onSubmit={form.onSubmit(handleSubmit)}>
      <Stack>
        <TextInput label="Nombre del Servicio" {...form.getInputProps('name')} withAsterisk />
        <Textarea label="Descripci√≥n" {...form.getInputProps('description')} withAsterisk />
        <NumberInput label="Duraci√≥n (minutos)" {...form.getInputProps('duration')} withAsterisk />
        <NumberInput label="Precio Est√°ndar (‚Ç¨)" {...form.getInputProps('prices.standard')} withAsterisk />
        <TextInput label="Categor√≠a" {...form.getInputProps('category')} withAsterisk />
        <Switch 
          label="Servicio Activo"
          description="Si est√° inactivo, no se podr√° seleccionar para nuevas reservas."
          {...form.getInputProps('isActive', { type: 'checkbox' })}
        />
        
        <Group justify="flex-end" mt="md">
          <Button variant="default" onClick={onClose} disabled={isSubmitting}>
            Cancelar
          </Button>
          <Button type="submit" loading={isSubmitting}>
            {isEditMode ? 'Guardar Cambios' : 'Crear Servicio'}
          </Button>
        </Group>
      </Stack>
    </form>
  );
}


// ====== [15] apps/client/src/components/booking/BookingDateTimePicker.tsx ======
// File: /apps/client/src/components/booking/BookingDateTimePicker.tsx (ACTUALIZADO)

import { useState, useEffect } from 'react';
import { DatePicker } from '@mantine/dates';
import { SimpleGrid, Button, Text, Loader, Center, Stack, Title } from '@mantine/core';
import dayjs from 'dayjs';
import apiClient from '../../lib/apiClient';

interface BookingDateTimePickerProps {
  serviceDuration: number;
  onDateTimeChange: (dateTime: Date | null) => void;
  // --- L√çNEA A√ëADIDA ---
  employeeId?: string | null; 
}

export function BookingDateTimePicker({ serviceDuration, onDateTimeChange, employeeId }: BookingDateTimePickerProps) {
  const [selectedDate, setSelectedDate] = useState<Date | null>(new Date());
  const [availableSlots, setAvailableSlots] = useState<string[]>([]);
  const [selectedSlot, setSelectedSlot] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // --- L√ìGICA MODIFICADA ---
  useEffect(() => {
    if (!selectedDate) {
      setAvailableSlots([]);
      return;
    }

    const fetchAvailability = async () => {
      setLoading(true);
      setError(null);
      setSelectedSlot(null);
      onDateTimeChange(null); // Reseteamos la fecha seleccionada al cambiar de d√≠a/empleado

      try {
        const formattedDate = dayjs(selectedDate).format('YYYY-MM-DD');
        const response = await apiClient.get<string[]>('/availability', {
          params: {
            date: formattedDate,
            // Si hay un employeeId y no es 'any', lo enviamos. Si no, no lo incluimos.
            ...(employeeId && employeeId !== 'any' && { employeeId }),
          },
        });
        setAvailableSlots(response.data);
      } catch (err) {
        console.error('Error fetching availability:', err);
        setError('No se pudo cargar la disponibilidad.');
      } finally {
        setLoading(false);
      }
    };

    fetchAvailability();
  // El useEffect ahora tambi√©n depende de employeeId
  }, [selectedDate, employeeId, onDateTimeChange]);
  // --- FIN DE LA MODIFICACI√ìN ---


  const handleSlotSelect = (slot: string) => {
    setSelectedSlot(slot);
    if (selectedDate) {
      const hours = parseInt(slot.split(':')[0] ?? '0', 10);
      const minutes = parseInt(slot.split(':')[1] ?? '0', 10);
      const finalDateTime = dayjs(selectedDate).hour(hours).minute(minutes).toDate();
      onDateTimeChange(finalDateTime);
    }
  };

  return (
    <Stack>
      <DatePicker
        value={selectedDate}
        onChange={setSelectedDate}
        minDate={new Date()}
        weekendDays={[0]}
      />

      <Stack mt="lg">
        <Title order={4}>Selecciona una hora</Title>
        {loading && <Center><Loader /></Center>}
        {error && <Text c="red">{error}</Text>}
        
        {!loading && !error && availableSlots.length === 0 && (
          <Text c="dimmed">No hay huecos disponibles para esta selecci√≥n.</Text>
        )}

        {!loading && !error && availableSlots.length > 0 && (
          <SimpleGrid cols={{ base: 3, sm: 4 }}>
            {availableSlots.map((slot) => (
              <Button
                key={slot}
                variant={selectedSlot === slot ? 'filled' : 'outline'}
                onClick={() => handleSlotSelect(slot)}
              >
                {slot}
              </Button>
            ))}
          </SimpleGrid>
        )}
      </Stack>
    </Stack>
  );
}


// ====== [16] apps/client/src/components/common/PublicFooter.module.css ======
/* File: /apps/client/src/components/common/PublicFooter.module.css (CORREGIDO) */

.footer {
  margin-top: calc(var(--mantine-spacing-xl) * 2);
  border-top: 1px solid light-dark(var(--mantine-color-gray-2), var(--mantine-color-dark-5));
  padding-top: var(--mantine-spacing-lg);
  padding-bottom: var(--mantine-spacing-lg);
}

.inner {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

/* Usamos una media query est√°ndar de CSS */
@media (max-width: 576px) {
  .inner {
    flex-direction: column;
    align-items: center;
    gap: var(--mantine-spacing-md);
  }
}


// ====== [17] apps/client/src/components/common/PublicFooter.tsx ======
// File: /apps/client/src/components/common/PublicFooter.tsx (CORREGIDO)

import { Container, Text, Anchor, Group } from '@mantine/core';
import classes from './PublicFooter.module.css';

export function PublicFooter() {
  return (
    <footer className={classes.footer}>
      <Container className={classes.inner}>
        <Text c="dimmed" size="sm">
          &copy; {new Date().getFullYear()} AquaClean Car Wash. Todos los derechos reservados.
        </Text>
        <Group gap="xs" justify="flex-end" wrap="nowrap">
          {/* Aqu√≠ podr√≠amos a√±adir enlaces a redes sociales o a p√°ginas como "Pol√≠tica de Privacidad" */}
          <Anchor c="dimmed" href="#" size="sm">
            T√©rminos
          </Anchor>
          <Anchor c="dimmed" href="#" size="sm">
            Privacidad
          </Anchor>
        </Group>
      </Container>
    </footer>
  );
}


// ====== [18] apps/client/src/components/common/PublicHeader.module.css ======
/* File: /apps/client/src/components/common/PublicHeader.module.css (NUEVO ARCHIVO) */

.header {
  height: 60px;
  border-bottom: 1px solid light-dark(var(--mantine-color-gray-3), var(--mantine-color-dark-4));
}

.inner {
  height: 60px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.link {
  display: block;
  line-height: 1;
  padding: 8px 12px;
  border-radius: var(--mantine-radius-sm);
  text-decoration: none;
  color: light-dark(var(--mantine-color-gray-7), var(--mantine-color-dark-0));
  font-size: var(--mantine-font-size-sm);
  font-weight: 500;

  &:hover {
    background-color: light-dark(var(--mantine-color-gray-0), var(--mantine-color-dark-6));
  }
}

.linkActive {
  &,
  &:hover {
    background-color: var(--mantine-color-blue-light);
    color: var(--mantine-color-blue-light-color);
  }
}


// ====== [19] apps/client/src/components/common/PublicHeader.tsx ======
// File: /apps/client/src/components/common/PublicHeader.tsx (ACTUALIZADO)

import { NavLink, useNavigate } from 'react-router-dom';
import { Container, Group, Button, Image } from '@mantine/core';
import classes from './PublicHeader.module.css';

export function PublicHeader() {
  const navigate = useNavigate();

  return (
    <header className={classes.header}>
      <Container size="md" className={classes.inner}>
        <Image
          src="/logo.png"
          alt="Logo de AquaClean Car Wash"
          h={40}
          fit="contain"
          style={{ cursor: 'pointer' }}
          onClick={() => navigate('/')}
        />

        <Group gap={5} visibleFrom="xs">
          <NavLink to="/" className={({ isActive }) => `${classes.link} ${isActive ? classes.linkActive : ''}`} end>
            Inicio
          </NavLink>
          <NavLink to="/services" className={({ isActive }) => `${classes.link} ${isActive ? classes.linkActive : ''}`}>
            Servicios
          </NavLink>
          <NavLink to="/team" className={({ isActive }) => `${classes.link} ${isActive ? classes.linkActive : ''}`}>
            Nuestro Equipo
          </NavLink>
        </Group>

        <Group>
          {/* --- L√çNEA MODIFICADA --- */}
          <Button onClick={() => navigate('/booking')}>Reservar Cita</Button>
        </Group>
      </Container>
    </header>
  );
}


// ====== [20] apps/client/src/custom.d.ts ======
// File: /apps/client/src/custom.d.ts (NUEVO ARCHIVO)

// Este archivo le dice a TypeScript c√≥mo tratar los archivos CSS Modules.
// Declara que cualquier importaci√≥n de un archivo que termine en .module.css
// exportar√° por defecto un objeto donde las claves y los valores son strings.
declare module '*.module.css' {
  const classes: { readonly [key: string]: string };
  export default classes;
}


// ====== [21] apps/client/src/layouts/AdminLayout.tsx ======
// File: /apps/client/src/layouts/AdminLayout.tsx (ACTUALIZADO)

import { Outlet, Navigate, NavLink } from 'react-router-dom';
import { AppShell, Burger, Group, Title } from '@mantine/core';
import { useDisclosure } from '@mantine/hooks';

export function AdminLayout() {
  const [opened, { toggle }] = useDisclosure();

  const authToken = localStorage.getItem('authToken');

  if (!authToken) {
    return <Navigate to="/admin/login" replace />;
  }

  // Estilos para los NavLink de react-router-dom
  const linkStyles = {
    display: 'block',
    padding: '8px 16px',
    borderRadius: '4px',
    textDecoration: 'none',
    color: 'black',
  };

  const activeLinkStyles = {
    backgroundColor: '#e9ecef',
    fontWeight: 500,
  };

  return (
    <AppShell
      header={{ height: 60 }}
      navbar={{ width: 300, breakpoint: 'sm', collapsed: { mobile: !opened } }} // <-- desktop: true eliminado para que se vea en desktop
      padding="md"
    >
      <AppShell.Header>
        <Group h="100%" px="md">
          <Burger opened={opened} onClick={toggle} hiddenFrom="sm" size="sm" />
          <Title order={4}>Panel de Administraci√≥n de AquaClean</Title>
        </Group>
      </AppShell.Header>

      <AppShell.Navbar p="md">
         <NavLink 
            to="/admin" 
            end // 'end' asegura que solo est√© activo en la ruta exacta
            style={({ isActive }) => ({ ...linkStyles, ...(isActive ? activeLinkStyles : {}) })}
         >
            Dashboard
         </NavLink>
         <NavLink 
            to="/admin/planning" 
            style={({ isActive }) => ({ ...linkStyles, ...(isActive ? activeLinkStyles : {}) })}
         >
            Planning
         </NavLink>
         <NavLink 
            to="/admin/services" 
            style={({ isActive }) => ({ ...linkStyles, ...(isActive ? activeLinkStyles : {}) })}
         >
            Servicios
         </NavLink>
         <NavLink 
            to="/admin/employees" 
            style={({ isActive }) => ({ ...linkStyles, ...(isActive ? activeLinkStyles : {}) })}
         >
            Empleados
         </NavLink>
         {/* --- L√çNEA A√ëADIDA --- */}
         <NavLink 
            to="/admin/settings" 
            style={({ isActive }) => ({ ...linkStyles, ...(isActive ? activeLinkStyles : {}) })}
         >
            Ajustes del Negocio
         </NavLink>
         {/* --- FIN DE LA L√çNEA A√ëADIDA --- */}
      </AppShell.Navbar>
      
      <AppShell.Main>
        <Outlet /> 
      </AppShell.Main>
    </AppShell>
  );
}


// ====== [22] apps/client/src/layouts/PublicLayout.tsx ======
// File: /apps/client/src/layouts/PublicLayout.tsx (ACTUALIZADO)

import { Outlet } from 'react-router-dom';
import { AppShell, Container } from '@mantine/core';

// Importamos los componentes que acabamos de crear
import { PublicHeader } from '../components/common/PublicHeader';
import { PublicFooter } from '../components/common/PublicFooter';

export function PublicLayout() {
  // Simplificamos el AppShell ya que no necesitamos la barra lateral (navbar)
  // que s√≠ usamos en el panel de admin.
  return (
    <AppShell header={{ height: 60 }} padding={0}>
      <AppShell.Header>
        <PublicHeader />
      </AppShell.Header>

      <AppShell.Main>
        {/* Usamos un Container para centrar y limitar el ancho del contenido de cada p√°gina */}
        <Container size="lg" py="xl">
          <Outlet />
        </Container>
      </AppShell.Main>
      
      {/* El footer se renderiza aqu√≠, despu√©s del contenido principal */}
      <PublicFooter />
    </AppShell>
  );
}


// ====== [23] apps/client/src/lib/apiClient.ts ======
// File: /apps/client/src/lib/apiClient.ts

import axios from 'axios';

// Creamos una instancia de Axios con una configuraci√≥n base.
// Todas las llamadas que hagamos usando 'apiClient' partir√°n de esta URL.
const apiClient = axios.create({
  // La URL base de nuestra API de backend.
  // Para un proyecto en producci√≥n, esto vendr√≠a de una variable de entorno,
  // pero para el desarrollo local, esta configuraci√≥n es perfecta.
  baseURL: 'http://localhost:3001/api',

  // Opcional: un tiempo de espera de 10 segundos para las peticiones.
  timeout: 10000,

  // Opcional: encabezados por defecto que se enviar√°n con cada petici√≥n.
  headers: {
    'Content-Type': 'application/json',
  },
});

export default apiClient;


// ====== [24] apps/client/src/main.tsx ======
// File: /apps/client/src/main.tsx (ACTUALIZADO)
import React from 'react';
import ReactDOM from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom';
import { MantineProvider } from '@mantine/core';
import { Notifications } from '@mantine/notifications'; // <-- 1. IMPORTAR
import App from './App';

import '@mantine/core/styles.css';
import '@mantine/dates/styles.css';
import '@mantine/notifications/styles.css'; // <-- 2. A√ëADIR ESTILOS

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <MantineProvider>
      <Notifications /> {/* <-- 3. A√ëADIR COMPONENTE */}
      <BrowserRouter>
        <App />
      </BrowserRouter>
    </MantineProvider>
  </React.StrictMode>
);


// ====== [25] apps/client/src/pages/admin/AdminDashboardPage.tsx ======
// File: /apps/client/src/pages/admin/AdminDashboardPage.tsx
export function AdminDashboardPage() {
  return <h3>Dashboard Principal</h3>;
}


// ====== [26] apps/client/src/pages/admin/AdminLoginPage.tsx ======
import { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Container,
  Title,
  Paper,
  TextInput,
  PasswordInput,
  Button,
  Text,
  LoadingOverlay,
  Stack,
} from '@mantine/core';
import apiClient from '../../lib/apiClient';

export function AdminLoginPage() {
  const navigate = useNavigate();
  const [email, setEmail] = useState('admin@aquaclean.com'); // Pre-rellenado para facilitar las pruebas
  const [password, setPassword] = useState('password123'); // Pre-rellenado para facilitar las pruebas
  const [error, setError] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);

  const handleLogin = async (event: React.FormEvent) => {
    event.preventDefault();
    setLoading(true);
    setError(null);

    try {
      const response = await apiClient.post('/auth/login', { email, password });
      
      // Aqu√≠ es donde guardaremos el token m√°s adelante (ej. en Zustand)
      console.log('Login exitoso:', response.data);
      // Por ahora, solo guardamos en localStorage para que funcione la protecci√≥n de rutas
      localStorage.setItem('authToken', response.data.token);
      
      // Redirigimos al dashboard de admin
      navigate('/admin');

    } catch (err: any) {
      console.error('Error en el login:', err);
      if (err.response && err.response.data && err.response.data.message) {
        setError(err.response.data.message);
      } else {
        setError('Ha ocurrido un error inesperado. Int√©ntalo de nuevo.');
      }
    } finally {
      setLoading(false);
    }
  };

  return (
    <Container size={420} my={40}>
      <Title ta="center">AquaClean Admin</Title>
      <Text c="dimmed" size="sm" ta="center" mt={5}>
        Inicia sesi√≥n para acceder al panel de administraci√≥n
      </Text>

      <Paper withBorder shadow="md" p={30} mt={30} radius="md" component="form" onSubmit={handleLogin}>
        <LoadingOverlay visible={loading} zIndex={1000} overlayProps={{ radius: 'sm', blur: 2 }} />
        <Stack gap="md">
          <TextInput
            label="Email"
            placeholder="tu@email.com"
            required
            value={email}
            onChange={(event) => setEmail(event.currentTarget.value)}
          />
          <PasswordInput
            label="Contrase√±a"
            placeholder="Tu contrase√±a"
            required
            value={password}
            onChange={(event) => setPassword(event.currentTarget.value)}
          />
          {error && (
            <Text c="red" size="sm" ta="center">
              {error}
            </Text>
          )}
          <Button fullWidth mt="xl" type="submit">
            Iniciar Sesi√≥n
          </Button>
        </Stack>
      </Paper>
    </Container>
  );
}


// ====== [27] apps/client/src/pages/admin/AdminPlanningPage.tsx ======
// File: /apps/client/src/pages/admin/AdminPlanningPage.tsx (ACTUALIZADO)

import { useState, useEffect } from 'react';
import FullCalendar from '@fullcalendar/react';
import { EventDropArg, EventClickArg } from '@fullcalendar/core';
import dayGridPlugin from '@fullcalendar/daygrid';
import timeGridPlugin from '@fullcalendar/timegrid';
import resourceTimelinePlugin from '@fullcalendar/resource-timeline';
import interactionPlugin from '@fullcalendar/interaction';
import { Alert, Modal } from '@mantine/core';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../lib/apiClient';
import { AppointmentForm } from '../../components/admin/AppointmentForm';

interface Resource {
  id: string;
  title: string;
}

export function AdminPlanningPage() {
  const [events, setEvents] = useState([]);
  const [resources, setResources] = useState<Resource[]>([]);
  const [error, setError] = useState<string | null>(null);
  const [opened, { open, close }] = useDisclosure(false);
  const [modalData, setModalData] = useState<any>(null);

  const fetchData = async () => {
    try {
      const [appointmentsResponse, employeesResponse] = await Promise.all([
        apiClient.get('/admin/appointments'),
        apiClient.get('/employees'),
      ]);

      setEvents(appointmentsResponse.data);

      const employeeResources = employeesResponse.data.map((emp: { id: string; name: string }) => ({
        id: emp.id,
        title: emp.name,
      }));
      setResources(employeeResources);
    } catch (err) {
      console.error('Error fetching data for planning:', err);
      setError('No se pudieron cargar los datos del planning. Int√©ntalo de nuevo m√°s tarde.');
    }
  };

  useEffect(() => {
    fetchData();
  }, []);

  const handleEventDrop = async (dropInfo: EventDropArg) => {
    try {
      const { event } = dropInfo;
      const updateData = { start: event.start, end: event.end };
      await apiClient.put(`/admin/appointments/${event.id}`, updateData);
    } catch (err) {
      console.error('Error al reagendar la cita:', err);
      dropInfo.revert();
    }
  };

  const handleDateClick = (arg: any) => {
    setModalData({ type: 'new', start: arg.date, employeeId: arg.resource?.id });
    open();
  };

  // --- L√ìGICA CORREGIDA ---
  // Ahora, arg.event.extendedProps viene lleno de datos desde nuestra API mejorada.
  // Al hacer spread (...), pasamos todos esos datos al modal.
  const handleEventClick = (arg: EventClickArg) => {
    setModalData({
      type: 'edit',
      ...arg.event.extendedProps,
    });
    open();
  };
  
  const handleFormSuccess = () => {
    close();
    fetchData();
  };

  if (error) {
    return <Alert title="Error" color="red" variant="light">{error}</Alert>;
  }

  return (
    <>
      <Modal opened={opened} onClose={close} title={modalData?.type === 'new' ? 'Crear Nueva Cita' : 'Editar Cita'} centered>
        <AppointmentForm
          initialData={modalData}
          onSuccess={handleFormSuccess}
          onClose={close}
        />
      </Modal>

      <div style={{ height: 'calc(100vh - 60px - 32px)' }}>
        <FullCalendar
          plugins={[resourceTimelinePlugin, dayGridPlugin, timeGridPlugin, interactionPlugin]}
          initialView="resourceTimelineWeek"
          headerToolbar={{
            left: 'prev,next today',
            center: 'title',
            right: 'resourceTimelineDay,resourceTimelineWeek,dayGridMonth',
          }}
          locale="es"
          editable={true}
          events={events}
          resources={resources}
          resourceAreaHeaderContent="Empleados"
          schedulerLicenseKey="GPL-My-Project-Is-Open-Source"
          slotMinWidth={50}
          height="100%"
          eventDrop={handleEventDrop}
          dateClick={handleDateClick}
          eventClick={handleEventClick}
        />
      </div>
    </>
  );
}


// ====== [28] apps/client/src/pages/admin/BusinessSettingsPage.tsx ======
// File: /apps/client/src/pages/admin/BusinessSettingsPage.tsx (CORRECCI√ìN FINAL DE ZONA HORARIA)

import { useState, useEffect } from 'react';
import { Title, Text, Paper, LoadingOverlay, Alert, Select, Button, Group, Stack, Divider, SimpleGrid, TextInput, ActionIcon, List, ThemeIcon } from '@mantine/core';
import { useForm, zodResolver } from '@mantine/form';
import { z } from 'zod';
import { notifications } from '@mantine/notifications';
import { IconAlertCircle, IconCalendar, IconClock, IconTrash } from '@tabler/icons-react';
import { DatePicker, TimeInput } from '@mantine/dates';
import dayjs from 'dayjs';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../lib/apiClient';
import { ScheduleEditor, WeeklySchedule } from '../../components/admin/ScheduleEditor';
import { ConflictResolutionModal } from '../../components/admin/ConflictResolutionModal';


// --- Tipos de datos ---
const settingsSchema = z.object({
  defaultServiceId: z.string().min(1, 'Debes seleccionar un servicio por defecto.'),
  weeklySchedule: z.record(z.string(), z.unknown()).optional(),
});
interface Service { id: string; name: string; duration: number; }
interface SettingsData { settings: { defaultServiceId: string | null; weeklySchedule: WeeklySchedule; defaultService: Service | null; }; allServices: Service[];}
interface DateOverride { id: string; date: string; reason?: string | null; openTime?: string | null; closeTime?: string | null; }
interface Conflict { id: string; startTime: string; user: { name: string | null; }; }


export function BusinessSettingsPage() {
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [allServices, setAllServices] = useState<{ value: string; label: string }[]>([]);
  
  const [overrides, setOverrides] = useState<DateOverride[]>([]);
  const [selectedDate, setSelectedDate] = useState<Date | null>(null);
  const [overrideReason, setOverrideReason] = useState('');
  const [overrideOpenTime, setOverrideOpenTime] = useState('');
  const [overrideCloseTime, setOverrideCloseTime] = useState('');

  const [conflictingAppointments, setConflictingAppointments] = useState<Conflict[]>([]);
  const [conflictModalOpened, { open: openConflictModal, close: closeConflictModal }] = useDisclosure(false);

  const form = useForm({
    initialValues: { defaultServiceId: '', weeklySchedule: {} as WeeklySchedule },
    validate: zodResolver(settingsSchema),
  });

  const fetchAllSettings = async () => {
    try {
      setLoading(true);
      const [settingsResponse, overridesResponse] = await Promise.all([
        apiClient.get<SettingsData>('/admin/settings'),
        apiClient.get<DateOverride[]>('/admin/overrides'),
      ]);
      const { settings, allServices } = settingsResponse.data;
      form.setValues({
        defaultServiceId: settings.defaultServiceId || '',
        weeklySchedule: settings.weeklySchedule || {},
      });
      setAllServices(allServices.map(s => ({ value: s.id, label: `${s.name} (${s.duration} min)` })));
      setOverrides(overridesResponse.data);
    } catch (err) {
      setError('No se pudo cargar la configuraci√≥n del negocio.');
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => { fetchAllSettings(); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const handleSubmit = async (values: typeof form.values) => {
    try {
      await apiClient.put('/admin/settings', values);
      notifications.show({
        title: '¬°Guardado!',
        message: 'La configuraci√≥n general del negocio se ha actualizado correctamente.',
        color: 'green',
      });
    } catch (err) {
      notifications.show({
        title: 'Error',
        message: 'No se pudo guardar la configuraci√≥n general. Int√©ntalo de nuevo.',
        color: 'red',
      });
    }
  };
  
  const handleAddOverride = async () => {
    if (!selectedDate) return;
    try {
      // --- L√çNEA CORREGIDA ---
      // Enviamos la fecha como un string 'YYYY-MM-DD' para evitar problemas de zona horaria.
      await apiClient.post('/admin/overrides', {
        date: dayjs(selectedDate).format('YYYY-MM-DD'),
        reason: overrideReason,
        openTime: overrideOpenTime || null,
        closeTime: overrideCloseTime || null,
      });
      notifications.show({ title: 'Configuraci√≥n de Fecha Guardada', message: 'El horario especial o cierre ha sido guardado.', color: 'green' });
      // Resetear formulario
      setSelectedDate(null);
      setOverrideReason('');
      setOverrideOpenTime('');
      setOverrideCloseTime('');
      fetchAllSettings(); // Recargar todo
    } catch (err: any) {
      if (err.response && err.response.status === 409) {
        setConflictingAppointments(err.response.data.conflicts || []);
        openConflictModal();
      } else {
        const errorMsg = err.response?.data?.message || 'No se pudo guardar la configuraci√≥n de la fecha.';
        notifications.show({ title: 'Error', message: errorMsg, color: 'red' });
      }
    }
  };

  const handleDeleteOverride = async (overrideId: string) => {
    try {
      await apiClient.delete(`/admin/overrides/${overrideId}`);
      notifications.show({ title: 'Configuraci√≥n Eliminada', message: 'La fecha vuelve a su horario normal.', color: 'orange' });
      fetchAllSettings(); // Recargar
    } catch (error) {
      notifications.show({ title: 'Error', message: 'No se pudo eliminar la configuraci√≥n.', color: 'red' });
    }
  };

  const overrideDates = overrides.map(o => dayjs(o.date).format('YYYY-MM-DD'));

  return (
    <>
      <ConflictResolutionModal opened={conflictModalOpened} onClose={closeConflictModal} conflicts={conflictingAppointments} />
      
      <Paper component="form" onSubmit={form.onSubmit(handleSubmit)} shadow="md" p="xl" withBorder pos="relative">
        <LoadingOverlay visible={loading} />
        <Title order={2}>Ajustes del Negocio</Title>
        <Text c="dimmed" mt="sm" mb="xl">Configura aqu√≠ las opciones principales de la aplicaci√≥n.</Text>

        {error && <Alert icon={<IconAlertCircle size="1rem" />} title="Error de Carga" color="red" mb="xl">{error}</Alert>}

        <Stack>
          <Title order={4}>Configuraci√≥n de Reservas</Title>
          <Select label="Servicio por Defecto para las Reservas" description="Este es el √∫nico servicio que se ofrecer√° a los clientes al reservar." data={allServices} disabled={loading} withAsterisk {...form.getInputProps('defaultServiceId')} />
          
          <Divider my="xl" label="Horario de Apertura del Negocio" />
          <Title order={4}>Horario Semanal Est√°ndar</Title>
          <Text c="dimmed" size="sm" mb="md">Define las horas de apertura y cierre para cada d√≠a. Esto establecer√° el marco general en el que los empleados pueden trabajar.</Text>
          <ScheduleEditor value={form.values.weeklySchedule} onChange={(schedule) => form.setFieldValue('weeklySchedule', schedule)} />
          
          <Divider my="xl" label="Horarios Especiales y D√≠as de Cierre" />
          <Title order={4}>Anulaciones por Fecha</Title>
          <Text c="dimmed" size="sm" mb="md">
            Selecciona un d√≠a para definir un horario especial o marcarlo como cerrado. Esta configuraci√≥n anular√° el horario semanal est√°ndar solo para esa fecha.
          </Text>
          
          <SimpleGrid cols={{ base: 1, md: 2 }} spacing="xl">
            <Stack>
              <DatePicker
                value={selectedDate}
                onChange={setSelectedDate}
                minDate={new Date()}
                renderDay={(date) => {
                  const day = date.getDate();
                  const isOverridden = overrideDates.includes(dayjs(date).format('YYYY-MM-DD'));
                  return (
                    <div style={{ position: 'relative' }}>
                      {day}
                      {isOverridden && <div style={{ position: 'absolute', top: -2, right: 0, width: 6, height: 6, borderRadius: '50%', backgroundColor: 'var(--mantine-color-red-5)' }} />}
                    </div>
                  );
                }}
              />
              {selectedDate && (
                <Paper withBorder p="sm" mt="md">
                  <Text size="sm" fw={500}>Configuraci√≥n para: {dayjs(selectedDate).format('DD/MM/YYYY')}</Text>
                  <TextInput label="Raz√≥n (opcional)" placeholder="Ej: Festivo, Evento" value={overrideReason} onChange={(e) => setOverrideReason(e.currentTarget.value)} mt="xs" />
                  <Text size="xs" c="dimmed" mt="md">Deja las horas en blanco para un cierre de d√≠a completo.</Text>
                  <Group grow>
                    <TimeInput label="Nueva Apertura" value={overrideOpenTime} onChange={(e) => setOverrideOpenTime(e.currentTarget.value)} />
                    <TimeInput label="Nuevo Cierre" value={overrideCloseTime} onChange={(e) => setOverrideCloseTime(e.currentTarget.value)} />
                  </Group>
                  <Button onClick={handleAddOverride} fullWidth mt="md">Guardar Configuraci√≥n de Fecha</Button>
                </Paper>
              )}
            </Stack>
            <Stack>
              <Title order={5}>Fechas con Configuraci√≥n Especial</Title>
              {overrides.length > 0 ? (
                <List spacing="sm" size="sm">
                  {overrides.map(override => (
                    <List.Item
                      key={override.id}
                      icon={
                        <ThemeIcon color={override.openTime ? 'blue' : 'red'} size={24} radius="xl">
                          {override.openTime ? <IconClock size="1rem" /> : <IconCalendar size="1rem" />}
                        </ThemeIcon>
                      }
                    >
                      <Group justify="space-between">
                        <div>
                          <Text>{dayjs(override.date).format('DD/MM/YYYY')}</Text>
                          <Text size="xs" c="dimmed">
                            {override.openTime ? `Horario: ${override.openTime} - ${override.closeTime}` : 'Cerrado todo el d√≠a'}
                            {override.reason && ` (${override.reason})`}
                          </Text>
                        </div>
                        <ActionIcon variant="light" color="red" size="sm" onClick={() => handleDeleteOverride(override.id)}>
                          <IconTrash size={14} />
                        </ActionIcon>
                      </Group>
                    </List.Item>
                  ))}
                </List>
              ) : (
                <Text c="dimmed" size="sm">No hay configuraciones especiales programadas.</Text>
              )}
            </Stack>
          </SimpleGrid>

          <Group justify="flex-end" mt="xl">
            <Button type="submit" disabled={loading}>Guardar Cambios Generales</Button>
          </Group>
        </Stack>
      </Paper>
    </>
  );
}


// ====== [29] apps/client/src/pages/admin/EmployeesManagementPage.tsx ======
// File: /apps/client/src/pages/admin/EmployeesManagementPage.tsx (COMPLETO Y CORREGIDO)

import { useEffect, useState } from 'react';
import { Table, Title, Button, Modal, TextInput, Select, Group, Avatar, Text, Flex, Badge, SegmentedControl, Tabs, LoadingOverlay, Stack, Box, Textarea } from '@mantine/core';
import { useDisclosure } from '@mantine/hooks';
import { useForm, zodResolver } from '@mantine/form';
import { notifications } from '@mantine/notifications';
import { IconArchive, IconUserPlus, IconUserCheck, IconUser, IconClock, IconBeach } from '@tabler/icons-react';
import apiClient from '../../lib/apiClient';
import { createEmployeeSchema } from '@aquaclean/types';
import { ScheduleEditor, WeeklySchedule } from '../../components/admin/ScheduleEditor';
import { AbsenceCalendar, Absence } from '../../components/admin/AbsenceCalendar';
import { ConflictResolutionModal } from '../../components/admin/ConflictResolutionModal';

export interface Employee {
  id: string; name: string; email: string; role: 'ADMIN' | 'EMPLOYEE';
  status: 'ACTIVE' | 'ARCHIVED'; imageUrl?: string | null; bio?: string | null;
  workSchedule?: WeeklySchedule;
}
interface Conflict { id: string; startTime: string; user: { name: string | null; }; }

export function EmployeesManagementPage() {
  const [employees, setEmployees] = useState<Employee[]>([]);
  const [loading, setLoading] = useState(true);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [selectedEmployee, setSelectedEmployee] = useState<Employee | undefined>(undefined);
  const [employeeAbsences, setEmployeeAbsences] = useState<Absence[]>([]);
  const [statusFilter, setStatusFilter] = useState('ACTIVE');
  
  const [conflictingAppointments, setConflictingAppointments] = useState<Conflict[]>([]);
  const [conflictModalOpened, { open: openConflictModal, close: closeConflictModal }] = useDisclosure(false);

  const [modalOpened, { open: openModal, close: closeModal }] = useDisclosure(false);

  const form = useForm({
    validate: zodResolver(createEmployeeSchema),
    initialValues: { name: '', email: '', role: 'EMPLOYEE', bio: '', imageUrl: '', workSchedule: {} as WeeklySchedule },
  });

  const fetchEmployees = async () => {
    try { setLoading(true); const response = await apiClient.get<Employee[]>(`/employees?status=${statusFilter}`); setEmployees(response.data);
    } catch (err) { notifications.show({ title: 'Error', message: 'No se pudieron cargar los empleados.', color: 'red' });
    } finally { setLoading(false); }
  };

  useEffect(() => { fetchEmployees(); }, [statusFilter]);

  const handleCreate = () => {
    form.reset(); setSelectedEmployee(undefined); setEmployeeAbsences([]); openModal();
  };

  const handleEdit = async (employee: Employee) => {
    setLoading(true); setSelectedEmployee(employee);
    const sanitizedEmployeeData = { ...employee, bio: employee.bio || '', imageUrl: employee.imageUrl || '', workSchedule: employee.workSchedule || {}, };
    form.setValues(sanitizedEmployeeData);
    try {
        const absencesResponse = await apiClient.get<Absence[]>(`/employees/${employee.id}/absences`);
        setEmployeeAbsences(absencesResponse.data); openModal();
    } catch (error) { notifications.show({ title: 'Error', message: 'No se pudieron cargar las ausencias del empleado.', color: 'red' });
    } finally { setLoading(false); }
  };

  const handleFormSubmit = async (values: typeof form.values) => {
    setIsSubmitting(true);
    try {
      if (selectedEmployee) { await apiClient.put(`/employees/${selectedEmployee.id}`, values);
        notifications.show({ title: '¬°Guardado!', message: 'Los datos del empleado han sido actualizados.', color: 'green' });
      } else { await apiClient.post('/employees', values);
        notifications.show({ title: '¬°Creado!', message: 'El nuevo empleado ha sido a√±adido.', color: 'green' });
      }
      fetchEmployees(); closeModal();
    } catch (err) { notifications.show({ title: 'Error', message: 'No se pudo guardar el empleado.', color: 'red' });
    } finally { setIsSubmitting(false); }
  };

  const handleStatusChange = async (employee: Employee, status: 'ACTIVE' | 'ARCHIVED') => {
    try { await apiClient.put(`/employees/${employee.id}`, { status });
      notifications.show({ title: `Empleado ${status === 'ACTIVE' ? 'Reactivado' : 'Archivado'}`, message: `${employee.name} ha sido actualizado.`, color: status === 'ACTIVE' ? 'teal' : 'orange' });
      fetchEmployees();
    } catch (err) { notifications.show({ title: 'Error', message: 'No se pudo cambiar el estado del empleado.', color: 'red' }); }
  };

  const handleAddAbsence = async (dates: [Date, Date]) => {
      if (!selectedEmployee) return;
      try {
          const newAbsence = await apiClient.post<Absence>(`/employees/${selectedEmployee.id}/absences`, { startDate: dates[0], endDate: dates[1] });
          setEmployeeAbsences([...employeeAbsences, newAbsence.data]);
          notifications.show({ title: 'Ausencia A√±adida', message: 'El periodo de ausencia ha sido guardado.', color: 'green' });
      } catch (error: any) { 
          if (error.response && error.response.status === 409) {
              setConflictingAppointments(error.response.data.conflicts || []);
              openConflictModal();
          } else {
              notifications.show({ title: 'Error', message: 'No se pudo guardar la ausencia.', color: 'red' });
          }
      }
  };

  const handleDeleteAbsence = async (absenceId: string) => {
      if (!selectedEmployee) return;
      try {
          await apiClient.delete(`/employees/${selectedEmployee.id}/absences/${absenceId}`);
          setEmployeeAbsences(employeeAbsences.filter(a => a.id !== absenceId));
          notifications.show({ title: 'Ausencia Eliminada', message: 'El periodo de ausencia ha sido eliminado.', color: 'orange' });
      } catch (error) { notifications.show({ title: 'Error', message: 'No se pudo eliminar la ausencia.', color: 'red' }); }
  };
  
  return (
    <div>
      <Modal opened={modalOpened} onClose={closeModal} title={selectedEmployee ? `Editando a ${selectedEmployee.name}` : 'A√±adir Nuevo Empleado'} size="xl" centered>
        <LoadingOverlay visible={isSubmitting || loading} />
        <Tabs defaultValue="profile">
          <Tabs.List>
            <Tabs.Tab value="profile" leftSection={<IconUser size={14} />}>Perfil</Tabs.Tab>
            <Tabs.Tab value="schedule" leftSection={<IconClock size={14} />}>Horario Laboral</Tabs.Tab>
            <Tabs.Tab value="absences" leftSection={<IconBeach size={14} />}>Ausencias</Tabs.Tab>
          </Tabs.List>

          <form onSubmit={form.onSubmit(handleFormSubmit)}>
            {/* --- SECCI√ìN RESTAURADA --- */}
            <Tabs.Panel value="profile" pt="md">
              <Stack>
                <TextInput label="Nombre Completo" {...form.getInputProps('name')} withAsterisk />
                <TextInput label="Email" type="email" {...form.getInputProps('email')} withAsterisk />
                <Select
                    label="Rol en el sistema"
                    data={[{ value: 'EMPLOYEE', label: 'Empleado' }, { value: 'ADMIN', label: 'Administrador' }]}
                    {...form.getInputProps('role')}
                    withAsterisk
                />
                <TextInput label="URL de la Foto" {...form.getInputProps('imageUrl')} />
                <Textarea label="Biograf√≠a" {...form.getInputProps('bio')} /> 
              </Stack>
            </Tabs.Panel>
            {/* --- FIN DE LA SECCI√ìN RESTAURADA --- */}
            
            <Tabs.Panel value="schedule" pt="md">
                <ScheduleEditor value={form.values.workSchedule} onChange={(schedule) => form.setFieldValue('workSchedule', schedule)} />
            </Tabs.Panel>

            {selectedEmployee && (
              <Tabs.Panel value="absences" pt="md">
                  <AbsenceCalendar absences={employeeAbsences} onAddAbsence={handleAddAbsence} onDeleteAbsence={handleDeleteAbsence} />
              </Tabs.Panel>
            )}

            <Group justify="flex-end" mt="xl">
                <Button variant="default" onClick={closeModal}>Cancelar</Button>
                <Button type="submit">Guardar Cambios</Button>
            </Group>
          </form>
        </Tabs>
      </Modal>

      <ConflictResolutionModal opened={conflictModalOpened} onClose={closeConflictModal} conflicts={conflictingAppointments} />

      <Group justify="space-between" mb="xl">
        <Title order={2}>Gesti√≥n de Empleados</Title>
        <Button onClick={handleCreate} leftSection={<IconUserPlus size={14} />}>A√±adir Empleado</Button>
      </Group>

      <SegmentedControl value={statusFilter} onChange={setStatusFilter} data={[{ label: 'Activos', value: 'ACTIVE' }, { label: 'Archivados', value: 'ARCHIVED' }]} mb="md" />

      <Table striped highlightOnHover withTableBorder>
        <Table.Thead>
          <Table.Tr><Table.Th>Nombre</Table.Th><Table.Th>Rol</Table.Th><Table.Th>Estado</Table.Th><Table.Th>Acciones</Table.Th></Table.Tr>
        </Table.Thead>
        <Table.Tbody>
          {employees.map((employee) => (
            <Table.Tr key={employee.id}>
              <Table.Td><Group><Avatar src={employee.imageUrl || undefined} name={employee.name} radius="xl" /><Box><Text>{employee.name}</Text><Text size="xs" c="dimmed">{employee.email}</Text></Box></Group></Table.Td>
              <Table.Td>{employee.role === 'ADMIN' ? 'Administrador' : 'Empleado'}</Table.Td>
              <Table.Td><Badge color={employee.status === 'ACTIVE' ? 'green' : 'gray'}>{employee.status === 'ACTIVE' ? 'Activo' : 'Archivado'}</Badge></Table.Td>
              <Table.Td>
                <Group gap="xs">
                  <Button variant="light" size="xs" onClick={() => handleEdit(employee)}>Editar</Button>
                  {employee.status === 'ACTIVE' ? (
                     <Button variant="light" color="orange" size="xs" onClick={() => handleStatusChange(employee, 'ARCHIVED')} leftSection={<IconArchive size={14} />}>Archivar</Button>
                  ) : (
                     <Button variant="light" color="teal" size="xs" onClick={() => handleStatusChange(employee, 'ACTIVE')} leftSection={<IconUserCheck size={14} />}>Reactivar</Button>
                  )}
                </Group>
              </Table.Td>
            </Table.Tr>
          ))}
        </Table.Tbody>
      </Table>
    </div>
  );
}


// ====== [30] apps/client/src/pages/admin/ServicesManagementPage.tsx ======
// File: /apps/client/src/pages/admin/ServicesManagementPage.tsx (RECONSTRUIDO)

import { useEffect, useState } from 'react';
import { Table, Title, Button, Group, Modal, ActionIcon, Switch, Text } from '@mantine/core';
import { useDisclosure } from '@mantine/hooks';
import { notifications } from '@mantine/notifications';
import { IconPencil, IconTrash } from '@tabler/icons-react';
import apiClient from '../../lib/apiClient';
import type { Service } from '@aquaclean/types';
import { ServiceForm } from '../../components/admin/ServiceForm';

export function ServicesManagementPage() {
  const [services, setServices] = useState<Service[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [selectedService, setSelectedService] = useState<Partial<Service> | undefined>(undefined);
  const [isSubmitting, setIsSubmitting] = useState(false);

  const [modalOpened, { open: openModal, close: closeModal }] = useDisclosure(false);
  const [deleteModalOpened, { open: openDeleteModal, close: closeDeleteModal }] = useDisclosure(false);

  const fetchServices = async () => {
    try {
      setLoading(true);
      const response = await apiClient.get<Service[]>('/services');
      setServices(response.data);
    } catch (err) {
      setError('No se pudieron cargar los servicios.');
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchServices();
  }, []);

  const handleCreate = () => {
    setSelectedService(undefined);
    openModal();
  };

  const handleEdit = (service: Service) => {
    setSelectedService(service);
    openModal();
  };
  
  const handleDeleteConfirm = (service: Service) => {
    setSelectedService(service);
    openDeleteModal();
  };

  const handleFormSuccess = () => {
    fetchServices(); // Recargamos la lista de servicios
    closeModal();
    setIsSubmitting(false);
  };
  
  const handleToggleActive = async (service: Service) => {
    try {
      const updatedService = { ...service, isActive: !service.isActive };
      await apiClient.put(`/services/${service.id}`, { isActive: updatedService.isActive });
      setServices(services.map(s => s.id === service.id ? updatedService : s));
      notifications.show({ title: 'Estado Cambiado', message: `El servicio "${service.name}" ha sido actualizado.`, color: 'blue' });
    } catch (err) {
      notifications.show({ title: 'Error', message: 'No se pudo cambiar el estado del servicio.', color: 'red' });
    }
  };

  const handleFormSubmit = async (serviceData: Partial<Service>) => {
    setIsSubmitting(true);
    try {
      if (serviceData.id) { // Modo Edici√≥n
        const response = await apiClient.put<Service>(`/services/${serviceData.id}`, serviceData);
        notifications.show({ title: '¬°Actualizado!', message: 'El servicio ha sido guardado correctamente.', color: 'green' });
      } else { // Modo Creaci√≥n
        const response = await apiClient.post<Service>('/services', serviceData);
        notifications.show({ title: '¬°Creado!', message: 'El nuevo servicio ha sido a√±adido.', color: 'green' });
      }
      handleFormSuccess();
    } catch (err: any) {
      setIsSubmitting(false);
      const errorMessage = err.response?.data?.message || 'Ocurri√≥ un error al guardar el servicio.';
      notifications.show({ title: 'Error', message: errorMessage, color: 'red' });
    }
  };
  
  const handleDeleteService = async () => {
    if (!selectedService?.id) return;
    setIsSubmitting(true);
    try {
      await apiClient.delete(`/services/${selectedService.id}`);
      notifications.show({ title: '¬°Eliminado!', message: 'El servicio ha sido eliminado.', color: 'orange' });
      fetchServices();
      closeDeleteModal();
    } catch (err: any) {
      const errorMessage = err.response?.data?.message || 'No se pudo eliminar el servicio.';
      notifications.show({ title: 'Error', message: errorMessage, color: 'red' });
    } finally {
      setIsSubmitting(false);
    }
  };


  if (loading) return <p>Cargando servicios...</p>;
  if (error) return <p style={{ color: 'red' }}>{error}</p>;

  return (
    <div>
      {/* Modal para Crear/Editar */}
      <Modal opened={modalOpened} onClose={closeModal} title={selectedService?.id ? 'Editar Servicio' : 'Crear Nuevo Servicio'} centered>
        <ServiceForm 
          initialData={selectedService}
          onSuccess={handleFormSubmit}
          onClose={closeModal}
          isSubmitting={isSubmitting}
        />
      </Modal>

      {/* Modal de confirmaci√≥n para Eliminar */}
      <Modal opened={deleteModalOpened} onClose={closeDeleteModal} title="Confirmar Eliminaci√≥n" centered>
        <Text>¬øEst√°s seguro de que quieres eliminar el servicio "{selectedService?.name}"? Esta acci√≥n no se puede deshacer.</Text>
        <Group justify="flex-end" mt="md">
          <Button variant="default" onClick={closeDeleteModal}>Cancelar</Button>
          <Button color="red" onClick={handleDeleteService} loading={isSubmitting}>Eliminar Servicio</Button>
        </Group>
      </Modal>

      <Group justify="space-between" mb="xl">
        <Title order={2}>Gesti√≥n de Servicios</Title>
        <Button onClick={handleCreate}>Crear Nuevo Servicio</Button>
      </Group>

      <Table striped highlightOnHover withTableBorder>
        <Table.Thead>
          <Table.Tr>
            <Table.Th>Nombre</Table.Th>
            <Table.Th>Duraci√≥n</Table.Th>
            <Table.Th>Estado</Table.Th>
            <Table.Th>Acciones</Table.Th>
          </Table.Tr>
        </Table.Thead>
        <Table.Tbody>
          {services.map((service) => (
            <Table.Tr key={service.id}>
              <Table.Td>{service.name}</Table.Td>
              <Table.Td>{service.duration} min</Table.Td>
              <Table.Td>
                <Switch 
                  checked={service.isActive} 
                  onChange={() => handleToggleActive(service)}
                  label={service.isActive ? 'Activo' : 'Inactivo'}
                />
              </Table.Td>
              <Table.Td>
                <Group gap="xs">
                  <ActionIcon variant="light" onClick={() => handleEdit(service)}>
                    <IconPencil size={16} />
                  </ActionIcon>
                  <ActionIcon variant="light" color="red" onClick={() => handleDeleteConfirm(service)}>
                    <IconTrash size={16} />
                  </ActionIcon>
                </Group>
              </Table.Td>
            </Table.Tr>
          ))}
        </Table.Tbody>
      </Table>
    </div>
  );
}


// ====== [31] apps/client/src/pages/public/BookingPage.tsx ======
// File: /apps/client/src/pages/public/BookingPage.tsx (ACTUALIZADO)

import { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { Container, Title, Paper, Stepper, Group, Button, TextInput, LoadingOverlay, Text, Alert, Select } from '@mantine/core';
import { useForm, zodResolver } from '@mantine/form';
import { z } from 'zod';
import { BookingDateTimePicker } from '../../components/booking/BookingDateTimePicker';
import apiClient from '../../lib/apiClient';

const customerInfoSchema = z.object({
  customerName: z.string().min(3, { message: 'El nombre debe tener al menos 3 caracteres.' }),
  customerEmail: z.string().email({ message: 'Introduce un email v√°lido.' }),
  customerPhone: z.string().min(9, { message: 'Introduce un n√∫mero de tel√©fono v√°lido.' }),
});
interface Employee { id: string; name: string; }
interface Settings { defaultService: { duration: number; id: string; }; }

export function BookingPage() {
  const navigate = useNavigate();
  const [activeStep, setActiveStep] = useState(0);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const [employees, setEmployees] = useState<{ value: string; label: string }[]>([]);
  // --- L√çNEA MODIFICADA ---
  const [selectedEmployeeId, setSelectedEmployeeId] = useState<string | null>('any');
  const [serviceInfo, setServiceInfo] = useState<{ duration: number; id: string } | null>(null);
  const [selectedDateTime, setSelectedDateTime] = useState<Date | null>(null);

  useEffect(() => {
    const fetchInitialData = async () => {
      setLoading(true);
      setError(null);
      try {
        const [employeesRes, settingsRes] = await Promise.all([
          apiClient.get<Employee[]>('/employees/public'),
          apiClient.get<{ settings: Settings }>('/admin/settings'),
        ]);
        const employeeOptions = employeesRes.data.map(emp => ({ value: emp.id, label: emp.name }));
        setEmployees([ { value: 'any', label: 'Cualquier Profesional' }, ...employeeOptions ]);
        if (settingsRes.data.settings.defaultService) {
          setServiceInfo(settingsRes.data.settings.defaultService);
        } else {
          throw new Error('No hay un servicio por defecto configurado.');
        }
      } catch (err) {
        setError('No se pudo cargar la configuraci√≥n de la reserva. Por favor, int√©ntalo m√°s tarde.');
      } finally {
        setLoading(false);
      }
    };
    fetchInitialData();
  }, []);

  const form = useForm({
    validate: zodResolver(customerInfoSchema),
    initialValues: { customerName: '', customerEmail: '', customerPhone: '' },
  });

  const handleDateTimeChange = (dateTime: Date | null) => {
    setSelectedDateTime(dateTime);
    if (dateTime) { setActiveStep(1); }
  };

  const handleBookingSubmit = async (values: typeof form.values) => {
    if (!serviceInfo?.id || !selectedDateTime) {
      setError('Faltan datos para completar la reserva.');
      return;
    }
    setLoading(true);
    setError(null);
    try {
      const payload = {
        ...values,
        serviceId: serviceInfo.id,
        startTime: selectedDateTime.toISOString(),
        ...(selectedEmployeeId && selectedEmployeeId !== 'any' && { employeeId: selectedEmployeeId }),
      };
      await apiClient.post('/bookings', payload);
      setActiveStep(2);
    } catch (err: any) {
      const errorMessage = err.response?.data?.message || 'No se pudo completar la reserva.';
      setError(errorMessage);
    } finally {
      setLoading(false);
    }
  };

  if (error && activeStep < 2) {
    return (
      <Container size="sm" py="xl">
        <Alert title="Error Cr√≠tico" color="red" variant="light">{error}</Alert>
        <Button onClick={() => navigate('/')} mt="md">Volver a Inicio</Button>
      </Container>
    );
  }

  return (
    <Container size="sm" py="xl">
      <LoadingOverlay visible={loading} />
      <Title order={2} ta="center" mb="xl">Realizar una Reserva</Title>

      <Stepper active={activeStep} onStepClick={setActiveStep}>
        <Stepper.Step label="Paso 1" description="Elige Profesional y Hora">
          <Paper withBorder shadow="md" p="xl" mt="xl" radius="md">
            <Select
              label="Elige un profesional"
              placeholder="Selecciona tu profesional de preferencia"
              data={employees}
              value={selectedEmployeeId}
              onChange={setSelectedEmployeeId}
              mb="xl"
            />
            {serviceInfo && (
              <BookingDateTimePicker
                key={selectedEmployeeId}
                serviceDuration={serviceInfo.duration}
                onDateTimeChange={handleDateTimeChange}
                employeeId={selectedEmployeeId}
              />
            )}
          </Paper>
        </Stepper.Step>

        <Stepper.Step label="Paso 2" description="Tus Datos">
          <Paper withBorder shadow="md" p="xl" mt="xl" radius="md" component="form" onSubmit={form.onSubmit(handleBookingSubmit)}>
            <LoadingOverlay visible={loading && activeStep === 1} />
            <Title order={4} mb="lg">Completa tu informaci√≥n</Title>
            <TextInput label="Nombre Completo" {...form.getInputProps('customerName')} withAsterisk />
            <TextInput label="Email" type="email" {...form.getInputProps('customerEmail')} withAsterisk mt="md" />
            <TextInput label="Tel√©fono" {...form.getInputProps('customerPhone')} withAsterisk mt="md" />
            <Group justify="flex-end" mt="xl">
              <Button variant="default" onClick={() => setActiveStep(0)}>Volver</Button>
              <Button type="submit">Confirmar Reserva</Button>
            </Group>
          </Paper>
        </Stepper.Step>

        <Stepper.Step label="Paso 3" description="Confirmaci√≥n">
           <Paper withBorder shadow="md" p="xl" mt="xl" radius="md">
             <Title order={3} ta="center">¬°Reserva Confirmada!</Title>
             <Text ta="center" mt="md">Hemos enviado un email de confirmaci√≥n a <strong>{form.values.customerEmail}</strong>.</Text>
             <Text ta="center" mt="sm">Fecha de la cita: <strong>{selectedDateTime?.toLocaleString('es-ES')}</strong></Text>
             <Group justify="center" mt="xl"><Button onClick={() => navigate('/')}>Ir a Inicio</Button></Group>
           </Paper>
        </Stepper.Step>
      </Stepper>
    </Container>
  );
}


// ====== [32] apps/client/src/pages/public/HomePage.module.css ======
/* File: /apps/client/src/pages/public/HomePage.module.css (ACTUALIZADO) */

.hero {
  position: relative;
  /* APUNTAMOS A NUESTRA IMAGEN LOCAL */
  background-image: url('/hero-background.jpg');
  background-size: cover;
  background-position: center;
  padding-top: calc(var(--mantine-spacing-xl) * 4);
  padding-bottom: calc(var(--mantine-spacing-xl) * 4);
}

.overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.65);
  z-index: 1;
}

.heroContent {
  position: relative;
  z-index: 2;
  text-align: center;
}

.heroTitle {
  color: var(--mantine-color-white);
  font-size: 50px;
  font-weight: 900;
  line-height: 1.1;

  @media (max-width: 768px) {
    font-size: 40px;
    line-height: 1.2;
  }
}

.heroDescription {
  color: var(--mantine-color-white);
  max-width: 600px;
  margin-left: auto;
  margin-right: auto;
}

.heroButton {
  margin-top: calc(var(--mantine-spacing-xl) * 1.5);
}


// ====== [33] apps/client/src/pages/public/HomePage.tsx ======
// File: /apps/client/src/pages/public/HomePage.tsx (ACTUALIZADO)

import { Title, Text, Button, Container, SimpleGrid, ThemeIcon, Stack } from '@mantine/core';
import { IconTruck, IconCertificate, IconCalendarStats } from '@tabler/icons-react';
import { useNavigate } from 'react-router-dom';
import classes from './HomePage.module.css';

function Feature({ icon: Icon, title, description }: { icon: React.ElementType, title: string, description: string }) {
  return (
    <Stack align="center" ta="center">
      <ThemeIcon variant="light" size={60} radius="md">
        <Icon size={30} />
      </ThemeIcon>
      <Text fw={700} fz="lg" mt="sm">{title}</Text>
      <Text c="dimmed" fz="sm">{description}</Text>
    </Stack>
  );
}

export function HomePage() {
  const navigate = useNavigate();

  return (
    <>
      <div className={classes.hero}>
        <div className={classes.overlay} />
        <Container className={classes.heroContent} size="lg">
          <Title className={classes.heroTitle}>La Excelencia en Cada Detalle</Title>
          <Text className={classes.heroDescription} c="white" size="xl" mt="xl">
            Tu veh√≠culo merece el mejor cuidado. Descubre nuestros servicios de detallado premium y devu√©lvele el brillo que se merece.
          </Text>
          <Button
            variant="gradient"
            gradient={{ from: 'blue', to: 'cyan' }}
            size="xl"
            radius="xl"
            className={classes.heroButton}
            // --- L√çNEA MODIFICADA ---
            onClick={() => navigate('/booking')}
          >
            Reservar Ahora
          </Button>
        </Container>
      </div>

      <Container py="xl" mt="xl">
        <Title order={2} ta="center" mb="xl">
          ¬øPor Qu√© Elegir AquaClean?
        </Title>
        <SimpleGrid cols={{ base: 1, md: 3 }} spacing="xl">
          <Feature
            icon={IconCertificate}
            title="Productos de Alta Calidad"
            description="Utilizamos solo los mejores productos del mercado, seguros para tu coche y para el medio ambiente."
          />
          <Feature
            icon={IconTruck}
            title="Atenci√≥n al Detalle"
            description="Nuestros t√©cnicos especializados tratan cada veh√≠culo como si fuera propio, garantizando un acabado impecable."
          />
          <Feature
            icon={IconCalendarStats}
            title="Reservas F√°ciles 24/7"
            description="Elige tu servicio y reserva tu cita en menos de 2 minutos con nuestro sistema de reservas online."
          />
        </SimpleGrid>
      </Container>
      
      <Container py="xl" ta="center">
         <Title order={3}>¬øListo para que tu coche luzca como nuevo?</Title>
         <Text c="dimmed" mt="sm" mb="lg">
           No esperes m√°s. Encuentra el servicio perfecto y agenda tu cita hoy mismo.
         </Text>
         {/* --- L√çNEA MODIFICADA --- */}
         <Button size="lg" onClick={() => navigate('/booking')}>
           Reservar Mi Cita Ahora
         </Button>
      </Container>
    </>
  );
}


// ====== [34] apps/client/src/pages/public/ServicesPage.tsx ======
// File: /apps/client/src/pages/public/ServicesPage.tsx (ACTUALIZADO)

import { useEffect, useState } from 'react';
import { useNavigate } from 'react-router-dom'; // <-- L√çNEA A√ëADIDA
import {
  Container,
  Title,
  Text,
  Card,
  Button,
  SimpleGrid,
  Group,
  Badge,
} from '@mantine/core';
import apiClient from '../../lib/apiClient';
import type { Service } from '@aquaclean/types';

export function ServicesPage() {
  const [services, setServices] = useState<Service[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const navigate = useNavigate(); // <-- L√çNEA A√ëADIDA

  useEffect(() => {
    const fetchServices = async () => {
      try {
        setLoading(true);
        const response = await apiClient.get<Service[]>('/services');
        setServices(response.data);
      } catch (err) {
        setError('No se pudieron cargar los servicios. Por favor, int√©ntalo m√°s tarde.');
        console.error(err);
      } finally {
        setLoading(false);
      }
    };

    fetchServices();
  }, []);

  // --- FUNCI√ìN A√ëADIDA ---
  // Esta funci√≥n se ejecutar√° cuando el cliente haga clic en "Reservar Ahora".
  // Navegar√° a la p√°gina de booking, pasando los datos del servicio en la URL.
  const handleReserveClick = (service: Service) => {
    navigate(`/booking?serviceId=${service.id}&duration=${service.duration}`);
  };
  // --- FIN DE LA FUNCI√ìN A√ëADIDA ---

  if (loading) {
    return <Container><Text>Cargando servicios...</Text></Container>;
  }

  if (error) {
    return <Container><Text c="red">{error}</Text></Container>;
  }

  return (
    <Container py="xl">
      <Title order={2} ta="center" mb="lg">
        Nuestros Servicios
      </Title>
      <Text ta="center" c="dimmed" mb="xl">
        Elige el tratamiento perfecto para tu veh√≠culo. Ofrecemos desde lavados r√°pidos hasta detallados completos con la m√°xima calidad.
      </Text>

      <SimpleGrid cols={{ base: 1, sm: 2, lg: 3 }} spacing="lg">
        {services.map((service) => (
          <Card shadow="sm" padding="lg" radius="md" withBorder key={service.id}>
            <Group justify="space-between" mt="md" mb="xs">
              <Text fw={500}>{service.name}</Text>
              <Badge color="pink">{service.category}</Badge>
            </Group>

            <Text size="sm" c="dimmed" style={{ minHeight: 60 }}>
              {service.description.substring(0, 100)}...
            </Text>
            
            <Text size="sm" c="dimmed" mt="sm">
              Duraci√≥n estimada: {service.duration} min.
            </Text>

            {/* --- L√çNEA MODIFICADA --- */}
            <Button
              color="blue"
              fullWidth
              mt="md"
              radius="md"
              onClick={() => handleReserveClick(service)} // <-- Se a√±ade el evento onClick
            >
              Reservar Ahora
            </Button>
            {/* --- FIN DE LA MODIFICACI√ìN --- */}
          </Card>
        ))}
      </SimpleGrid>
    </Container>
  );
}


// ====== [35] apps/client/src/pages/public/TeamPage.tsx ======
// File: /apps/client/src/pages/public/TeamPage.tsx (NUEVO ARCHIVO)

import { useEffect, useState } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Container,
  Title,
  Text,
  SimpleGrid,
  Card,
  Avatar,
  Button,
  Loader,
  Center,
  Alert,
} from '@mantine/core';
import { IconAlertCircle } from '@tabler/icons-react';
import apiClient from '../../lib/apiClient';

// Definimos un tipo local para los datos que esperamos de la API.
// Esto nos da autocompletado y seguridad de tipos.
interface TeamMember {
  id: string;
  name: string;
  role: 'ADMIN' | 'EMPLOYEE';
  bio?: string;
  imageUrl?: string;
}

export function TeamPage() {
  const [team, setTeam] = useState<TeamMember[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const navigate = useNavigate();

  useEffect(() => {
    const fetchTeam = async () => {
      try {
        const response = await apiClient.get<TeamMember[]>('/employees');
        // Por ahora, mostramos a todos. En el futuro, podr√≠amos filtrar por rol.
        setTeam(response.data);
      } catch (err) {
        console.error('Error fetching team members:', err);
        setError('No se pudo cargar la informaci√≥n del equipo. Por favor, int√©ntalo de nuevo m√°s tarde.');
      } finally {
        setLoading(false);
      }
    };
    fetchTeam();
  }, []);

  if (loading) {
    return <Center style={{ height: 300 }}><Loader /></Center>;
  }

  if (error) {
    return (
      <Alert icon={<IconAlertCircle size="1rem" />} title="Error" color="red">
        {error}
      </Alert>
    );
  }

  return (
    <Container py="xl">
      <Title order={2} ta="center">
        Conoce a Nuestro Equipo
      </Title>
      <Text c="dimmed" ta="center" mt="sm" mb="xl">
        Profesionales apasionados por el cuidado de tu veh√≠culo, listos para ofrecerte el mejor servicio.
      </Text>

      <SimpleGrid cols={{ base: 1, sm: 2, lg: 3 }} spacing="lg">
        {team.map((member) => (
          <Card key={member.id} shadow="sm" padding="lg" radius="md" withBorder>
            <Center>
              <Avatar src={member.imageUrl} size={120} radius="xl" alt={member.name} />
            </Center>
            <Text ta="center" fw={500} fz="lg" mt="md">
              {member.name}
            </Text>
            <Text ta="center" c="dimmed" fz="sm">
              {member.role === 'ADMIN' ? 'Gerente de Operaciones' : 'Especialista en Detallado'}
            </Text>
            <Text ta="center" fz="sm" mt="sm" style={{ minHeight: 60 }}>
              {member.bio || 'Comprometido con la excelencia y la satisfacci√≥n del cliente.'}
            </Text>
            <Button
              variant="light"
              fullWidth
              mt="md"
              radius="md"
              onClick={() => navigate('/services')}
            >
              Ver Servicios
            </Button>
          </Card>
        ))}
      </SimpleGrid>
    </Container>
  );
}


// ====== [36] apps/client/tsconfig.json ======
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "lib": ["DOM", "DOM.Iterable", "ESNext"],
    "plugins": [{ "name": "typescript-plugin-css-modules" }]
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}



// ====== [37] apps/client/tsconfig.node.json ======
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "composite": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "noEmit": false
  },
  "include": ["vite.config.ts"]
}


// ====== [38] apps/server/.env ======
# File: /apps/server/.env - v1.0

# --- Base de Datos y Servidor ---
DATABASE_URL="postgresql://postgres:Matrix2010%40@localhost:5432/aquaclean_db?schema=public"
PORT=3001

# --- Autenticaci√≥n ---
JWT_SECRET="temporal-secret-dev-12345!"
JWT_EXPIRES_IN="604800s" # (s for seconds)

# --- Servicios Externos (Cloudinary) ---
CLOUDINARY_CLOUD_NAME="dbrniwsql"
CLOUDINARY_API_KEY="369383982123395"
CLOUDINARY_API_SECRET="rSOm48XmeYC5FQt27D6k5sppguc"

# --- CORS ---
CORS_ALLOWED_ORIGIN="http://localhost:5173"

# --- Configuraci√≥n de Email (Nodemailer) ---
EMAIL_HOST="smtp.privateemail.com"
EMAIL_PORT="465"
EMAIL_USER="info@ohcodex.com"
EMAIL_PASS="Matrix2010@"
EMAIL_FROM="AquaClean Notificaciones <info@ohcodex.com>"
EMAIL_TO="info@ohcodex.com"


// ====== [39] apps/server/package.json ======
{
  "name": "server",
  "version": "1.0.0",
  "private": true,
  "main": "dist/server.js",
  "scripts": {
    "dev": "ts-node-dev --respawn --transpile-only --exit-child src/server.ts",
    "build": "tsc",
    "start": "node dist/server.js",
    "lint": "eslint . --ext .ts",
    "migrate:dev": "prisma migrate dev --schema=./prisma/schema.prisma",
    "migrate:deploy": "prisma migrate deploy --schema=./prisma/schema.prisma",
    "prisma:generate": "prisma generate --schema=./prisma/schema.prisma",
    "prisma:studio": "prisma studio --schema=./prisma/schema.prisma",
    "prisma:seed": "ts-node prisma/seed.ts"
  },
  "dependencies": {
    "@prisma/client": "^5.14.0",
    "bcryptjs": "^2.4.3",
    "cors": "^2.8.5",
    "dayjs": "^1.11.11",
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "jsonwebtoken": "^9.0.2",
    "nodemailer": "^6.10.1",
    "zod": ">=3.0.0"
  },
  "devDependencies": {
    "@aquaclean/config": "workspace:*",
    "@aquaclean/types": "workspace:*",
    "@types/bcryptjs": "^2.4.6",
    "@types/cors": "^2.8.17",
    "@types/express": "^4.17.21",
    "@types/jsonwebtoken": "^9.0.10",
    "@types/node": "^20.12.12",
    "@types/nodemailer": "^6.4.20",
    "eslint": "^8.57.0",
    "prisma": "^5.14.0",
    "ts-node": "^10.9.2",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.4.5"
  }
}


// ====== [40] apps/server/prisma/schema.prisma ======
// File: /apps/server/prisma/schema.prisma (CORREGIDO)

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// 2. Modelos de Autenticaci√≥n y Usuarios
model User {
  id              String          @id @default(cuid())
  name            String?
  email           String          @unique
  emailVerified   DateTime?
  passwordHash    String?
  image           String?
  role            UserRole        @default(CUSTOMER)
  stripeCustomerId String?        @unique

  accounts        Account[]
  sessions        Session[]
  appointments    Appointment[]
  reviews         Review[]
  vehicles        Vehicle[]
  purchasedBonuses PurchasedBonus[]
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime
  @@unique([identifier, token])
}

// 3. Modelos del Core del Negocio
model Service {
  id          String   @id @default(cuid())
  name        String
  description String   @db.Text
  duration    Int
  prices      Json
  category    String
  isAddon     Boolean  @default(false)
  isGiftable  Boolean  @default(false)
  isFeatured  Boolean  @default(false)
  isActive    Boolean  @default(true)

  appointments    AppointmentService[]
  bonusOfferings  BonusOffering[]
  giftCards       GiftCard[]

  businessSettings BusinessSettings?
}

model Employee {
  id           String @id @default(cuid())
  name         String
  email        String @unique
  role         UserRole @default(EMPLOYEE)
  bio          String? @db.Text
  imageUrl     String?
  status       EmployeeStatus @default(ACTIVE)
  
  workSchedule Json?
  absences     Absence[]

  appointments Appointment[]
  reviews      Review[]
}

model Absence {
  id         String   @id @default(cuid())
  startDate  DateTime
  endDate    DateTime
  reason     String?
  
  employee   Employee @relation(fields: [employeeId], references: [id])
  employeeId String
}

// 4. Modelos Operacionales
model Appointment {
  id            String   @id @default(cuid())
  startTime     DateTime
  endTime       DateTime
  notes         String?
  status        AppointmentStatus @default(CONFIRMED)
  paymentIntentId String?  @unique
  googleEventId   String?  @unique

  user          User     @relation(fields: [userId], references: [id])
  userId        String
  
  employee      Employee @relation(fields: [employeeId], references: [id])
  employeeId    String

  services      AppointmentService[]
  review        Review?
}

model AppointmentService {
  appointment   Appointment @relation(fields: [appointmentId], references: [id])
  appointmentId String
  service       Service     @relation(fields: [serviceId], references: [id])
  serviceId     String
  @@id([appointmentId, serviceId])
}

model Review {
  id            String      @id @default(cuid())
  rating        Int
  comment       String?     @db.Text
  status        ReviewStatus @default(PENDING)
  isFeatured    Boolean     @default(false)
  createdAt     DateTime    @default(now())
  
  appointment   Appointment @relation(fields: [appointmentId], references: [id])
  appointmentId String      @unique
  user          User        @relation(fields: [userId], references: [id])
  userId        String

  employee      Employee    @relation(fields: [employeeId], references: [id])
  employeeId    String
}

// 5. Modelos de Cliente y Marketing
model Vehicle {
  id          String @id @default(cuid())
  alias       String
  brand       String
  model       String
  plate       String?
  size        String
  user        User   @relation(fields: [userId], references: [id])
  userId      String
}

model BonusOffering {
  id          String   @id @default(cuid())
  name        String
  price       Float
  uses        Int
  validityDays Int?
  isActive    Boolean  @default(true)
  service     Service  @relation(fields: [serviceId], references: [id])
  serviceId   String
  purchases   PurchasedBonus[]
}

model PurchasedBonus {
  id              String   @id @default(cuid())
  usesRemaining   Int
  expiresAt       DateTime?
  user            User     @relation(fields: [userId], references: [id])
  userId          String
  bonusOffering   BonusOffering @relation(fields: [bonusOfferingId], references: [id])
  bonusOfferingId String
}

model GiftCard {
  id            String    @id @default(cuid())
  code          String    @unique
  isRedeemed    Boolean   @default(false)
  redeemedAt    DateTime?
  recipientEmail String?
  message       String?   @db.Text
  service       Service   @relation(fields: [serviceId], references: [id])
  serviceId     String
}

// 6. Modelo de Configuraci√≥n del Negocio
model BusinessSettings {
  id              String    @id @default(cuid())
  weeklySchedule  Json
  singleton       String    @unique @default("SINGLETON")

  defaultService   Service? @relation(fields: [defaultServiceId], references: [id])
  defaultServiceId String?  @unique
}

// --- MODELO REFACTORIZADO (Antiguo BusinessClosure) ---
model DateOverride {
  id        String   @id @default(cuid())
  date      DateTime // <-- @unique ha sido eliminado
  reason    String?

  // Si estos son nulos, es un cierre completo.
  // Si tienen valor, es un horario especial para este d√≠a.
  openTime  String? // formato "HH:mm"
  closeTime String? // formato "HH:mm"
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 7. Enums
enum UserRole {
  ADMIN
  EMPLOYEE
  CUSTOMER
}

enum AppointmentStatus {
  CONFIRMED
  COMPLETED
  CANCELLED
  PENDING_PAYMENT
}

enum ReviewStatus {
  PENDING
  APPROVED
  HIDDEN
}

enum EmployeeStatus {
  ACTIVE
  ARCHIVED
}


// ====== [41] apps/server/prisma/seed.ts ======
// File: /apps/server/prisma/seed.ts (ACTUALIZADO CON dateOverride)

import { PrismaClient, UserRole, EmployeeStatus } from '@prisma/client';
import { hash } from 'bcryptjs';

const prisma = new PrismaClient();

async function main() {
  console.log('Starting database seed...');

  // --- 0. Limpieza Previa de Datos Relacionados ---
  console.log('Cleaning up old relations...');
  await prisma.businessSettings.updateMany({
    data: { defaultServiceId: null },
  });
  await prisma.appointmentService.deleteMany({});
  await prisma.absence.deleteMany({});
  // --- L√çNEA MODIFICADA ---
  await prisma.dateOverride.deleteMany({}); // <-- ACTUALIZADO DE businessClosure a dateOverride
  await prisma.appointment.deleteMany({});
  console.log('Cleanup complete.');
  
  // --- 1. Seed del Usuario Administrador ---
  const adminEmail = 'admin@aquaclean.com';
  const adminPassword = 'password123';
  const adminUser = await prisma.user.findUnique({ where: { email: adminEmail } });

  if (!adminUser) {
    const hashedPassword = await hash(adminPassword, 12);
    await prisma.user.create({
      data: {
        email: adminEmail,
        name: 'Admin User',
        passwordHash: hashedPassword,
        role: UserRole.ADMIN,
        emailVerified: new Date(),
      },
    });
    console.log(`‚úÖ Admin user created successfully: ${adminEmail}`);
  } else {
    console.log('Admin user already exists. Skipping creation.');
  }

  // --- 2. Seed del Empleado de Prueba ---
  const employeeEmail = 'employee@aquaclean.com';
  const testEmployee = await prisma.employee.findUnique({ where: { email: employeeEmail } });
  const employeeWorkSchedule = {
    monday: [{ start: '09:00', end: '13:00' }, { start: '14:00', end: '17:00' }],
    tuesday: [{ start: '09:00', end: '13:00' }, { start: '14:00', end: '17:00' }],
    wednesday: [{ start: '09:00', end: '13:00' }, { start: '14:00', end: '17:00' }],
    thursday: [{ start: '09:00', end: '13:00' }, { start: '14:00', end: '17:00' }],
    friday: [{ start: '09:00', end: '13:00' }, { start: '14:00', end: '17:00' }],
    saturday: [{ start: '10:00', end: '14:00' }],
  };

  if (!testEmployee) {
    await prisma.employee.create({
      data: {
        email: employeeEmail,
        name: 'Juan Empleado',
        role: UserRole.EMPLOYEE,
        workSchedule: employeeWorkSchedule,
        status: EmployeeStatus.ACTIVE,
      },
    });
    console.log(`‚úÖ Test employee created successfully: ${employeeEmail}`);
  } else {
    await prisma.employee.update({
        where: { email: employeeEmail },
        data: { 
          workSchedule: employeeWorkSchedule,
          status: EmployeeStatus.ACTIVE,
        }
    });
    console.log('‚úÖ Test employee updated with default work schedule.');
  }

  // --- 3. Seed del Servicio por Defecto ---
  console.log('Seeding default service...');
  await prisma.appointment.deleteMany({});
  await prisma.service.deleteMany({});
  
  const defaultService = await prisma.service.create({
    data: {
      name: 'Servicio Completo de Detallado',
      description: 'El √∫nico servicio que lo tiene todo. Limpieza exterior e interior profunda para dejar tu veh√≠culo como el primer d√≠a.',
      duration: 75,
      prices: { standard: 60, suv: 75 },
      category: 'Completo',
      isActive: true,
    },
  });
  console.log(`‚úÖ Seeded 1 default service: "${defaultService.name}"`);

  // --- 4. Seed de la Configuraci√≥n del Negocio ---
  // Hacemos upsert usando el `singleton` como identificador √∫nico
  const settings = await prisma.businessSettings.findUnique({ where: { singleton: 'SINGLETON' } });
  if (!settings) {
      await prisma.businessSettings.create({
          data: {
              singleton: 'SINGLETON',
              weeklySchedule: {
                  monday: { open: '09:00', close: '19:00' },
                  tuesday: { open: '09:00', close: '19:00' },
                  wednesday: { open: '09:00', close: '19:00' },
                  thursday: { open: '09:00', close: '19:00' },
                  friday: { open: '09:00', close: '19:00' },
                  saturday: { open: '10:00', close: '14:00' },
                  sunday: null,
              },
              defaultServiceId: defaultService.id,
          }
      });
  } else {
      await prisma.businessSettings.update({
          where: { singleton: 'SINGLETON' },
          data: {
              weeklySchedule: {
                  monday: { open: '09:00', close: '19:00' },
                  tuesday: { open: '09:00', close: '19:00' },
                  wednesday: { open: '09:00', close: '19:00' },
                  thursday: { open: '09:00', close: '19:00' },
                  friday: { open: '09:00', close: '19:00' },
                  saturday: { open: '10:00', close: '14:00' },
                  sunday: null,
              },
              defaultServiceId: defaultService.id,
          }
      });
  }
  console.log('‚úÖ Business settings created/updated and linked to default service.');

  console.log('Database seed finished.');
}

main()
  .catch((e) => {
    console.error('An error occurred during seeding:', e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });


// ====== [42] apps/server/src/api/adminAppointments.routes.ts ======
// File: /apps/server/src/api/adminAppointments.routes.ts (CORREGIDO)

import { Router } from 'express';
import { z, ZodError } from 'zod';
import dayjs from 'dayjs';
import prisma from '../lib/prisma';
import { Prisma } from '@prisma/client';

const router = Router();

// --- ESQUEMAS ---
const createAppointmentAdminSchema = z.object({
  customerName: z.string().min(1), customerEmail: z.string().email(),
  serviceId: z.string().cuid(), employeeId: z.string().cuid(),
  startTime: z.coerce.date(),
});
const updateAppointmentAdminSchema = createAppointmentAdminSchema.partial();
const updateAppointmentDndSchema = z.object({ start: z.coerce.date(), end: z.coerce.date() });

// --- OBTENER TODAS LAS CITAS ---
router.get('/', async (req, res) => {
  try {
    const appointments = await prisma.appointment.findMany({
      include: {
        user: { select: { name: true, email: true } },
        services: { include: { service: { select: { id: true, name: true } } } },
      },
    });
    const events = appointments.map((appointment) => {
      const service = appointment.services[0]?.service;
      const customer = appointment.user;
      return {
        id: appointment.id, title: `${service?.name || 'Servicio'} - ${customer?.name || 'Cliente'}`,
        start: appointment.startTime, end: appointment.endTime, resourceId: appointment.employeeId,
        extendedProps: {
          appointmentId: appointment.id, customerName: customer?.name, customerEmail: customer?.email,
          serviceId: service?.id, employeeId: appointment.employeeId, start: appointment.startTime,
        }
      };
    });
    res.status(200).json(events);
  } catch (error) { res.status(500).json({ message: 'Error interno del servidor.' }); }
});

// --- CREAR CITA ---
router.post('/', async (req, res) => {
  try {
    const validatedData = createAppointmentAdminSchema.parse(req.body);
    const service = await prisma.service.findUnique({ where: { id: validatedData.serviceId } });
    if (!service) return res.status(404).json({ message: 'Servicio no encontrado.' });
    const endTime = dayjs(validatedData.startTime).add(service.duration, 'minutes').toDate();
    const newAppointment = await prisma.appointment.create({
      data: {
        startTime: validatedData.startTime, endTime, status: 'CONFIRMED',
        employee: { connect: { id: validatedData.employeeId } },
        services: { create: { service: { connect: { id: validatedData.serviceId } } } },
        user: {
          connectOrCreate: {
            where: { email: validatedData.customerEmail },
            create: { email: validatedData.customerEmail, name: validatedData.customerName, role: 'CUSTOMER' },
          },
        },
      },
    });
    res.status(201).json(newAppointment);
  } catch (error) {
    if (error instanceof ZodError) return res.status(400).json({ message: 'Datos inv√°lidos.', errors: error.issues });
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});

// --- ACTUALIZAR CITA ---
router.put('/:id', async (req, res) => {
  try {
    const { id } = req.params;
    if (req.body.start && req.body.end) {
      const { start, end } = updateAppointmentDndSchema.parse(req.body);
      const updated = await prisma.appointment.update({ where: { id }, data: { startTime: start, endTime: end } });
      return res.status(200).json(updated);
    }
    const validatedData = updateAppointmentAdminSchema.parse(req.body);
    const { customerName, customerEmail, serviceId, employeeId, startTime } = validatedData;
    const updateData: Prisma.AppointmentUpdateInput = {};
    if (startTime) updateData.startTime = startTime;
    if (employeeId) updateData.employee = { connect: { id: employeeId } };
    if (serviceId) updateData.services = { deleteMany: {}, create: { serviceId } };
    if (customerEmail && customerName) {
      updateData.user = { connectOrCreate: { where: { email: customerEmail }, create: { email: customerEmail, name: customerName, role: 'CUSTOMER' } } };
    }
    if (startTime || serviceId) {
        const currentAppointment = await prisma.appointment.findUnique({ where: { id }, include: { services: true } });
        const finalServiceId = serviceId || currentAppointment?.services[0]?.serviceId;
        const finalStartTime = startTime || currentAppointment?.startTime;
        if(finalServiceId && finalStartTime) {
            const service = await prisma.service.findUnique({ where: { id: finalServiceId } });
            if (service) updateData.endTime = dayjs(finalStartTime).add(service.duration, 'minutes').toDate();
        }
    }
    const updatedAppointment = await prisma.appointment.update({ where: { id }, data: updateData });
    res.status(200).json(updatedAppointment);
  } catch (error) {
    if (error instanceof ZodError) return res.status(400).json({ message: 'Datos inv√°lidos.', errors: error.issues });
    if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') return res.status(404).json({ message: 'La cita no fue encontrada.' });
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});

// --- ANULAR/ELIMINAR UNA CITA (CORREGIDO) ---
router.delete('/:id', async (req, res) => {
  try {
    const { id } = req.params;

    // Usamos una transacci√≥n para asegurar que ambas operaciones se completen
    await prisma.$transaction([
      // 1. Borramos los registros de la tabla intermedia
      prisma.appointmentService.deleteMany({
        where: { appointmentId: id },
      }),
      // 2. Borramos la cita principal
      prisma.appointment.delete({
        where: { id },
      }),
    ]);
    
    res.status(204).send();
  } catch (error) {
    if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
      return res.status(404).json({ message: 'La cita que intentas eliminar no fue encontrada.' });
    }
    console.error('Error deleting appointment:', error);
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});

export default router;


// ====== [43] apps/server/src/api/adminDateOverrides.routes.ts ======
// File: /apps/server/src/api/adminDateOverrides.routes.ts (CORREGIDO CON NORMALIZACI√ìN UTC)

import { Router } from 'express';
import { z, ZodError } from 'zod';
import dayjs from 'dayjs';
import utc from 'dayjs/plugin/utc'; // <-- Importar el plugin UTC
import prisma from '../lib/prisma';
import { Prisma } from '@prisma/client';

dayjs.extend(utc); // <-- Usar el plugin

const router = Router();

const overrideSchema = z
  .object({
    date: z.coerce.date(),
    reason: z.string().optional(),
    openTime: z.string().regex(/^\d{2}:\d{2}$/).optional().nullable(),
    closeTime: z.string().regex(/^\d{2}:\d{2}$/).optional().nullable(),
  })
  .refine(
    (data) => (data.openTime && data.closeTime) || (!data.openTime && !data.closeTime),
    {
      message: 'Se deben proporcionar tanto la hora de apertura como la de cierre, o ninguna de las dos.',
      path: ['openTime', 'closeTime'],
    }
  );

// --- OBTENER TODAS LAS ANULACIONES DE FECHA ---
router.get('/', async (req, res) => {
  try {
    const overrides = await prisma.dateOverride.findMany({
      orderBy: { date: 'asc' },
    });
    res.status(200).json(overrides);
  } catch (error) {
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});

// --- A√ëADIR UNA NUEVA ANULACI√ìN (CIERRE U HORARIO ESPECIAL) ---
router.post('/', async (req, res) => {
  try {
    const { date, reason, openTime, closeTime } = overrideSchema.parse(req.body);

    // --- CORRECCI√ìN CLAVE: NORMALIZAR LA FECHA A UTC ---
    const utcDate = dayjs(date).utc().startOf('day').toDate();
    const startOfDay = dayjs(utcDate); // Ya est√° en UTC
    const endOfDay = startOfDay.endOf('day');

    // Comprobar si ya existe una anulaci√≥n para este d√≠a
    const existingOverride = await prisma.dateOverride.findFirst({
        where: { date: utcDate },
    });

    if (existingOverride) {
        return res.status(409).json({ message: 'Ya existe una configuraci√≥n especial para este d√≠a.' });
    }
    // --- FIN DE LA CORRECCI√ìN ---


    let conflictingAppointments = [];

    if (openTime && closeTime) {
      const specialOpening = dayjs.utc(`${startOfDay.format('YYYY-MM-DD')}T${openTime}`);
      const specialClosing = dayjs.utc(`${startOfDay.format('YYYY-MM-DD')}T${closeTime}`);

      conflictingAppointments = await prisma.appointment.findMany({
        where: {
          startTime: { gte: startOfDay.toDate(), lte: endOfDay.toDate() },
          OR: [
            { startTime: { lt: specialOpening.toDate() } },
            { endTime: { gt: specialClosing.toDate() } },
          ],
        },
        include: { user: { select: { name: true } } },
      });
    } else {
      conflictingAppointments = await prisma.appointment.findMany({
        where: { startTime: { gte: startOfDay.toDate(), lte: endOfDay.toDate() } },
        include: { user: { select: { name: true } } },
      });
    }

    if (conflictingAppointments.length > 0) {
      return res.status(409).json({
        message: `La operaci√≥n entra en conflicto con ${conflictingAppointments.length} citas existentes.`,
        conflicts: conflictingAppointments,
      });
    }

    const newOverride = await prisma.dateOverride.create({
      data: { date: utcDate, reason, openTime, closeTime }, // <-- Usar la fecha normalizada
    });

    res.status(201).json(newOverride);
  } catch (error) {
    if (error instanceof ZodError) {
      return res.status(400).json({ message: 'Datos inv√°lidos.', errors: error.issues });
    }
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});

// --- ELIMINAR UNA ANULACI√ìN ---
router.delete('/:id', async (req, res) => {
  try {
    const { id } = req.params;
    await prisma.dateOverride.delete({ where: { id } });
    res.status(204).send();
  } catch (error) {
    if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
      return res.status(404).json({ message: 'La anulaci√≥n no fue encontrada.' });
    }
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});

export default router;


// ====== [44] apps/server/src/api/adminSettings.routes.ts ======
// File: /apps/server/src/api/adminSettings.routes.ts (VERSI√ìN DE DEPURACI√ìN PARA EL GUARDADO)

import { Router } from 'express';
import { z, ZodError } from 'zod';
import prisma from '../lib/prisma';
import { Prisma } from '@prisma/client';

const router = Router();

const updateSettingsSchema = z.object({
  defaultServiceId: z.string().cuid({ message: 'El ID del servicio no es v√°lido.' }),
  weeklySchedule: z.record(z.any()).optional(),
});

router.get('/', async (req, res) => {
  try {
    const settings = await prisma.businessSettings.findUnique({
      where: { singleton: 'SINGLETON' },
      include: { defaultService: true },
    });

    if (!settings) {
      return res.status(404).json({ message: 'No se ha encontrado la configuraci√≥n del negocio.' });
    }
    
    const transformedSchedule: { [key: string]: { start: string, end: string }[] } = {};
    const originalSchedule = settings.weeklySchedule as any;
    if (originalSchedule) {
        for (const day in originalSchedule) {
            const daySetting = originalSchedule[day];
            if (daySetting && daySetting.open && daySetting.close) {
                transformedSchedule[day] = [{ start: daySetting.open, end: daySetting.close }];
            } else {
                transformedSchedule[day] = [];
            }
        }
    }

    const allServices = await prisma.service.findMany({
      where: { isActive: true },
    });
    
    res.status(200).json({
      settings: { ...settings, weeklySchedule: transformedSchedule },
      allServices,
    });

  } catch (error) {
    console.error('Error al obtener la configuraci√≥n del negocio:', error);
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});

router.put('/', async (req, res) => {
  try {
    // --- SECCI√ìN DE LOGS ---
    console.log('\n\n--- Petici√≥n PUT a /api/admin/settings ---');

    const validatedData = updateSettingsSchema.parse(req.body);
    const { defaultServiceId, weeklySchedule } = validatedData;
    
    console.log('1. Datos recibidos del frontend (weeklySchedule):', JSON.stringify(weeklySchedule, null, 2));

    const scheduleToSave: { [key: string]: { open: string, close: string } | null } = {};
    if (weeklySchedule) {
        for (const day in weeklySchedule) {
            const shifts = weeklySchedule[day] as { start: string, end: string }[];
            if (shifts && shifts.length > 0 && shifts[0]) {
                scheduleToSave[day] = { open: shifts[0].start, close: shifts[0].end };
            } else {
                scheduleToSave[day] = null;
            }
        }
    }
    
    console.log('2. Datos transformados para guardar en BBDD:', JSON.stringify(scheduleToSave, null, 2));
    // --- FIN DE SECCI√ìN DE LOGS ---

    const updatedSettings = await prisma.businessSettings.update({
      where: { singleton: 'SINGLETON' },
      data: {
        defaultServiceId,
        weeklySchedule: scheduleToSave,
      },
    });

    console.log('3. Guardado en base de datos completado con √©xito.');
    res.status(200).json(updatedSettings);

  } catch (error) {
    if (error instanceof ZodError) {
      return res.status(400).json({ message: 'Datos de entrada inv√°lidos.', errors: error.issues });
    }
    if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
      return res.status(404).json({ message: 'El servicio seleccionado no existe.' });
    }
    console.error('Error al actualizar la configuraci√≥n del negocio:', error);
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});


export default router;


// ====== [45] apps/server/src/api/auth.routes.ts ======
import { Router } from 'express';
import { compare } from 'bcryptjs';
import jwt from 'jsonwebtoken';
import { z } from 'zod';
import prisma from '../lib/prisma';
import { UserRole } from '@prisma/client';

const router = Router();

// Esquema de validaci√≥n para los datos del login
const loginSchema = z.object({
  email: z.string().email('El formato del email no es v√°lido.'),
  password: z.string().min(1, 'La contrase√±a es requerida.'),
});

router.post('/login', async (req, res) => {
  try {
    // 1. Validar los datos de entrada
    const { email, password } = loginSchema.parse(req.body);

    // 2. Buscar al usuario administrador en la base de datos
    const adminUser = await prisma.user.findUnique({
      where: { email },
    });

    // 3. Verificar si el usuario existe y si es un administrador
    if (!adminUser || adminUser.role !== UserRole.ADMIN) {
      return res.status(401).json({ message: 'Credenciales inv√°lidas.' });
    }

    // 4. Comparar la contrase√±a enviada con el hash guardado
    const isPasswordValid = await compare(password, adminUser.passwordHash!);
    if (!isPasswordValid) {
      return res.status(401).json({ message: 'Credenciales inv√°lidas.' });
    }

    // 5. Generar el Token JWT
    const jwtSecret = process.env.JWT_SECRET;
    if (!jwtSecret) {
      console.error('Error: La variable de entorno JWT_SECRET no est√° definida.');
      return res.status(500).json({ message: 'Error interno del servidor.' });
    }

    const token = jwt.sign(
      {
        userId: adminUser.id,
        email: adminUser.email,
        role: adminUser.role,
      },
      jwtSecret,
      { expiresIn: '1d' } // El token expirar√° en 1 d√≠a
    );

    // 6. Enviar el token al cliente
    res.status(200).json({
      message: 'Login exitoso.',
      token,
      user: {
        id: adminUser.id,
        name: adminUser.name,
        email: adminUser.email,
        role: adminUser.role,
      },
    });
  } catch (error) {
    console.error('Error en el login:', error);
    // Si el error es de validaci√≥n de Zod, enviamos una respuesta m√°s espec√≠fica
    if (error instanceof z.ZodError) {
      return res.status(400).json({ message: 'Datos de entrada inv√°lidos.', errors: error.issues });
    }
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});

export default router;


// ====== [46] apps/server/src/api/availability.routes.ts ======
// File: /apps/server/src/api/availability.routes.ts (FORZANDO UTC EN TODO EL PROCESO)

import { Router } from 'express';
import { z } from 'zod';
import dayjs from 'dayjs';
import utc from 'dayjs/plugin/utc';
import isBetween from 'dayjs/plugin/isBetween';
import 'dayjs/locale/en';
import prisma from '../lib/prisma';
import { isEmployeeAvailable } from '../lib/availabilityService';

dayjs.extend(utc);
dayjs.extend(isBetween);
dayjs.locale('en');

const router = Router();

const availabilityQuerySchema = z.object({
  date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, 'El formato de fecha debe ser YYYY-MM-DD'),
  employeeId: z.string().cuid().optional(),
});

router.get('/', async (req, res) => {
  console.log(`\n\n--- [GET /availability] Nueva Petici√≥n para fecha: ${req.query.date} ---`);
  try {
    const validation = availabilityQuerySchema.safeParse(req.query);
    if (!validation.success) {
      console.error('[AVAILABILITY] Error de validaci√≥n:', validation.error.issues);
      return res.status(400).json({ errors: validation.error.issues });
    }
    
    const { date, employeeId } = validation.data;
    const selectedDate = dayjs.utc(date);

    const settings = await prisma.businessSettings.findUnique({
      where: { singleton: 'SINGLETON' },
      include: { defaultService: true },
    });

    if (!settings?.defaultService) {
      console.error('[AVAILABILITY] FALLO CR√çTICO: El servicio por defecto no est√° configurado.');
      return res.status(503).json({ message: 'El servicio por defecto no est√° configurado.' });
    }

    let businessDayHours: { open: string; close: string } | null = null;
    const override = await prisma.dateOverride.findFirst({
      where: { date: { gte: selectedDate.startOf('day').toDate(), lte: selectedDate.endOf('day').toDate() } }
    });

    if (override) {
      console.log(`[AVAILABILITY] Anulaci√≥n de fecha encontrada para ${date}.`);
      if (override.openTime && override.closeTime) {
        businessDayHours = { open: override.openTime, close: override.closeTime };
      }
    } else {
      const dayOfWeek = selectedDate.format('dddd').toLowerCase();
      const weeklySchedule = settings.weeklySchedule as any;
      const daySchedule = weeklySchedule?.[dayOfWeek];
      if (daySchedule && daySchedule.open && daySchedule.close) {
        businessDayHours = { open: daySchedule.open, close: daySchedule.close };
      }
    }

    if (!businessDayHours) {
      console.log(`[AVAILABILITY] No se encontr√≥ horario de apertura para este d√≠a. El negocio est√° cerrado.`);
      return res.json([]);
    }
    console.log(`[AVAILABILITY] Horario de negocio para ${date}: ${businessDayHours.open} - ${businessDayHours.close}`);

    const { defaultService } = settings;
    const serviceDuration = defaultService.duration;
    
    const appointmentsOnDay = await prisma.appointment.findMany({
      where: { startTime: { gte: selectedDate.startOf('day').toDate(), lte: selectedDate.endOf('day').toDate() } },
      select: { startTime: true, endTime: true, employeeId: true },
    });
    console.log(`[AVAILABILITY] Encontradas ${appointmentsOnDay.length} citas existentes para este d√≠a.`);

    let employeesToCheck = await prisma.employee.findMany({
      where: { status: 'ACTIVE', ...(employeeId && { id: employeeId }) },
      include: { absences: true },
    });
    
    const availableSlots: string[] = [];
    // --- CORRECCI√ìN CLAVE: CREAR LAS HORAS DE APERTURA Y CIERRE EN MODO UTC ---
    const openingTime = dayjs.utc(`${date}T${businessDayHours.open}`);
    const closingTime = dayjs.utc(`${date}T${businessDayHours.close}`);

    let currentTime = openingTime;
    console.log('[AVAILABILITY] Iniciando bucle de comprobaci√≥n de huecos...');
    while (currentTime.add(serviceDuration, 'minutes').isBefore(closingTime.add(1, 'minute'))) {
      const slotStart = currentTime;
      const slotEnd = currentTime.add(serviceDuration, 'minutes');

      // Pasamos el slot (que ya es UTC) a la funci√≥n de validaci√≥n
      const theoreticallyAvailableEmployees = employeesToCheck.filter(emp => 
        isEmployeeAvailable(emp, slotStart, serviceDuration)
      );

      if(theoreticallyAvailableEmployees.length > 0) {
        const isAnyEmployeeFree = theoreticallyAvailableEmployees.some(emp => {
          const hasOverlappingAppointment = appointmentsOnDay.some(apt => 
            apt.employeeId === emp.id &&
            // Comparamos UTC (cita) con UTC (slot)
            ( (dayjs.utc(apt.startTime).isBefore(slotEnd)) && (dayjs.utc(apt.endTime).isAfter(slotStart)) )
          );
          return !hasOverlappingAppointment;
        });
        
        if (isAnyEmployeeFree) {
          availableSlots.push(slotStart.format('HH:mm'));
        }
      }
      
      currentTime = currentTime.add(15, 'minutes');
    }
    
    console.log('[AVAILABILITY] Bucle finalizado. Total de huecos encontrados:', availableSlots.length, availableSlots);
    res.status(200).json(availableSlots);

  } catch (error) {
    console.error('[AVAILABILITY] Error fatal al calcular la disponibilidad:', error);
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});

export default router;


// ====== [47] apps/server/src/api/bookings.routes.ts ======
// File: /apps/server/src/api/bookings.routes.ts (CON LOGS PARA DEPURACI√ìN)

import { Router } from 'express';
import { z, ZodError } from 'zod';
import dayjs from 'dayjs';
import prisma from '../lib/prisma';
import { Prisma } from '@prisma/client';
import { notificationService } from '../lib/notificationService';
import { findAvailableEmployeeForSlot } from '../lib/availabilityService';

const router = Router();

const createBookingSchema = z.object({
  serviceId: z.string().cuid({ message: 'El ID del servicio no es v√°lido.' }),
  startTime: z.coerce.date({ invalid_type_error: 'La fecha de inicio debe ser una fecha v√°lida.' }),
  employeeId: z.string().cuid({ message: 'El ID del empleado no es v√°lido.' }).optional(),
  customerName: z.string().min(3, { message: 'El nombre del cliente es requerido.' }),
  customerEmail: z.string().email({ message: 'El email del cliente no es v√°lido.' }),
  customerPhone: z.string().min(1, { message: 'El tel√©fono del cliente es requerido.' }),
});


router.post('/', async (req, res) => {
  try {
    console.log('\n\n--- [POST /bookings] Nueva Petici√≥n de Reserva ---');
    const validatedData = createBookingSchema.parse(req.body);
    console.log('[POST /bookings] Datos recibidos y validados:', validatedData);

    const { serviceId, startTime, customerName, customerEmail, customerPhone } = validatedData;
    let assignedEmployeeId = validatedData.employeeId;

    const service = await prisma.service.findUnique({ where: { id: serviceId } });
    if (!service) {
      return res.status(404).json({ message: 'El servicio seleccionado no existe.' });
    }
    const endTime = dayjs(startTime).add(service.duration, 'minutes').toDate();

    if (!assignedEmployeeId) {
      assignedEmployeeId = await findAvailableEmployeeForSlot(startTime, endTime, service.duration);
    }

    if (!assignedEmployeeId) {
      console.log('[POST /bookings] FALLO: No se pudo asignar un empleado. Devolviendo 409.');
      return res.status(409).json({ message: 'Lo sentimos, no hay profesionales disponibles en el horario seleccionado. Por favor, elige otra hora.' });
    }
    
    console.log(`[POST /bookings] √âXITO: Empleado asignado -> ID: ${assignedEmployeeId}`);
    const newAppointment = await prisma.appointment.create({
      data: {
        startTime, endTime, status: 'CONFIRMED',
        employee: { connect: { id: assignedEmployeeId } },
        services: { create: { service: { connect: { id: serviceId } } } },
        user: {
          connectOrCreate: {
            where: { email: customerEmail },
            create: { email: customerEmail, name: customerName, role: 'CUSTOMER' },
          },
        },
      },
    });

    const fullAppointmentDetails = await prisma.appointment.findUnique({
      where: { id: newAppointment.id },
      include: { user: true, employee: true, services: { include: { service: true } } },
    });

    if (fullAppointmentDetails) {
      notificationService.sendBookingConfirmation(fullAppointmentDetails);
    }

    res.status(201).json(newAppointment);

  } catch (error) {
    if (error instanceof ZodError) {
      return res.status(400).json({ message: 'Datos de entrada inv√°lidos.', errors: error.issues });
    }
    if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
      return res.status(404).json({ message: 'El empleado especificado no existe.' });
    }
    console.error('Error al crear la reserva:', error);
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});

export default router;


// ====== [48] apps/server/src/api/employees.routes.ts ======
// File: /apps/server/src/api/employees.routes.ts (ORDEN CORREGIDO)

import { Router } from 'express';
import { z, ZodError } from 'zod';
import { Prisma, EmployeeStatus } from '@prisma/client';
import prisma from '../lib/prisma';
import { createEmployeeSchema } from '@aquaclean/types';

const router = Router();

// --- GESTI√ìN DEL PERFIL DEL EMPLEADO Y RUTAS P√öBLICAS ---

// Ruta para el panel de admin
router.get('/', async (req, res) => {
  try {
    const { status } = req.query;
    let whereClause = {};
    if (status === 'ACTIVE' || status === 'ARCHIVED') {
      whereClause = { status: status as EmployeeStatus };
    }
    const employees = await prisma.employee.findMany({ where: whereClause, orderBy: { name: 'asc' } });
    res.status(200).json(employees);
  } catch (error) {
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});

// --- RUTA P√öBLICA (MOVIDA HACIA ARRIBA) ---
router.get('/public', async (req, res) => {
  try {
    const publicEmployees = await prisma.employee.findMany({
      where: { status: 'ACTIVE' },
      select: { id: true, name: true, bio: true, imageUrl: true },
      orderBy: { name: 'asc' },
    });
    res.status(200).json(publicEmployees);
  } catch (error) {
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});

// --- RUTA GEN√âRICA CON :id (AHORA VA DESPU√âS DE LA ESPEC√çFICA) ---
router.get('/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const employee = await prisma.employee.findUnique({ where: { id } });
    if (!employee) return res.status(404).json({ message: 'Empleado no encontrado.' });
    res.status(200).json(employee);
  } catch (error) {
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});

router.post('/', async (req, res) => {
  try {
    const validatedData = createEmployeeSchema.parse(req.body);
    const { workSchedule, ...restOfData } = validatedData;
    const newEmployee = await prisma.employee.create({
      data: {
        ...restOfData,
        workSchedule: (workSchedule as Prisma.JsonObject) ?? Prisma.JsonNull,
      },
    });
    res.status(201).json(newEmployee);
  } catch (error) {
    if (error instanceof ZodError) return res.status(400).json({ errors: error.issues });
    if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
      return res.status(409).json({ message: 'Ya existe un empleado con ese email.' });
    }
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});

router.put('/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const updateSchema = createEmployeeSchema.partial();
    const validatedData = updateSchema.parse(req.body);
    const { workSchedule, ...restOfData } = validatedData;
    const updatedEmployee = await prisma.employee.update({
      where: { id },
      data: {
        ...restOfData,
        ...(workSchedule && {
          workSchedule: workSchedule as Prisma.JsonObject,
        }),
      },
    });
    res.status(200).json(updatedEmployee);
  } catch (error) {
    if (error instanceof ZodError) return res.status(400).json({ errors: error.issues });
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      if (error.code === 'P2025') return res.status(404).json({ message: 'Empleado no encontrado.' });
      if (error.code === 'P2002') return res.status(409).json({ message: 'Ya existe otro empleado con ese email.' });
    }
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});

// --- GESTI√ìN DE AUSENCIAS (VACACIONES, ETC.) ---
// ... (el resto del archivo no cambia) ...

const absenceSchema = z.object({
  startDate: z.coerce.date(),
  endDate: z.coerce.date(),
  reason: z.string().optional(),
});

router.get('/:employeeId/absences', async (req, res) => {
  try {
    const { employeeId } = req.params;
    const absences = await prisma.absence.findMany({ where: { employeeId } });
    res.status(200).json(absences);
  } catch (error) {
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});

router.post('/:employeeId/absences', async (req, res) => {
  try {
    const { employeeId } = req.params;
    const validatedData = absenceSchema.parse(req.body);
    const newAbsence = await prisma.absence.create({
      data: { ...validatedData, employeeId },
    });
    res.status(201).json(newAbsence);
  } catch (error) {
    if (error instanceof ZodError) return res.status(400).json({ errors: error.issues });
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});

router.delete('/:employeeId/absences/:absenceId', async (req, res) => {
  try {
    const { absenceId } = req.params;
    await prisma.absence.delete({ where: { id: absenceId } });
    res.status(204).send();
  } catch (error) {
    if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
      return res.status(404).json({ message: 'Ausencia no encontrada.' });
    }
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});

export default router;


// ====== [49] apps/server/src/api/services.routes.ts ======
// File: /apps/server/src/api/services.routes.ts (RECONSTRUIDO)

import { Router } from 'express';
import { ZodError } from 'zod';
import { Prisma } from '@prisma/client';
import prisma from '../lib/prisma';
import { createServiceSchema } from '@aquaclean/types';

const router = Router();

// --- OBTENER TODOS LOS SERVICIOS ---
router.get('/', async (req, res) => {
  try {
    const services = await prisma.service.findMany({
      orderBy: { name: 'asc' },
    });
    res.status(200).json(services);
  } catch (error) {
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});

// --- CREAR UN NUEVO SERVICIO ---
router.post('/', async (req, res) => {
  try {
    const validatedData = createServiceSchema.parse(req.body);
    const newService = await prisma.service.create({
      data: validatedData,
    });
    res.status(201).json(newService);
  } catch (error) {
    if (error instanceof ZodError) {
      return res.status(400).json({ message: 'Datos de entrada inv√°lidos.', errors: error.issues });
    }
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});

// --- ACTUALIZAR UN SERVICIO EXISTENTE ---
router.put('/:id', async (req, res) => {
  try {
    const { id } = req.params;
    // Hacemos el esquema parcial para permitir actualizaciones de solo algunos campos
    const updateSchema = createServiceSchema.partial();
    const validatedData = updateSchema.parse(req.body);

    const updatedService = await prisma.service.update({
      where: { id },
      data: validatedData,
    });
    res.status(200).json(updatedService);
  } catch (error) {
    if (error instanceof ZodError) {
      return res.status(400).json({ message: 'Datos de entrada inv√°lidos.', errors: error.issues });
    }
    if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
      return res.status(404).json({ message: 'Servicio no encontrado.' });
    }
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});

// --- ELIMINAR UN SERVICIO ---
router.delete('/:id', async (req, res) => {
  try {
    const { id } = req.params;

    // L√≥gica de seguridad: Comprobar si hay citas asociadas
    const appointmentCount = await prisma.appointmentService.count({
      where: { serviceId: id },
    });

    if (appointmentCount > 0) {
      return res.status(409).json({ // 409 Conflict
        message: `No se puede eliminar el servicio porque tiene ${appointmentCount} citas asociadas. Por favor, desact√≠valo en su lugar.`,
      });
    }

    await prisma.service.delete({
      where: { id },
    });
    res.status(204).send(); // 204 No Content
  } catch (error) {
    if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
      return res.status(404).json({ message: 'Servicio no encontrado.' });
    }
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
});

export default router;


// ====== [50] apps/server/src/lib/availabilityService.ts ======
// File: /apps/server/src/lib/availabilityService.ts (CORRECCI√ìN FINAL)

import dayjs from 'dayjs';
import utc from 'dayjs/plugin/utc';
import isSameOrAfter from 'dayjs/plugin/isSameOrAfter';
import isSameOrBefore from 'dayjs/plugin/isSameOrBefore';
import isBetween from 'dayjs/plugin/isBetween';
import 'dayjs/locale/en';
import { Employee, Absence } from '@prisma/client';
import prisma from './prisma';

dayjs.extend(utc);
dayjs.extend(isSameOrAfter);
dayjs.extend(isSameOrBefore);
dayjs.extend(isBetween);
dayjs.locale('en');

export function isEmployeeAvailable(
  employee: Employee & { absences: Absence[] },
  slot: dayjs.Dayjs,
  serviceDuration: number
): boolean {
  const dayOfWeek = slot.format('dddd').toLowerCase();
  const workSchedule = employee.workSchedule as any;
  const daySchedule = workSchedule?.[dayOfWeek];

  if (!daySchedule || daySchedule.length === 0) {
    return false;
  }

  const worksDuringSlot = (daySchedule as any[]).some(shift => {
    // --- LA CORRECCI√ìN CLAVE EST√Å AQU√ç ---
    // Creamos las horas de inicio y fin del turno en la ZONA HORARIA LOCAL DEL SERVIDOR.
    // dayjs() sin .utc() asume la zona horaria del sistema.
    // Esto convierte "09:00" local a su equivalente en UTC (ej: 07:00 UTC),
    // permitiendo una comparaci√≥n correcta con el 'slot' que tambi√©n est√° en UTC.
    const shiftStart = dayjs(`${slot.format('YYYY-MM-DD')}T${shift.start}`);
    const shiftEnd = dayjs(`${slot.format('YYYY-MM-DD')}T${shift.end}`);
    const slotEnd = slot.add(serviceDuration, 'minutes');

    return slot.isSameOrAfter(shiftStart) && slotEnd.isSameOrBefore(shiftEnd);
  });

  if (!worksDuringSlot) {
    return false;
  }
  
  const hasAbsence = employee.absences.some(absence => {
    const absenceStart = dayjs.utc(absence.startDate).startOf('day');
    const absenceEnd = dayjs.utc(absence.endDate).endOf('day');
    return slot.isBetween(absenceStart, absenceEnd, null, '[]');
  });

  if (hasAbsence) {
    return false;
  }

  return true;
};

export async function findAvailableEmployeeForSlot(startTime: Date, endTime: Date, serviceDuration: number): Promise<string | undefined> {
  const overlappingAppointments = await prisma.appointment.findMany({
    where: { OR: [ { startTime: { lt: endTime }, endTime: { gt: startTime } } ] },
    select: { employeeId: true },
  });
  const busyEmployeeIds = new Set(overlappingAppointments.map(a => a.employeeId));

  const potentialEmployees = await prisma.employee.findMany({
    where: { 
      status: 'ACTIVE', 
      id: { notIn: Array.from(busyEmployeeIds) },
      absences: { none: { startDate: { lte: endTime }, endDate: { gte: startTime } } } 
    },
    include: { absences: true }
  });
  
  const startTimeUtc = dayjs.utc(startTime);

  const availableEmployee = potentialEmployees.find(employee => {
    return isEmployeeAvailable(employee, startTimeUtc, serviceDuration);
  });

  return availableEmployee ? availableEmployee.id : undefined;
}


// ====== [51] apps/server/src/lib/notificationService.ts ======
// File: /apps/server/src/lib/notificationService.ts (VERSI√ìN FINAL CON ETHEREAL FORZADO Y SIN ERRORES)

import nodemailer from 'nodemailer';
import { Appointment, Employee, Service, User } from '@prisma/client';
import dayjs from 'dayjs';
import 'dayjs/locale/es';

dayjs.locale('es');

export type FullAppointmentDetails = Appointment & {
  user: User;
  employee: Employee;
  services: { service: Service }[];
};

let transporter: nodemailer.Transporter | null = null;
let testAccount: nodemailer.TestAccount | null = null;

/**
 * Crea y configura un transporter de Nodemailer usando una cuenta de prueba de Ethereal.
 * Es una funci√≥n as√≠ncrona que solo se ejecuta una vez para obtener las credenciales.
 */
async function getTransporter() {
  // Si ya tenemos el transporter, lo reutilizamos.
  if (transporter) {
    return transporter;
  }

  // Si no, creamos una cuenta de prueba de Ethereal.
  testAccount = await nodemailer.createTestAccount();

  console.log('--- Ethereal Mail Account (SIMULADOR DE EMAIL) ---');
  console.log('User:', testAccount.user);
  console.log('Pass:', testAccount.pass);
  console.log('Los emails enviados aparecer√°n en la terminal con un enlace individual.');
  console.log('----------------------------------------------------');

  transporter = nodemailer.createTransport({
    host: 'smtp.ethereal.email',
    port: 587,
    secure: false, // true for 465, false for other ports
    auth: {
      user: testAccount.user, // generated ethereal user
      pass: testAccount.pass, // generated ethereal password
    },
  });

  return transporter;
}

/**
 * Env√≠a un email de confirmaci√≥n de reserva al cliente y una notificaci√≥n al negocio.
 * @param appointmentDetails - El objeto completo de la cita con sus relaciones.
 */
async function sendBookingConfirmation(appointmentDetails: FullAppointmentDetails) {
  try {
    const mailTransporter = await getTransporter();
    const { user, employee, services, startTime } = appointmentDetails;
    const service = services[0]?.service;

    if (!service) {
      console.error('Error: No se encontr√≥ el servicio en los detalles de la cita.');
      return;
    }

    const formattedDateTime = dayjs(startTime).format('dddd, D [de] MMMM [de] YYYY [a las] HH:mm');

    // 1. Email para el Cliente
    const customerMailOptions = {
      from: '"AquaClean Car Wash" <noreply@aquaclean.com>',
      to: user.email,
      subject: `¬°Tu cita en AquaClean est√° confirmada para el ${dayjs(startTime).format('DD/MM/YYYY')}!`,
      text: `
        Hola ${user.name || 'Cliente'},

        ¬°Gracias por reservar con nosotros!

        Tu cita ha sido confirmada con los siguientes detalles:
        - Servicio: ${service.name}
        - Profesional: ${employee.name}
        - Fecha y Hora: ${formattedDateTime}

        Te esperamos. Si necesitas cancelar o reprogramar, por favor, contacta con nosotros.

        Saludos,
        El equipo de AquaClean Car Wash
      `,
    };

    // 2. Email para el Negocio (se enviar√° a Ethereal tambi√©n)
    const businessMailOptions = {
      from: '"Sistema de Reservas AquaClean" <noreply@aquaclean.com>',
      to: 'business@aquaclean.com', // Direcci√≥n de prueba
      subject: `üì¢ Nueva Reserva: ${service.name} para ${user.name}`,
      text: `
        ¬°Se ha registrado una nueva reserva!

        Detalles de la cita:
        - Cliente: ${user.name} (${user.email})
        - Servicio: ${service.name}
        - Profesional Asignado: ${employee.name}
        - Fecha y Hora: ${formattedDateTime}

        La cita ha sido a√±adida autom√°ticamente al planning.
      `,
    };

    const [customerInfo, businessInfo] = await Promise.all([
      mailTransporter.sendMail(customerMailOptions),
      mailTransporter.sendMail(businessMailOptions),
    ]);

    // --- LOGS CORREGIDOS ---
    // Obtenemos la URL del mensaje DESPU√âS de enviarlo, lo cual es correcto y no da error.
    console.log('----------------------------------------------------');
    console.log('‚úÖ Emails de simulaci√≥n enviados con √©xito.');
    console.log('üîó Vista previa del email del CLIENTE:', nodemailer.getTestMessageUrl(customerInfo));
    console.log('üîó Vista previa del email del NEGOCIO:', nodemailer.getTestMessageUrl(businessInfo));
    console.log('----------------------------------------------------');

  } catch (error) {
    console.error('Error al enviar los emails de confirmaci√≥n:', error);
  }
}


// Exportamos el servicio para que pueda ser utilizado en otras partes de la aplicaci√≥n
export const notificationService = {
  sendBookingConfirmation,
};


// ====== [52] apps/server/src/lib/prisma.ts ======
// File: /apps/server/src/lib/prisma.ts

import { PrismaClient } from '@prisma/client';

// Se recomienda instanciar PrismaClient una sola vez en tu aplicaci√≥n.
// Esto evita agotar el n√∫mero de conexiones a la base de datos.
// https://www.prisma.io/docs/guides/performance-and-optimization/connection-management#prismaclient-in-long-running-applications

const prisma = new PrismaClient();

export default prisma;


// ====== [53] apps/server/src/server.ts ======
// File: /apps/server/src/server.ts (ACTUALIZADO)

import express, { Request, Response } from 'express';
import cors from 'cors';
import dotenv from 'dotenv';

// Importamos nuestros enrutadores
import servicesRouter from './api/services.routes';
import employeesRouter from './api/employees.routes';
import authRouter from './api/auth.routes';
import availabilityRouter from './api/availability.routes';
import bookingsRouter from './api/bookings.routes';
import adminAppointmentsRouter from './api/adminAppointments.routes';
import adminSettingsRouter from './api/adminSettings.routes';
// --- L√çNEA MODIFICADA ---
import adminDateOverridesRouter from './api/adminDateOverrides.routes'; // <-- IMPORTAMOS EL NUEVO ENRUTADOR

// Cargar variables de entorno
dotenv.config();

const app = express();
const PORT = process.env.PORT || 3001;

// Middlewares b√°sicos
app.use(cors({ origin: process.env.CORS_ALLOWED_ORIGIN || 'http://localhost:5173' }));
app.use(express.json());

// --- RUTAS DE LA API ---

// Rutas P√∫blicas y de Clientes
app.use('/api/auth', authRouter);
app.use('/api/services', servicesRouter);
app.use('/api/employees', employeesRouter);
app.use('/api/availability', availabilityRouter);
app.use('/api/bookings', bookingsRouter);

// Rutas Espec√≠ficas del Panel de Administraci√≥n
app.use('/api/admin/appointments', adminAppointmentsRouter);
app.use('/api/admin/settings', adminSettingsRouter);
// --- L√çNEA MODIFICADA ---
app.use('/api/admin/overrides', adminDateOverridesRouter); // <-- USAMOS EL NUEVO ENRUTADOR Y CAMBIAMOS LA RUTA


// Ruta de prueba para verificar que el servidor funciona
app.get('/api', (req: Request, res: Response) => {
  res.json({ message: 'üëã Hello from the AquaClean API!' });
});

// Iniciar el servidor
app.listen(PORT, () => {
  console.log(`üöÄ Server is running on http://localhost:${PORT}`);
});


// ====== [54] apps/server/tsconfig.json ======
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "dist",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "noEmit": false
  },
  "include": ["src/**/*.ts", "prisma/**/*.ts"],
  "exclude": ["node_modules", "dist"]
}


// ====== [55] docs/PROJECT_SPECIFICATION.md ======
<!-- File: /docs/PROJECT_SPECIFICATION.md - v1.1 -->

# Propuesta y Especificaci√≥n del Proyecto: AquaClean Car Wash

## 1. Visi√≥n del Proyecto

Construir una aplicaci√≥n web a medida de alto rendimiento que act√∫e como el motor central del negocio. La plataforma digitalizar√° por completo la experiencia del cliente, desde la reserva hasta la valoraci√≥n, y proporcionar√° al personal herramientas de gesti√≥n avanzadas para optimizar las operaciones, automatizar el marketing y potenciar el crecimiento.

## 2. Arquitectura Tecnol√≥gica

El proyecto se construir√° sobre un stack tecnol√≥gico moderno, robusto y escalable, garantizando un desarrollo eficiente y un producto final de m√°xima calidad.

| √Årea                                     | Tecnolog√≠as                                                    |
| :--------------------------------------- | :------------------------------------------------------------- |
| **Lenguaje Principal**                   | **TypeScript**                                                 |
| **Frontend**                             | React 18, Vite, Mantine UI                                     |
| **Gesti√≥n de Estado (Frontend)**         | Zustand                                                        |
| **Backend**                              | Node.js, Express.js, Zod                                       |
| **ORM y Base de Datos**                  | Prisma, PostgreSQL                                             |
| **Testing**                              | Vitest, React Testing Library                                  |
| **Herramientas de Desarrollo y Calidad** | pnpm Monorepo, Turborepo, ESLint, Prettier, Husky, lint-staged |

## 3. Desglose Detallado de Funcionalidades

Esta secci√≥n act√∫a como un √≠ndice hacia los documentos de especificaci√≥n detallada para cada m√≥dulo del sistema.

- **Sistema de Autenticaci√≥n**
  - Flujos de registro, login (email/Google), verificaci√≥n y recuperaci√≥n de contrase√±a.
  - **[Ver especificaciones detalladas en `01-authentication.md`](./features/01-authentication.md)**

- **Sitio P√∫blico y Presentaci√≥n**
  - Detalle de las secciones p√∫blicas (Inicio, Servicios, Equipo, Valoraciones, Tarjetas Regalo).
  - **[Ver especificaciones detalladas en `02-public-site.md`](./features/02-public-site.md)**

- **Flujo de Reserva del Cliente**
  - El paso a paso detallado del proceso de reserva online.
  - **[Ver especificaciones detalladas en `03-booking-flow.md`](./features/03-booking-flow.md)**

- **Panel de Cliente**
  - Funcionalidades del √°rea de cliente (Mis Citas, Mis Veh√≠culos, Bonos, Perfil).
  - **[Ver especificaciones detalladas en `04-customer-panel.md`](./features/04-customer-panel.md)**

- **Panel de Administraci√≥n: Gesti√≥n Base**
  - Configuraci√≥n de Servicios, Empleados, Horarios y Clientes.
  - **[Ver especificaciones detalladas en `05-admin-panel-core-management.md`](./features/05-admin-panel-core-management.md)**

- **Panel de Administraci√≥n: Operaciones Diarias**
  - Herramientas del d√≠a a d√≠a (Dashboard, Planning Visual, Gesti√≥n de Citas).
  - **[Ver especificaciones detalladas en `06-admin-panel-operations.md`](./features/06-admin-panel-operations.md)**

- **Sistema de Valoraciones**
  - Flujo de solicitud de valoraciones y panel de moderaci√≥n de rese√±as.
  - **[Ver especificaciones detalladas en `07-reviews-system.md`](./features/07-reviews-system.md)**

- **M√≥dulos de Marketing y Monetizaci√≥n**
  - Gesti√≥n de bonos, programas de fidelizaci√≥n y suscripciones.
  - **[Ver especificaciones detalladas en `08-marketing-monetization.md`](./features/08-marketing-monetization.md)**

- **Sistema de Notificaciones**
  - Detalle de todos los emails y mensajes de WhatsApp autom√°ticos.
  - **[Ver especificaciones detalladas en `09-notifications-system.md`](./features/09-notifications-system.md)**

- **Integraciones Externas**
  - Especificaciones de la sincronizaci√≥n con Google Calendar y la pasarela de pago Stripe.
  - **[Ver especificaciones detalladas en `10-external-integrations.md`](./features/10-external-integrations.md)**



// ====== [56] docs/features/01-authentication.md ======
<!-- File: /docs/features/01-authentication.md - v1.0 -->
````markdown
# 1. Sistema de Autenticaci√≥n

## 1.1. Objetivo

Permitir a los usuarios crear una cuenta segura y acceder a su panel personal. Ofrecer m√©todos de registro modernos y de baja fricci√≥n para maximizar la conversi√≥n de visitante a cliente registrado, incluyendo el registro cl√°sico por email y el inicio de sesi√≥n social con Google.

## 1.2. Flujos de Usuario (User Stories)

### Registro con Email y Contrase√±a

1.  Como nuevo usuario, quiero poder hacer clic en "Registrarse".
2.  Quiero ver un formulario que me pida Nombre, Email y Contrase√±a.
3.  La contrase√±a debe tener un indicador de seguridad visual (ej: m√≠nimo 8 caracteres, una may√∫scula, un n√∫mero).
4.  Al enviar el formulario, quiero recibir un email para verificar que mi correo es real.
5.  La aplicaci√≥n debe informarme de que revise mi bandeja de entrada para completar el registro.
6.  Al hacer clic en el enlace de verificaci√≥n del email, mi cuenta se activar√° y ser√© redirigido a la p√°gina de "Inicio de Sesi√≥n".

### Registro / Inicio de Sesi√≥n con Google (OAuth)

1.  Como usuario, quiero ver un bot√≥n "Continuar con Google" en las p√°ginas de registro e inicio de sesi√≥n.
2.  Al hacer clic, quiero que se abra el pop-up de autenticaci√≥n de Google.
3.  Tras autorizar los permisos, si es mi primera vez, se debe crear una cuenta en el sistema autom√°ticamente con mi nombre y email de Google.
4.  Si ya tengo una cuenta asociada a ese email, se debe iniciar sesi√≥n.
5.  En ambos casos, debo ser redirigido a mi "Panel de Cliente" (`/dashboard`).

### Inicio de Sesi√≥n Cl√°sico

1.  Como usuario registrado, quiero poder introducir mi email y contrase√±a para acceder.
2.  Quiero una opci√≥n de "Recordar sesi√≥n" (checkbox) para no tener que iniciar sesi√≥n cada vez.
3.  Si introduzco credenciales incorrectas, quiero ver un mensaje de error claro.
4.  Quiero un enlace de "¬øHas olvidado tu contrase√±a?" por si no la recuerdo.

### Recuperaci√≥n de Contrase√±a

1.  Al hacer clic en "¬øHas olvidado tu contrase√±a?", quiero ir a una p√°gina donde introduzco mi direcci√≥n de email.
2.  Tras enviar mi email, quiero recibir un correo con un enlace seguro y de un solo uso para establecer una nueva contrase√±a.
3.  Al hacer clic en el enlace, quiero ser llevado a una p√°gina donde pueda introducir y confirmar mi nueva contrase√±a.
4.  Tras cambiarla con √©xito, quiero ser redirigido a la p√°gina de "Inicio de Sesi√≥n".

## 1.3. Componentes de UI (Vistas Necesarias)

- P√°gina de Registro: `/auth/register`
- P√°gina de Inicio de Sesi√≥n: `/auth/login`
- P√°gina de "Verifica tu Email": `/auth/verify-request` (P√°gina informativa que se muestra tras el registro).
- P√°gina de "Contrase√±a Olvidada": `/auth/forgot-password`
- P√°gina para "Restablecer Contrase√±a": `/auth/reset-password?token=[TOKEN]`

## 1.4. Modelo de Datos (Esquema Prisma)

```prisma
// Este esquema define la estructura de la base de datos para la autenticaci√≥n.
// Sigue el est√°ndar de NextAuth.js/Auth.js para m√°xima compatibilidad.

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  passwordHash  String?   // Hash de la contrase√±a para usuarios de email/pass
  image         String?
  accounts      Account[]
  sessions      Session[]
  appointments  Appointment[]
  // ... otros campos relacionados con el cliente
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String  // ej. "google"
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}
```
````

## 1.5. Endpoints de la API

- `POST /api/auth/register`: Recibe `{ name, email, password }`. Crea el usuario (inactivo), genera un token de verificaci√≥n y env√≠a el email.
- `POST /api/auth/login`: Recibe `{ email, password }`. Valida las credenciales y devuelve una sesi√≥n (cookie JWT).
- `GET /api/auth/verify-email?token=[TOKEN]`: Valida el token de email, marca `emailVerified` en la base de datos y activa la cuenta.
- `POST /api/auth/forgot-password`: Recibe `{ email }`. Genera un token de reseteo y lo env√≠a por email.
- `POST /api/auth/reset-password`: Recibe `{ token, newPassword }`. Valida el token y actualiza el `passwordHash` del usuario.
- `GET /api/auth/providers/google`: Redirige al usuario a la p√°gina de consentimiento de Google (inicia el flujo OAuth).
- `GET /api/auth/providers/google/callback`: Endpoint al que Google redirige tras la autorizaci√≥n. Procesa los datos del usuario, crea/loguea al usuario y establece la sesi√≥n.
- `POST /api/auth/logout`: Cierra la sesi√≥n del usuario.

```

```




// ====== [57] docs/features/02-public-site.md ======
<!-- File: /docs/features/02-public-site.md - v1.1 (ACTUALIZADO) -->

# 2. Sitio P√∫blico y Presentaci√≥n

## 2.1. Objetivo

Construir la cara visible del negocio. Esta √°rea debe ser visualmente atractiva, profesional, r√°pida y estar optimizada para convertir visitantes en clientes. Cada p√°gina tiene el prop√≥sito de informar, generar confianza y guiar al usuario hacia la acci√≥n principal: la reserva de una cita.

## 2.2. Desglose de P√°ginas y Secciones

### P√°gina de Inicio (`/`)

**Estado: Implementado.** La p√°gina de inicio est√° funcional y sus botones de llamada a la acci√≥n redirigen directamente al flujo de reserva (`/booking`).

**Prop√≥sito:** La primera impresi√≥n. Debe captar la atenci√≥n del usuario en segundos y comunicar el valor y la calidad del servicio.

### P√°gina de Servicios (`/services`)

**Estado: Implementado.**

**Prop√≥sito:** Actuar como un cat√°logo digital informativo. Aunque ya no es un paso obligatorio en la reserva, permite a los clientes interesados conocer en detalle los diferentes tratamientos que se han ofrecido o se podr√≠an ofrecer.

**Componentes Clave:**

- **Listado de Servicios:**
  - Una cuadr√≠cula con los servicios. Cada "tarjeta" de servicio incluye: nombre, descripci√≥n, duraci√≥n y precio.

**Datos Requeridos (API):**

- ‚úÖ `GET /api/services`

### P√°gina "Nuestro Equipo" (`/team`)

**Estado: Implementado.**

**Prop√≥sito:** Humanizar la marca y generar confianza, presentando al personal que realiza los servicios.

**Componentes Clave:**

- **Perfiles de Empleados:**
  - Una secci√≥n para cada t√©cnico con su foto, nombre, cargo y una breve biograf√≠a.
- **Llamada a la Acci√≥n:**
  - Cada perfil tiene un bot√≥n "Ver Servicios" que gu√≠a al usuario hacia el flujo de reserva.
- **(Futuro):** El bot√≥n podr√≠a evolucionar a "Reservar con [Nombre]", pre-seleccionando a ese empleado en la p√°gina de booking.

**Datos Requeridos (API):**

- ‚úÖ `GET /api/employees` (Endpoint p√∫blico).

### P√°gina de Valoraciones de Clientes (`/reviews`)

**Estado: Pendiente.**

**Prop√≥sito:** Proveer prueba social masiva y transparente, mostrando las experiencias de otros clientes.

### P√°gina de Tarjetas Regalo (`/gift-cards`)

**Estado: Pendiente.**

**Prop√≥sito:** Crear una nueva l√≠nea de ingresos permitiendo a los usuarios regalar servicios.



// ====== [58] docs/features/03-booking-flow.md ======
<!-- File: /docs/features/03-booking-flow.md - v1.2 (Actualizado con Estado de Bug) -->

# 3. Flujo de Reserva del Cliente

## 3.1. Objetivo

Dise√±ar un proceso de reserva online que sea intuitivo, r√°pido y sin fricciones. El objetivo es guiar al usuario desde la selecci√≥n del profesional (opcional) hasta la confirmaci√≥n de la cita en el menor n√∫mero de pasos posible, minimizando la tasa de abandono y maximizando las conversiones.

## 3.2. Puntos de Entrada al Flujo

Un usuario puede iniciar el proceso de reserva desde m√∫ltiples puntos en la web:

- Bot√≥n "Reservar Ahora" en la p√°gina de Inicio, que dirige a `/booking`.
- Bot√≥n "Reservar Cita" en la cabecera, que dirige a `/booking`.
- (Futuro) Bot√≥n "Reservar con [Nombre]" en la p√°gina de equipo, que dirigir√° a `/booking` con el empleado ya pre-seleccionado.

## 3.3. Desglose del Proceso por Pasos

El flujo se presenta como un asistente multi-paso en la p√°gina `/booking`.

### Paso 1: Selecci√≥n de Profesional (Opcional) y Fecha/Hora

**UI/UX:**

- **Selecci√≥n de Profesional:**
  - Se muestra un selector (`Select`) que permite al usuario elegir un empleado espec√≠fico o mantener la opci√≥n por defecto: **"Cualquier Profesional"**.
- **Selecci√≥n de Fecha:**
  - Se muestra un componente de calendario (`DatePicker`).
- **Selecci√≥n de Hora:**
  - Al cargar la p√°gina (y cada vez que se cambia de profesional o de d√≠a), se realiza una llamada a la API para obtener los huecos de tiempo disponibles.
  - Se muestra una cuadr√≠cula con los "slots" de tiempo disponibles (ej: 09:00, 10:15, 11:30).
  - El usuario selecciona un slot.
- El bot√≥n "Siguiente" se activa una vez se ha seleccionado una fecha y una hora.

**L√≥gica de Negocio:**

- **Estado: Implementado.** La API de disponibilidad (`GET /api/availability`) es el cerebro del sistema y funciona correctamente, mostrando los huecos disponibles.
  - Si se selecciona "Cualquier Profesional", la API calcula la capacidad total.
  - Si se selecciona un profesional espec√≠fico, la API calcula su disponibilidad individual.

**API Calls:**

- ‚úÖ `GET /api/employees/public`
- ‚úÖ `GET /api/availability?date=[YYYY-MM-DD]`
- ‚úÖ `GET /api/availability?date=[YYYY-MM-DD]&employeeId=[ID]`

### Paso 2: Informaci√≥n Personal

**UI/UX:**

- Un formulario (`@mantine/form`) solicita los datos del cliente: Nombre, Email y N√∫mero de Tel√©fono.
- El bot√≥n "Siguiente" se activa cuando todos los campos obligatorios est√°n validados.

### Paso 3: Resumen y Confirmaci√≥n

**UI/UX:**

- Se muestra un resumen completo y claro de toda la selecci√≥n.
- El bot√≥n final es "Confirmar Reserva".

**L√≥gica de Negocio:**

- Al hacer clic en "Confirmar", se env√≠a toda la informaci√≥n a la API de creaci√≥n de reservas.
- **Estado: üî¥ Con Bug Bloqueante.** Aunque la l√≥gica de auto-asignaci√≥n est√° implementada en el backend, actualmente sufre de un bug cr√≠tico de inconsistencia. Esto causa que devuelva incorrectamente un error `409 Conflict` ("No hay profesionales disponibles") incluso para huecos que la API de disponibilidad ha mostrado como v√°lidos, impidiendo que las reservas se completen.

**API Calls:**

- [üî¥] `POST /api/bookings`

## 3.4. Flujo Post-Reserva

- **P√°gina de √âxito:**
  - Inaccesible actualmente debido al bug de la API.
- **Notificaciones Autom√°ticas:**
  - **Estado: Pendiente.** La implementaci√≥n est√° en pausa hasta que se resuelva el bug de la API de reservas.



// ====== [59] docs/features/04-customer-panel.md ======
<!-- File: /docs/features/04-customer-panel.md - v1.0 -->
# 4. Panel de Cliente

## 4.1. Objetivo

Crear un √°rea privada y segura donde los clientes registrados puedan gestionar su relaci√≥n con el negocio de forma aut√≥noma. El panel debe proporcionar un valor a√±adido que fomente el registro y la fidelizaci√≥n, ofreciendo conveniencia, control y acceso a su historial y beneficios.

## 4.2. Desglose de Secciones del Panel

El panel de cliente estar√° disponible en la ruta `/dashboard` y sub-rutas, y ser√° accesible solo para usuarios autenticados.

### Secci√≥n: Mis Citas (`/dashboard/appointments`)

**Prop√≥sito:** El centro de operaciones del cliente. Proporciona una visi√≥n completa de su historial y sus pr√≥ximas citas.

**Componentes Clave:**

- **Pesta√±as de Navegaci√≥n:** "Pr√≥ximas Citas" y "Historial de Citas".
- **Vista "Pr√≥ximas Citas":**
  - Listado de citas pendientes.
  - Cada cita mostrar√°: Fecha, Hora, Servicio(s), Empleado asignado, Precio.
  - **Acciones por Cita:**
    - **Cancelar Cita:** Bot√≥n para solicitar la cancelaci√≥n. Se aplican reglas de negocio (ej: no se puede cancelar con menos de 24h de antelaci√≥n). Un modal pedir√° confirmaci√≥n.
    - **Solicitar Cambio:** Bot√≥n que abre un modal donde el cliente puede sugerir una nueva fecha/hora. Esto enviar√° una notificaci√≥n al administrador para su aprobaci√≥n manual.
    - **A√±adir al Calendario:** Opci√≥n para descargar un archivo `.ics`.
- **Vista "Historial de Citas":**
  - Listado de citas completadas.
  - Cada cita mostrar√° la misma informaci√≥n que las pr√≥ximas.
  - **Acciones por Cita:**
    - **Reservar de Nuevo:** Bot√≥n que inicia el flujo de reserva con el mismo servicio, veh√≠culo y (si est√° disponible) empleado ya pre-seleccionados.
    - **Dejar Valoraci√≥n:** Si la cita es reciente y a√∫n no ha sido valorada, se mostrar√° un bot√≥n para escribir una rese√±a.
    - **Ver Factura:** (Opcional, futuro) Enlace para ver/descargar la factura del servicio.

**API Calls:**

- `GET /api/me/appointments?status=upcoming`
- `GET /api/me/appointments?status=completed`
- `POST /api/me/appointments/[id]/cancel`
- `POST /api/me/appointments/[id]/reschedule-request`

### Secci√≥n: Mis Veh√≠culos (`/dashboard/vehicles`)

**Prop√≥sito:** Agilizar el proceso de reserva permitiendo al cliente guardar y gestionar la informaci√≥n de sus coches.

**Componentes Clave:**

- **Listado de Veh√≠culos Guardados:**
  - Una vista de "tarjetas" con cada veh√≠culo.
  - Cada tarjeta mostrar√°: Alias (ej: "Mi Coche"), Marca, Modelo y Tama√±o.
- **Acciones:**
  - **A√±adir Nuevo Veh√≠culo:** Bot√≥n que abre un formulario modal para introducir los datos de un nuevo coche.
  - **Editar/Eliminar:** Opciones en cada tarjeta para modificar los datos o eliminar el veh√≠culo del perfil.

**API Calls:**

- `GET /api/me/vehicles`
- `POST /api/me/vehicles`
- `PUT /api/me/vehicles/[id]`
- `DELETE /api/me/vehicles/[id]`

### Secci√≥n: Mis Bonos y Beneficios (`/dashboard/benefits`)

**Prop√≥sito:** Dar visibilidad sobre los programas de fidelizaci√≥n y los productos comprados, incentivando su uso.

**Componentes Clave:**

- **Secci√≥n de Bonos:**
  - Si el cliente ha comprado bonos (ej: "Bono 5 Lavados Premium"), se listar√°n aqu√≠.
  - Cada bono mostrar√°: Nombre del bono, Servicios restantes (ej: "3 de 5 restantes"), Fecha de caducidad (si aplica).
- **Secci√≥n de Puntos de Fidelizaci√≥n:**
  - Visualizaci√≥n de los puntos acumulados.
  - Informaci√≥n sobre c√≥mo canjear los puntos (ej: "500 puntos = 1 Lavado B√°sico Gratis").

**API Calls:**

- `GET /api/me/benefits`

### Secci√≥n: Mi Perfil (`/dashboard/profile`)

**Prop√≥sito:** Permitir al usuario mantener su informaci√≥n personal actualizada.

**Componentes Clave:**

- **Formulario de Datos Personales:**
  - Campos para editar: Nombre, Apellido, N√∫mero de Tel√©fono.
  - El email se mostrar√° pero no ser√° editable por ser el identificador principal de la cuenta.
- **Formulario de Cambio de Contrase√±a:**
  - Campos para: Contrase√±a Actual, Nueva Contrase√±a, Confirmar Nueva Contrase√±a.
  - (Este formulario solo ser√° visible para usuarios registrados con email/contrase√±a, no para los de OAuth).
- **Gesti√≥n de Notificaciones:**
  - Checkboxes para que el usuario elija sus preferencias (ej: "Recibir recordatorios por WhatsApp", "Recibir ofertas por email").

**API Calls:**

- `PUT /api/me/profile`
- `POST /api/me/change-password`




// ====== [60] docs/features/05-admin-panel-core-management.md ======
<!-- File: /docs/features/05-admin-panel-core-management.md - v1.2 (Actualizado con Anulaciones por Fecha) -->

# 5. Panel de Administraci√≥n: Gesti√≥n de la Configuraci√≥n Base

## 5.1. Objetivo

Proporcionar al administrador del negocio un control total sobre las entidades fundamentales de la plataforma. Esta secci√≥n se centra en la configuraci√≥n "maestra" que define c√≥mo opera el negocio: qu√© servicios se ofrecen, qui√©n trabaja, cu√°ndo trabajan y cu√°ndo descansan.

## 5.2. Desglose de Secciones

Estas secciones estar√°n bajo la ruta `/admin` y requerir√°n un rol de "Administrador".

### Secci√≥n: Gesti√≥n de Servicios (`/admin/services`)

**Estado: Implementado.** Se ha implementado un CRUD completo para el cat√°logo de servicios.

**Prop√≥sito:** Gestionar los servicios que ofrece el negocio.

**Componentes Clave:**

- **Vista de Listado:**
  - Una tabla que lista todos los servicios creados.
  - Columnas: Nombre, Duraci√≥n, Precio, **Estado (Activo/Inactivo)**.
  - Acciones por fila: "Editar", "Eliminar" (con modal de confirmaci√≥n y protecci√≥n contra borrado si hay citas asociadas).
  - Un `Switch` para cambiar r√°pidamente el estado `Activo/Inactivo` de un servicio.
- **Formulario de Creaci√≥n/Edici√≥n (en un Modal):**
  - Campos para: Nombre, Descripci√≥n, Duraci√≥n (en minutos), Precio, Categor√≠a y Estado.

**API Calls:**

- ‚úÖ `GET /api/services`
- ‚úÖ `POST /api/services`
- ‚úÖ `PUT /api/services/[id]`
- ‚úÖ `DELETE /api/services/[id]` (con l√≥gica de protecci√≥n).

### Secci√≥n: Gesti√≥n de Empleados y Horarios (`/admin/employees`)

**Estado: Implementado.** Se ha implementado una gesti√≥n avanzada de los empleados y su disponibilidad.

**Prop√≥sito:** Gestionar los perfiles del personal y, fundamentalmente, sus horarios de trabajo y ausencias, que son la base del sistema de disponibilidad.

**Componentes Clave:**

- **Vista de Listado:**
  - Una tabla con todos los empleados, filtrable por estado **(Activos/Archivados)**.
  - Acciones por fila: "Editar", "Archivar" y "Reactivar".
- **Modal de Edici√≥n Avanzado (con Pesta√±as):**
  - **Pesta√±a "Perfil":** Formulario para datos b√°sicos (Nombre, Email, Rol, Foto, Bio).
  - **Pesta√±a "Horario Laboral":**
    - Un editor visual para los 7 d√≠as de la semana.
    - Permite definir **m√∫ltiples turnos de trabajo por d√≠a** (ej: para configurar pausas de almuerzo).
  - **Pesta√±a "Ausencias y Vacaciones":**
    - Un calendario para a√±adir y visualizar bloqueos de d√≠as completos (vacaciones, bajas, etc.).
    - **Sistema de Detecci√≥n de Conflictos:** Si se intenta programar una ausencia en fechas donde el empleado ya tiene citas, el sistema lo notifica y muestra un modal para resolver el conflicto.

**API Calls:**

- ‚úÖ `GET /api/employees?status=[STATUS]`
- ‚úÖ `POST /api/employees`
- ‚úÖ `PUT /api/employees/[id]` (para perfil, horario y estado).
- ‚úÖ `GET /api/employees/[id]/absences`
- ‚úÖ `POST /api/employees/[id]/absences` (con l√≥gica de detecci√≥n de conflictos).
- ‚úÖ `DELETE /api/employees/[id]/absences/[id]`

### Secci√≥n: Configuraci√≥n del Negocio (`/admin/settings`)

**Estado: Implementado.**

**Prop√≥sito:** Un panel centralizado para gestionar las configuraciones globales y las excepciones del horario del negocio.

**Componentes Clave:**

- **Selecci√≥n del Servicio por Defecto:**
  - ‚úÖ Un `Select` que permite elegir cu√°l de los servicios **activos** se ofrecer√° a los clientes.
- **Formulario de Horario Semanal Est√°ndar:**
  - ‚úÖ Una interfaz visual (`ScheduleEditor`) para definir las horas de apertura y cierre recurrentes para cada d√≠a de la semana.
- **Gesti√≥n de Anulaciones por Fecha:**
  - ‚úÖ Una interfaz de calendario que permite anular el horario est√°ndar para fechas espec√≠ficas.
  - ‚úÖ Soporte para **Cierres de D√≠a Completo** (ej: festivos nacionales).
  - ‚úÖ Soporte para **Horarios Especiales** (ej: jornada reducida para un d√≠a concreto).
  - ‚úÖ Sistema de detecci√≥n de conflictos que avisa si se intenta modificar un d√≠a con citas ya programadas.

**API Calls:**

- ‚úÖ `GET /api/admin/settings` (para el horario y servicio por defecto).
- ‚úÖ `PUT /api/admin/settings`
- ‚úÖ `GET /api/admin/overrides` (para las anulaciones de fecha).
- ‚úÖ `POST /api/admin/overrides` (con l√≥gica de detecci√≥n de conflictos).
- ‚úÖ `DELETE /api/admin/overrides/[id]`

### Secci√≥n: Gesti√≥n de Clientes (`/admin/clients`)

**Estado: Pendiente.**

**Prop√≥sito:** Un CRM (Customer Relationship Management) simple para tener una visi√≥n 360 de cada cliente.



// ====== [61] docs/features/06-admin-panel-operations.md ======
<!-- File: /docs/features/06-admin-panel-operations.md - v1.2 (ACTUALIZADO) -->

# 6. Panel de Administraci√≥n: Operaciones Diarias

## 6.1. Objetivo

Equipar al administrador con las herramientas interactivas necesarias para la gesti√≥n del d√≠a a d√≠a del lavadero. Esta secci√≥n se enfoca en la visualizaci√≥n de la actividad, la manipulaci√≥n de la agenda y el seguimiento de cada cita de forma individual. Es el centro neur√°lgico para las operaciones en tiempo real.

## 6.2. Desglose de Secciones

### Secci√≥n: Dashboard de Anal√≠ticas (`/admin/dashboard`)

**Prop√≥sito:** La p√°gina de inicio del panel de administraci√≥n. Debe proporcionar una instant√°nea clara y r√°pida de la salud y la actividad del negocio.

**Componentes Clave:**

- **Tarjetas de KPIs (Indicadores Clave de Rendimiento):**
  - **Citas para Hoy:** N√∫mero total de citas programadas para el d√≠a actual.
  - **Ingresos del D√≠a:** Suma de los precios de las citas de hoy.
  - **Ocupaci√≥n Semanal:** Porcentaje de horas reservadas frente a horas disponibles para la semana en curso.
  - **Nuevos Clientes (Mes):** N√∫mero de clientes que se han registrado este mes.
- **Gr√°ficos Visuales (`Chart.js`):**
  - **Reservas por D√≠a:** Un gr√°fico de barras mostrando el n√∫mero de citas para cada d√≠a de la √∫ltima semana.
  - **Servicios M√°s Populares:** Un gr√°fico de tarta o de barras mostrando el top 5 de servicios m√°s reservados en los √∫ltimos 30 d√≠as.
- **Actividad Reciente:**
  - Un listado de las 5-10 pr√≥ximas citas del d√≠a.
  - Un feed de las √∫ltimas acciones importantes (ej: "Juan P√©rez ha cancelado su cita", "Nuevo cliente registrado: Mar√≠a L√≥pez").

**API Calls:**

- `GET /api/admin/dashboard/kpis`
- `GET /api/admin/dashboard/charts`
- `GET /api/admin/dashboard/activity`

### Secci√≥n: Planning Visual (Calendario) (`/admin/planning`)

**Prop√≥sito:** La herramienta m√°s importante para la gesti√≥n de la agenda. Permite una visualizaci√≥n clara de la carga de trabajo y una manipulaci√≥n r√°pida de las citas.

**Componentes Clave:**

- **Integraci√≥n de `FullCalendar`:**
  - **Estado: Implementado.** Se ha integrado la librer√≠a `FullCalendar` con los plugins `resourceTimeline`, `dayGrid`, `timeGrid` e `interaction`.
  - **Vista Semanal por Empleado (Resource Timeline):** Es la vista por defecto. Muestra los d√≠as de la semana en el eje X y los empleados como "recursos" en el eje Y. Las citas aparecen como bloques en la fila del empleado correspondiente.
  - **Otras Vistas:** Botones para cambiar a vista de D√≠a (`resourceTimelineDay`) o Mes (`dayGridMonth`).
  - **Navegaci√≥n:** Flechas para avanzar y retroceder por semanas/d√≠as.
- **Interactividad:**
  - **[‚úÖ] Reagendar y Reasignar (Drag & Drop):** El administrador puede arrastrar una cita a otra hora/d√≠a para reagendarla, o a la fila de otro empleado para reasignarla. Los cambios se guardan autom√°ticamente en la base de datos.
  - **[‚úÖ] Crear Cita Manualmente:** Al hacer clic en un hueco vac√≠o del calendario, se abre un modal para crear una nueva cita (ideal para reservas telef√≥nicas), pre-rellenando el empleado y la hora de inicio.
  - **[‚úÖ] Ver/Editar/Anular Cita:** Al hacer clic en una cita existente, se abre un modal con todos los detalles, permitiendo su edici√≥n completa (cambiar servicio, datos del cliente, etc.) y ofreciendo la opci√≥n de anular la cita (con un modal de confirmaci√≥n).
- **C√≥digo de Colores:** (Futuro) Las citas pueden tener colores diferentes seg√∫n su estado (ej: Azul para confirmadas, Verde para completadas, Gris para canceladas).

**API Calls:**

- ‚úÖ `GET /api/admin/appointments?start=[DATE]&end=[DATE]` (FullCalendar llama a esta API para obtener los eventos).
- ‚úÖ `PUT /api/admin/appointments/[id]` (Se llama a esta API al soltar una cita despu√©s de arrastrarla y para guardar ediciones desde el modal).
- ‚úÖ `POST /api/admin/appointments` (Para crear citas manualmente desde el modal).
- ‚úÖ `DELETE /api/admin/appointments/[id]` (Para anular citas desde el modal).

### Secci√≥n: Gesti√≥n de Citas (`/admin/appointments`)

**Prop√≥sito:** Proporcionar una vista de tabla detallada de todas las citas, con potentes herramientas de b√∫squeda y filtrado para encontrar y gestionar cualquier reserva espec√≠fica.

**Componentes Clave:**

- **Tabla de Datos Avanzada (`Mantine Data Table`):**
  - **B√∫squeda Global:** Un campo de b√∫squeda para encontrar citas por nombre del cliente, email, tel√©fono o servicio.
  - **Filtros Avanzados:** Dropdowns para filtrar por:
    - Rango de Fechas.
    - Empleado.
    - Estado de la Cita (Confirmada, Completada, Cancelada, Pendiente de Pago, etc.).
- **Columnas de la Tabla:**
  - ID de Cita, Cliente, Servicio(s), Fecha y Hora, Empleado, Duraci√≥n, Precio, Estado.
- **Acciones por Fila:**
  - **Ver Detalles:** Abre el mismo panel/modal que desde el calendario.
  - **Cambiar Estado:** Un dropdown para cambiar r√°pidamente el estado de una cita (ej: marcar como "Completada" al finalizar el servicio).
  - **Reenviar Email de Confirmaci√≥n:** Un bot√≥n para volver a enviar la notificaci√≥n al cliente.
  - **Gestionar Pago:** Ver el estado del pago de Stripe y realizar acciones (ej: registrar un pago en efectivo si fuera el caso).

**API Calls:**

- `GET /api/admin/appointments` (con todos los par√°metros de b√∫squeda y filtrado).
- `PUT /api/admin/appointments/[id]/status`



// ====== [62] docs/features/07-reviews-system.md ======
<!-- File: /docs/features/07-reviews-system.md - v1.0 -->
````markdown
# 7. Sistema de Valoraciones y Rese√±as

## 7.1. Objetivo

Implementar un ciclo de feedback completo que permita recopilar valoraciones de los clientes de forma automatizada y utilizar esas rese√±as como una potente herramienta de marketing y prueba social. El sistema debe dar al administrador control total sobre qu√© valoraciones se muestran p√∫blicamente.

## 7.2. Flujo del Cliente para Dejar una Valoraci√≥n

El proceso est√° dise√±ado para ser lo m√°s simple y proactivo posible, maximizando la tasa de respuesta.

1.  **Disparador (Trigger):** Un administrador cambia el estado de una cita a "Completada" en el panel de administraci√≥n.
2.  **Espera Programada:** El sistema espera un tiempo configurable (ej: 3 horas) para dar tiempo al cliente a disfrutar del resultado antes de pedirle una opini√≥n.
3.  **Notificaci√≥n Autom√°tica:** Pasado el tiempo de espera, se env√≠a un email y/o un mensaje de WhatsApp al cliente.
    - El mensaje agradece su visita.
    - Incluye una llamada a la acci√≥n clara, como "Valora tu experiencia en 1 minuto".
    - Proporciona dos enlaces:
      - **Enlace principal:** Un link seguro, √∫nico y de un solo uso que dirige a la p√°gina de valoraci√≥n del propio sitio web.
      - **Enlace secundario (opcional):** Un enlace directo para dejar una rese√±a en el perfil de Google Business de la empresa.
4.  **P√°gina de Valoraci√≥n:**
    - Al hacer clic en el enlace principal, el usuario llega a una p√°gina simple y sin distracciones.
    - La p√°gina ya sabe de qu√© cita se trata gracias al token en la URL.
    - **Formulario:**
      - **Calificaci√≥n General (Estrellas):** Un selector de 1 a 5 estrellas (obligatorio).
      - **Comentario:** Un √°rea de texto para que el cliente escriba su opini√≥n (opcional).
      - **Calificaci√≥n del Empleado (Opcional):** Si se desea, se puede a√±adir un segundo selector de estrellas para valorar espec√≠ficamente al t√©cnico que le atendi√≥.
    - **Env√≠o:** Al enviar, la valoraci√≥n se guarda en la base de datos con el estado inicial de **"Pendiente"**.

## 7.3. Panel de Moderaci√≥n para el Administrador (`/admin/reviews`)

**Prop√≥sito:** Dar al due√±o del negocio el control total sobre la reputaci√≥n online que se muestra en su propia web.

**Componentes Clave:**

- **Vista Principal:**
  - Una vista de "bandeja de entrada" con todas las valoraciones recibidas, ordenadas por fecha (las m√°s recientes primero).
  - Filtros para ver rese√±as por estado: "Pendientes", "Aprobadas", "Ocultas".
- **Tarjeta de Valoraci√≥n Individual:**
  - Cada valoraci√≥n pendiente se muestra claramente con toda su informaci√≥n:
    - Nombre del Cliente.
    - Servicio recibido.
    - Empleado que lo atendi√≥.
    - Fecha de la cita.
    - Calificaci√≥n en estrellas.
    - Texto completo del comentario.
- **Acciones de Moderaci√≥n:**
  - **Aprobar:** Cambia el estado a "Aprobada". La valoraci√≥n ser√° ahora visible en las secciones p√∫blicas de la web.
  - **Ocultar:** Cambia el estado a "Oculta". La valoraci√≥n se guarda para registros internos y anal√≠ticas, pero **no ser√° visible p√∫blicamente**. No se elimina.
  - **Destacar (Checkbox/Toggle):** Una opci√≥n adicional en las rese√±as aprobadas para marcarlas como "Destacadas" y que aparezcan en la p√°gina de inicio.

## 7.4. Modelo de Datos (Esquema Prisma)

```prisma
model Review {
  id            String      @id @default(cuid())
  rating        Int         // Calificaci√≥n de 1 a 5
  comment       String?     @db.Text
  status        ReviewStatus @default(PENDING) // PENDING, APPROVED, HIDDEN
  isFeatured    Boolean     @default(false)    // Para la homepage

  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  // Relaciones
  appointment   Appointment @relation(fields: [appointmentId], references: [id])
  appointmentId String      @unique // Cada cita solo puede tener una rese√±a

  user          User        @relation(fields: [userId], references: [id])
  userId        String

  employee      Employee    @relation(fields: [employeeId], references: [id])
  employeeId    String
}

enum ReviewStatus {
  PENDING
  APPROVED
  HIDDEN
}
```
````

## 7.5. Endpoints de la API

- `GET /api/reviews/request?token=[TOKEN]`: Valida el token de un solo uso y muestra la p√°gina/formulario para dejar la valoraci√≥n.
- `POST /api/reviews?token=[TOKEN]`: Endpoint para que el cliente env√≠e su valoraci√≥n. Valida el token antes de guardar los datos.
- `GET /api/reviews`: Endpoint p√∫blico que devuelve todas las rese√±as con estado "APROBADA" para las p√°ginas `/reviews` y la homepage. Permite filtrar por empleado y servicio.
- `GET /api/admin/reviews`: Endpoint protegido para que el administrador obtenga todas las rese√±as, incluyendo las pendientes y ocultas.
- `PUT /api/admin/reviews/[id]`: Endpoint protegido para que el administrador actualice el estado (`status`) o la propiedad `isFeatured` de una rese√±a.

```

```




// ====== [63] docs/features/08-marketing-monetization.md ======
<!-- File: /docs/features/08-marketing-monetization.md - v1.0 -->
````markdown
# 8. M√≥dulos de Marketing y Monetizaci√≥n

## 8.1. Objetivo

Crear un conjunto de herramientas integradas en la plataforma para diversificar las fuentes de ingresos, aumentar el valor de vida del cliente (LTV) y fomentar la lealtad a la marca. Estos m√≥dulos transforman la web de una simple herramienta de reservas a una plataforma de crecimiento para el negocio.

## 8.2. Desglose de M√≥dulos

### M√≥dulo 1: Gesti√≥n de Bonos (Bundles)

**Prop√≥sito:** Incentivar la compra por adelantado de m√∫ltiples servicios a un precio reducido, asegurando ingresos y visitas futuras.

**Funcionalidad en el Panel de Administraci√≥n (`/admin/marketing/bonuses`):**

- **CRUD de Bonos:** Interfaz para crear, editar y desactivar ofertas de bonos.
- **Formulario de Creaci√≥n/Edici√≥n:**
  - **Nombre del Bono:** Ej: "Bono 5 Lavados Premium".
  - **Servicio Asociado:** Selecci√≥n de un √∫nico servicio del cat√°logo.
  - **Cantidad de Usos:** Ej: 5.
  - **Precio Total:** Precio con descuento por el paquete completo.
  - **Periodo de Validez (Opcional):** Ej: "V√°lido por 12 meses desde la compra".
  - **Estado:** Activo / Inactivo.

**Experiencia del Cliente:**

- Una secci√≥n en el sitio p√∫blico para comprar estos bonos.
- El pago se realiza a trav√©s de Stripe.
- En su "Panel de Cliente", el usuario puede ver sus bonos activos y los usos restantes.
- Durante el flujo de reserva, si el cliente elige un servicio para el que tiene un bono con usos disponibles, el sistema le ofrecer√° la opci√≥n de "Usar 1 cr√©dito del bono" en lugar de pagar.

**Modelo de Datos (Prisma):**

```prisma
// Definici√≥n del bono que se puede comprar
model BonusOffering {
  id          String   @id @default(cuid())
  name        String
  price       Float
  uses        Int
  validityDays Int?
  isActive    Boolean  @default(true)

  service     Service  @relation(fields: [serviceId], references: [id])
  serviceId   String
}

// Instancia de un bono comprado por un cliente
model PurchasedBonus {
  id              String   @id @default(cuid())
  usesRemaining   Int
  expiresAt       DateTime?

  user            User     @relation(fields: [userId], references: [id])
  userId          String

  bonusOffering   BonusOffering @relation(fields: [bonusOfferingId], references: [id])
  bonusOfferingId String
}
```
````

### M√≥dulo 2: Tarjetas Regalo (Gift Cards)

**Prop√≥sito:** Abrir una nueva v√≠a de ingresos permitiendo que los servicios del lavadero sean regalados, ideal para ocasiones especiales.

**Funcionalidad en el Panel de Administraci√≥n:**

- No requiere gesti√≥n activa m√°s all√° de tener los servicios marcados como "regalables".
- Una secci√≥n para visualizar las tarjetas regalo vendidas y su estado (canjeada/no canjeada).

**Experiencia del Cliente (Comprador y Receptor):**

- P√°gina p√∫blica `/gift-cards` para la compra.
- El comprador elige un servicio, introduce los datos del destinatario y un mensaje personalizado.
- Tras el pago con Stripe, el sistema genera un **c√≥digo de regalo √∫nico**.
- Se env√≠a un email al destinatario (o al comprador) con un dise√±o de tarjeta regalo digital que incluye el c√≥digo.
- El receptor de la tarjeta puede canjear el c√≥digo durante el paso de pago del flujo de reserva, lo que aplicar√° un descuento del 100%.

**Modelo de Datos (Prisma):**

```prisma
model GiftCard {
  id            String    @id @default(cuid())
  code          String    @unique // C√≥digo alfanum√©rico √∫nico
  isRedeemed    Boolean   @default(false)
  redeemedAt    DateTime?
  recipientEmail String?
  message       String?   @db.Text

  // Relaciones
  service       Service   @relation(fields: [serviceId], references: [id])
  serviceId     String

  purchaseOrder Order     @relation(fields: [orderId], references: [id])
  orderId       String
}
```

### M√≥dulo 3: Suscripciones (Club de Lavado)

**Prop√≥sito:** Generar ingresos mensuales recurrentes y predecibles, creando una base de clientes de alta fidelidad.

**Funcionalidad en el Panel de Administraci√≥n (`/admin/marketing/subscriptions`):**

- **CRUD de Planes de Suscripci√≥n:**
  - **Nombre del Plan:** Ej: "Club AquaClean Oro".
  - **Precio Mensual:** Ej: 49.99‚Ç¨.
  - **Beneficios Incluidos:**
    - Una interfaz para definir cu√°ntos usos de qu√© servicios incluye al mes (ej: "2 Lavados Premium", "4 Lavados B√°sicos").
  - **Integraci√≥n con Stripe Products & Prices** para gestionar la facturaci√≥n recurrente.

**Experiencia del Cliente:**

- P√°gina p√∫blica `/club` para ver y suscribirse a los planes.
- El pago mensual es autom√°tico a trav√©s de Stripe.
- En su panel, el cliente ve su estado de suscripci√≥n y los servicios que puede usar ese mes.
- Al igual que con los bonos, al reservar un servicio incluido en su plan, puede canjearlo sin coste adicional.

### M√≥dulo 4: Programa de Fidelizaci√≥n (Puntos)

**Prop√≥sito:** Recompensar la recurrencia, incentivando a los clientes a volver para acumular beneficios.

**Funcionalidad en el Panel de Administraci√≥n (`/admin/marketing/loyalty`):**

- **Configuraci√≥n del Programa:**
  - Definir la regla de acumulaci√≥n (ej: "1‚Ç¨ gastado = 1 punto").
  - Definir las recompensas (ej: "500 puntos = 1 Lavado B√°sico Gratis").
- El sistema asignar√° los puntos autom√°ticamente despu√©s de cada cita completada.

**Experiencia del Cliente:**

- En su panel (`/dashboard/benefits`), el cliente ve su saldo de puntos.
- El cliente es notificado cuando alcanza los puntos necesarios para una recompensa.
- Se le proporciona un c√≥digo de descuento o una opci√≥n en el flujo de reserva para canjear su recompensa.

## 8.3. Endpoints de la API

- `GET /api/bonuses`: Devuelve los bonos disponibles para la compra.
- `POST /api/bonuses/purchase`: Inicia la compra de un bono.
- `POST /api/gift-cards/purchase`: Inicia la compra de una tarjeta regalo.
- `POST /api/bookings/redeem`: Endpoint para canjear bonos, tarjetas regalo o puntos durante la reserva.
- `GET /api/admin/marketing/...`: Endpoints protegidos para toda la gesti√≥n de estos m√≥dulos.

```

```




// ====== [64] docs/features/09-notifications-system.md ======
<!-- File: /docs/features/09-notifications-system.md - v1.0 -->
# 9. Sistema de Notificaciones

## 9.1. Objetivo

Establecer un sistema de comunicaci√≥n proactivo y automatizado para mantener informados tanto a los clientes como al personal del negocio en cada etapa clave del ciclo de vida de una cita. Los objetivos principales son: mejorar la experiencia del cliente, reducir dr√°sticamente la tasa de no presentaci√≥n (no-shows) y minimizar la carga de trabajo administrativo.

## 9.2. Stack Tecnol√≥gico

| Canal        | Tecnolog√≠a                 | Prop√≥sito                                                                                                                                                   |
| :----------- | :------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Email**    | **Nodemailer**             | Env√≠o de correos electr√≥nicos transaccionales robustos. Se utilizar√°n plantillas HTML (ej: `mjml` o `react-email`) para un dise√±o profesional y responsivo. |
| **WhatsApp** | **Twilio API (o similar)** | Env√≠o de mensajes de WhatsApp para notificaciones de alta prioridad como recordatorios y confirmaciones.                                                    |

## 9.3. Notificaciones para el Cliente

Estas notificaciones se env√≠an al cliente para guiarlo y mantenerlo informado.

| Evento Desencadenante                | Canal(es)       | Contenido Clave                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| :----------------------------------- | :-------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **Registro de Nueva Cuenta**         | Email           | **Asunto:** "Confirma tu cuenta en AquaClean".<br>Contiene un enlace de verificaci√≥n √∫nico y de un solo uso para activar la cuenta.                                                                                                                                                                                                                                                                                                                                             |
| **Solicitud de Contrase√±a Olvidada** | Email           | **Asunto:** "Restablece tu contrase√±a de AquaClean".<br>Contiene un enlace seguro para que el usuario pueda establecer una nueva contrase√±a.                                                                                                                                                                                                                                                                                                                                    |
| **Reserva de Cita Exitosa**          | Email, WhatsApp | **Asunto (Email):** "Tu cita en AquaClean est√° confirmada para el [Fecha] a las [Hora]".<br> **Mensaje (WhatsApp):** "¬°Hola [Nombre]! üëã Tu cita en AquaClean para un [Servicio] el [Fecha] a las [Hora] est√° confirmada. ¬°Te esperamos!".<br>El email **debe** incluir un archivo adjunto `.ics` para que el cliente pueda a√±adir la cita a su calendario (Google, Apple, etc.) con un solo clic. Tambi√©n incluir√° un resumen completo: servicio, empleado, direcci√≥n y coste. |
| **Recordatorio de Cita (24h antes)** | Email, WhatsApp | **Asunto (Email):** "Recordatorio: Tu cita en AquaClean es ma√±ana".<br> **Mensaje (WhatsApp):** "¬°Recordatorio! Ma√±ana a las [Hora] tienes tu cita para un [Servicio] en AquaClean. Si necesitas cambiarla, cont√°ctanos. ¬°Nos vemos pronto!".<br>Incluye opciones para confirmar la asistencia o contactar para reagendar.                                                                                                                                                      |
| **Cancelaci√≥n de Cita**              | Email           | **Asunto:** "Tu cita en AquaClean ha sido cancelada".<br>Confirma que la cita para el [Fecha] ha sido cancelada correctamente. Si aplica, informa sobre la pol√≠tica de reembolso.                                                                                                                                                                                                                                                                                               |
| **Cita Marcada como "Completada"**   | Email, WhatsApp | **Asunto (Email):** "¬°Gracias por tu visita a AquaClean! ¬øQu√© tal ha ido?".<br> **Mensaje (WhatsApp):** "¬°Gracias por visitarnos, [Nombre]! Esperamos que tu coche haya quedado impecable ‚ú®. ¬øTe importar√≠a dejarnos tu opini√≥n en 1 minuto? [Enlace a la p√°gina de valoraci√≥n]".<br>Se env√≠a tras un lapso de tiempo configurable (ej: 3 horas). Contiene el enlace para dejar una rese√±a en la web y/o en Google.                                                            |

## 9.4. Notificaciones para la Empresa (Administrador)

Estas notificaciones se env√≠an al personal para mantenerlos al tanto de la actividad de los clientes en tiempo real.

| Evento Desencadenante             | Canal(es)       | Contenido Clave                                                                                                                                                                                                                                                                                                                                     |
| :-------------------------------- | :-------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Nueva Reserva Realizada**       | Email, WhatsApp | **Asunto (Email):** "Nueva Reserva: [Servicio] para el [Fecha] a las [Hora]".<br> **Mensaje (WhatsApp):** "üîî ¬°Nueva Reserva! Cliente: [Nombre Cliente]. Servicio: [Servicio]. D√≠a: [Fecha] a las [Hora]. Empleado: [Nombre Empleado]".<br>Proporciona todos los detalles de la nueva cita para una visi√≥n r√°pida sin necesidad de entrar al panel. |
| **Cliente Cancela una Cita**      | Email, WhatsApp | **Asunto (Email):** "Cancelaci√≥n de Cita: [Nombre Cliente] para el [Fecha]".<br> **Mensaje (WhatsApp):** "‚ö†Ô∏è Cancelaci√≥n. El cliente [Nombre Cliente] ha cancelado su cita para el [Fecha] a las [Hora]".<br>Permite al administrador reaccionar r√°pidamente y, si es necesario, contactar a otros clientes para ocupar el hueco.                   |
| **Cliente Solicita Cambiar Cita** | Email           | **Asunto:** "Solicitud de Cambio de Cita de [Nombre Cliente]".<br>Informa al administrador que un cliente ha solicitado un cambio y le dirige al panel de administraci√≥n para gestionar la petici√≥n.                                                                                                                                                |

## 9.5. Implementaci√≥n en el Backend

- Se crear√° un `NotificationService` centralizado en el backend.
- Este servicio ser√° invocado por otros servicios de la aplicaci√≥n (ej: `BookingService`, `AuthService`) cuando ocurran los eventos relevantes.
- El `NotificationService` contendr√° la l√≥gica para:
  1.  Seleccionar la plantilla de mensaje adecuada (para email o WhatsApp).
  2.  Rellenar la plantilla con los datos din√°micos (nombre del cliente, fecha de la cita, etc.).
  3.  Invocar al proveedor correspondiente (`Nodemailer` o `Twilio`) para realizar el env√≠o.
- Se implementar√° un sistema de colas (opcional pero recomendado para escalar) para procesar los env√≠os de notificaciones de forma as√≠ncrona, evitando que la aplicaci√≥n se ralentice mientras espera la respuesta de las APIs externas.




// ====== [65] docs/features/10-external-integrations.md ======
<!-- File: /docs/features/10-external-integrations.md - v1.0 -->
````markdown
# 10. Integraciones Externas

## 10.1. Objetivo

Integrar la plataforma con servicios de terceros l√≠deres en su sector para incorporar funcionalidades cr√≠ticas de forma robusta y segura. Esto nos permite centrarnos en el valor a√±adido de nuestra aplicaci√≥n mientras delegamos tareas complejas como el procesamiento de pagos y la sincronizaci√≥n de calendarios a APIs especializadas.

## 10.2. Pasarela de Pagos: Stripe

**Prop√≥sito:** Gestionar todas las transacciones monetarias de la plataforma, desde citas individuales hasta la compra de bonos y suscripciones recurrentes.

### Funcionalidades Clave

- **Procesamiento de Pagos √önicos:** Aceptar pagos con tarjeta de cr√©dito/d√©bito para reservas de citas y compra de tarjetas regalo.
- **Gesti√≥n de Suscripciones:** Automatizar los cobros mensuales para los clientes del "Club de Lavado" a trav√©s de **Stripe Billing**.
- **Seguridad y Cumplimiento PCI:** Delegar el manejo de la informaci√≥n sensible de las tarjetas a Stripe, asegurando el m√°ximo nivel de seguridad y cumplimiento normativo.
- **Portal de Cliente de Stripe (Opcional):** Permitir a los clientes suscritos gestionar sus m√©todos de pago y facturas directamente a trav√©s de un portal alojado por Stripe.

### Flujo de Implementaci√≥n

1.  **Configuraci√≥n:**

    - Se crear√°n cuentas de Producto y Precio en el dashboard de Stripe para cada servicio, bono y plan de suscripci√≥n.
    - Las claves de API (p√∫blica y secreta) de Stripe se configurar√°n en las variables de entorno del backend.

2.  **Flujo de Pago √önico (para Citas/Regalos):**

    - **Frontend:**
      - Se utilizar√° la librer√≠a `@stripe/react-stripe-js`.
      - Al llegar al paso de pago, el cliente solicitar√° un `client_secret` a nuestra API.
      - Se renderizar√° el componente `PaymentElement` de Stripe, que es un formulario de pago seguro y unificado.
    - **Backend:**
      - Se crear√° un endpoint `POST /api/payments/create-intent`.
      - Este endpoint calcular√° el importe total y crear√° un `PaymentIntent` en Stripe, devolviendo su `client_secret` al frontend.
    - **Confirmaci√≥n:**
      - Tras el env√≠o del formulario por parte del cliente, Stripe procesar√° el pago.
      - El backend escuchar√° los **Webhooks** de Stripe (evento `payment_intent.succeeded`) para confirmar el pago de forma fiable y, en ese momento, finalizar√° la creaci√≥n de la reserva en la base de datos.

3.  **Flujo de Suscripciones:**
    - Se utilizar√° Stripe Checkout o el Payment Element para la suscripci√≥n inicial.
    - El backend crear√° un `Customer` en Stripe para cada usuario que se suscriba.
    - Se crear√°n objetos `Subscription` en Stripe, que gestionar√°n los cobros recurrentes autom√°ticamente.
    - Los Webhooks (`invoice.paid`, `customer.subscription.deleted`, etc.) ser√°n esenciales para mantener el estado de la suscripci√≥n sincronizado en nuestra base de datos.

### Modelo de Datos (Prisma)

```prisma
model User {
  // ... campos existentes
  stripeCustomerId String? @unique // ID del cliente en Stripe
}

model Appointment {
  // ... campos existentes
  paymentIntentId String? @unique // ID del intento de pago de Stripe
  paymentStatus   PaymentStatus @default(PENDING)
}

enum PaymentStatus {
  PENDING
  SUCCEEDED
  FAILED
}
```
````

## 10.3. Sincronizaci√≥n de Calendario: Google Calendar

**Prop√≥sito:** Ofrecer una conexi√≥n opcional para el administrador que sincroniza la agenda de la plataforma con un Google Calendar de la empresa, mejorando la visibilidad y la gesti√≥n de la disponibilidad desde fuera de la aplicaci√≥n.

### Funcionalidades Clave

- **Sincronizaci√≥n de Citas (App -> Google Calendar):**
  - Cuando una cita se crea, reagenda o cancela en nuestra plataforma, el evento correspondiente se crea, actualiza o elimina autom√°ticamente en el Google Calendar del negocio.
- **Sincronizaci√≥n de Disponibilidad (Google Calendar -> App):**
  - Cuando el administrador crea un evento manual en su Google Calendar (ej: "Cita M√©dica", "Reuni√≥n"), el sistema de nuestra aplicaci√≥n lo detectar√° como un "bloqueo de tiempo".
  - Ese intervalo de tiempo se marcar√° como no disponible en el calculador de disponibilidad de la web, evitando que los clientes puedan reservar en ese hueco.

### Flujo de Implementaci√≥n

1.  **Autorizaci√≥n (OAuth 2.0):**

    - En el panel de administraci√≥n, habr√° una secci√≥n de "Integraciones".
    - El administrador har√° clic en "Conectar con Google Calendar".
    - Esto iniciar√° un flujo de consentimiento de OAuth 2.0 donde el administrador autoriza a nuestra aplicaci√≥n a gestionar su calendario.
    - El backend recibir√° y almacenar√° de forma segura las credenciales de OAuth (access token y refresh token) asociadas a la cuenta del negocio.

2.  **Creaci√≥n y Modificaci√≥n de Eventos:**

    - Cuando se crea una cita, el backend utilizar√° las credenciales guardadas para llamar a la API de Google Calendar y crear un nuevo evento.
    - La informaci√≥n del evento incluir√°: nombre del servicio, nombre del cliente y empleado asignado.
    - El `googleEventId` devuelto por la API se guardar√° en nuestro modelo `Appointment`.
    - Para actualizar o cancelar, se usar√° ese `googleEventId` guardado para modificar el evento correcto.

3.  **Lectura de Disponibilidad:**
    - Cuando el sistema calcula los huecos disponibles para un d√≠a, adem√°s de mirar las citas en nuestra propia base de datos, har√° una llamada a la API de Google (`freebusy`) para consultar los periodos de tiempo ocupados en el calendario del administrador.
    - Estos periodos ocupados se restar√°n de la disponibilidad total.

### Modelo de Datos (Prisma)

```prisma
model Appointment {
  // ... campos existentes
  googleEventId String? @unique // ID del evento en Google Calendar
}

// Modelo para guardar las credenciales de la empresa
model AccountSettings {
  id                    String @id @default(cuid())
  googleAccessToken     String? @db.Text
  googleRefreshToken    String? @db.Text
  googleTokenExpiryDate DateTime?
  // ... otras configuraciones del negocio
}
```




// ====== [66] package.json ======
{
  "name": "aquaclean-car-wash-monorepo",
  "version": "1.0.0",
  "private": true,
  "description": "Plataforma de gesti√≥n y reservas para AquaClean Car Wash",
  "author": "R3v180",
  "license": "UNLICENSED",
  "scripts": {
    "dev": "turbo run dev --parallel",
    "build": "turbo run build",
    "lint": "turbo run lint",
    "format": "prettier --write \"**/*.{ts,tsx,md,json}\""
  },
  "devDependencies": {
    "@typescript-eslint/eslint-plugin": "^7.10.0",
    "@typescript-eslint/parser": "^7.10.0",
    "eslint": "^8.57.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-react": "^7.34.1",
    "eslint-plugin-react-hooks": "^4.6.2",
    "prettier": "^3.2.5",
    "turbo": "^1.13.3",
    "typescript": "^5.4.5",
    "zod": "^3.23.8"
  },
  "packageManager": "pnpm@9.1.1"
}


// ====== [67] packages/config/eslint-preset.js ======
// File: /packages/config/eslint-preset.js - v1.0

module.exports = {
  extends: [
    'eslint:recommended',
    'plugin:@typescript-eslint/recommended',
    'plugin:react/recommended',
    'plugin:react-hooks/recommended',
    'prettier',
  ],
  parser: '@typescript-eslint/parser',
  plugins: ['@typescript-eslint'],
  env: {
    browser: true,
    node: true,
    es2021: true,
  },
  settings: {
    react: {
      version: 'detect',
    },
  },
  rules: {
    // Reglas de TypeScript
    '@typescript-eslint/no-unused-vars': [
      'warn',
      { argsIgnorePattern: '^_', varsIgnorePattern: '^_' },
    ],
    '@typescript-eslint/no-explicit-any': 'warn',

    // Reglas de React
    'react/prop-types': 'off', // No necesitamos prop-types porque usamos TypeScript
    'react/react-in-jsx-scope': 'off', // No es necesario importar React en el scope con React 17+
    'react/jsx-uses-react': 'off',

    // Reglas generales de ESLint
    'no-console': ['warn', { allow: ['warn', 'error'] }],
  },
  ignorePatterns: [
    'node_modules/',
    'dist/',
    'build/',
    '.turbo/',
    'coverage/',
  ],
};


// ====== [68] packages/config/package.json ======
{
  "name": "@aquaclean/config",
  "version": "1.0.0",
  "private": true,
  "main": "index.js",
  "files": [
    "eslint-preset.js"
  ],
  "devDependencies": {
    "@typescript-eslint/eslint-plugin": "^7.10.0",
    "@typescript-eslint/parser": "^7.10.0",
    "eslint": "^8.57.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-react": "^7.34.1",
    "eslint-plugin-react-hooks": "^4.6.2",
    "typescript": "^5.4.5"
  }
}


// ====== [69] packages/types/package.json ======
{
  "name": "@aquaclean/types",
  "version": "1.0.0",
  "private": true,
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    ".": {
      "import": "./dist/index.js",
      "require": "./dist/index.js",
      "types": "./dist/index.d.ts"
    }
  },
  "scripts": {
    "build": "tsc",
    "dev": "tsc --watch",
    "lint": "eslint . --ext .ts"
  },
  "peerDependencies": {
    "zod": ">=3.0.0"
  },
  "devDependencies": {
    "typescript": "^5.4.5"
  }
}


// ====== [70] packages/types/src/employee.schema.ts ======
// File: /packages/types/src/employee.schema.ts (ACTUALIZADO)

import { z } from 'zod';

// Esquema para la creaci√≥n/edici√≥n de un nuevo empleado
export const createEmployeeSchema = z.object({
  name: z.string().min(1, { message: 'El nombre es requerido.' }).min(3, { message: 'El nombre debe tener al menos 3 caracteres.' }),

  email: z.string().min(1, { message: 'El email es requerido.' }).email({ message: 'El formato del email no es v√°lido.' }),

  role: z.enum(['ADMIN', 'EMPLOYEE']),

  bio: z.string().optional(),

  imageUrl: z
    .string()
    .url({ message: 'La URL de la imagen no es v√°lida.' })
    .or(z.literal(''))
    .optional(),
  
  // --- L√çNEA A√ëADIDA ---
  status: z.enum(['ACTIVE', 'ARCHIVED']).optional(),
  
  workSchedule: z.record(z.string(), z.unknown()).optional(),
});


// ====== [71] packages/types/src/index.ts ======
// File: /packages/types/src/index.ts (ACTUALIZADO)

// Exportamos los esquemas desde su nueva ubicaci√≥n local
export * from './service.schema';
export * from './employee.schema'; // <-- L√çNEA A√ëADIDA

// Exportamos las interfaces de tipos
export * from './service';

export interface User {
  id: string;
  name: string | null;
  email: string;
  emailVerified: Date | null;
  image: string | null;
  role: 'ADMIN' | 'CUSTOMER';
}


// ====== [72] packages/types/src/service.schema.ts ======
// File: /packages/types/src/service.schema.ts (ACTUALIZADO)

import { z } from 'zod';

// Definimos el esquema de validaci√≥n para la creaci√≥n/edici√≥n de un servicio.
export const createServiceSchema = z.object({
  name: z.string().min(1, { message: 'El nombre es requerido.' }).min(3, { message: 'El nombre debe tener al menos 3 caracteres.' }),

  description: z.string().min(1, { message: 'La descripci√≥n es requerida.' }).min(10, { message: 'La descripci√≥n debe tener al menos 10 caracteres.' }),

  duration: z.coerce.number()
    .int({ message: 'La duraci√≥n debe ser un n√∫mero entero.' })
    .positive({ message: 'La duraci√≥n debe ser un n√∫mero positivo.' }),

  prices: z.record(z.string(), z.number()).refine(obj => Object.keys(obj).length > 0, {
    message: 'Se requiere al menos un precio.',
  }),
  
  category: z.string().min(1, { message: 'La categor√≠a es requerida.' }),

  // --- L√çNEA A√ëADIDA ---
  isActive: z.boolean().optional(),

  isAddon: z.boolean().optional(),
  isGiftable: z.boolean().optional(),
  isFeatured: z.boolean().optional(),
});


// ====== [73] packages/types/src/service.ts ======
// File: /packages/types/src/service.ts (ACTUALIZADO)

export interface Service {
  id: string;
  name: string;
  description: string;
  duration: number; // en minutos
  // --- L√çNEA MODIFICADA ---
  prices: {
    standard: number;
    // Podemos a√±adir m√°s tipos de precios en el futuro si es necesario
    [key: string]: number; 
  };
  // --- FIN DE LA MODIFICACI√ìN ---
  category: string;
  isActive: boolean;
  isAddon: boolean;
  isGiftable: boolean;
  isFeatured: boolean;
}


// ====== [74] packages/types/tsconfig.json ======
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "dist",
    "declaration": true,
    "noEmit": false
  },
  "include": ["src/**/*.ts"],
  "exclude": ["node_modules", "dist"]
}


// ====== [75] tsconfig.base.json ======
// File: /tsconfig.base.json - v1.0
{
  "compilerOptions": {
    /* Base Options */
    "esModuleInterop": true,
    "skipLibCheck": true,
    "target": "ESNext",
    "allowJs": true,
    "resolveJsonModule": true,
    "moduleResolution": "bundler",
    "isolatedModules": true,

    /* Strictness */
    "strict": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitAny": true,

    /* Transpilation */
    "module": "ESNext",
    "jsx": "react-jsx",
    "noEmit": true,

    /* Path Aliases */
    "baseUrl": ".",
    "paths": {
      "@aquaclean/types": ["packages/types/src"],
      "@aquaclean/config/*": ["packages/config/*"]
    }
  }
}


// ====== [76] tsconfig.json ======
// File: /tsconfig.json - v1.0
{
  "files": [],
  "references": [
    { "path": "apps/client" },
    { "path": "apps/server" },
    { "path": "packages/types" },
    { "path": "packages/config" }
  ]
}


// ====== [77] turbo.json ======
{
  "$schema": "./.schemas/turbo-schema-v1.json",
  "globalDependencies": ["tsconfig.base.json"],
  "pipeline": {
    "dev": {
      "cache": false,
      "persistent": true
    },
    "build": {
      "dependsOn": ["^build"],
      "outputs": ["dist/**"]
    },
    "lint": {
      "outputs": []
    },
    "format": {
      "outputs": []
    }
  }
}

